<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Mastery Quest â€“ Professional Edition 6.3.8.0.0.1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--
    Provide a descriptive summary of what this page offers. This helps search engines
    understand the content and improves SEO when the file is hosted publicly (for
    example on GitHub Pages). Keep the description concise and in plain language.
  -->
  <meta name="description" content="Violin Mastery Quest is an interactive training app designed to help violinists practice notes, positions and music theory through responsive exercises and engaging challenges." />
  <meta name="color-scheme" content="light dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#f8fafc;
      --card:#fff;
      --ink:#0f172a;
      --ink-light:#475569;
      --primary:#3a5ba0;
      --primary-dark:#2f4b7e;
      --primary-light:#5a7bc0;
      --success:#009e73;
      --warning:#e69f00;
      --danger:#d55e00;
      --neutral:#6c757d;
      --accent:#8b5cf6;
      --accent-light:#a78bfa;
      --border:rgba(0,0,0,0.1);
      --shadow:rgba(0,0,0,0.08);
      --gradient-1:#667eea;
      --gradient-2:#764ba2;
    }
    :root.dark {
      --bg:#0b1426;
      --card:#0f1f3d;
      --ink:#e2e8f0;
      --ink-light:#94a3b8;
      --primary:#4a78b6;
      --primary-dark:#355a8a;
      --primary-light:#6a98d6;
      --success:#00b58a;
      --warning:#f3ae3d;
      --danger:#d5672f;
      --neutral:#6b7280;
      --accent:#9f7aea;
      --accent-light:#b794f4;
      --border:rgba(255,255,255,0.15);
      --shadow:rgba(0,0,0,0.3);
    }
    
    * { box-sizing: border-box; }
    
    body {
      margin:0;
      font-family: 'Inter', sans-serif;
      background:var(--bg);
      color:var(--ink);
      padding-bottom:80px;
      line-height:1.6;
    }
    
    .container {
      max-width: 1000px;
      margin:auto;
      padding:1rem;
    }
    
    .card {
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:1.5rem 1.75rem;
      margin-bottom:1.5rem;
      box-shadow:0 4px 24px var(--shadow);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow:0 8px 32px var(--shadow);
    }
    
    .card-compact {
      padding:1rem 1.25rem;
    }
    
    h1, h2, h3 {
      margin-top:0;
      line-height:1.2;
    }
    
    h1 {
      font-size:2rem;
      font-weight:800;
      background:linear-gradient(135deg, var(--gradient-1), var(--gradient-2));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      margin-bottom:0.5rem;
    }
    
    h2 {
      font-size:1.5rem;
      font-weight:700;
      color:var(--ink);
    }
    
    h3 {
      font-size:1.15rem;
      font-weight:600;
      color:var(--ink);
    }
    
    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:0.5rem;
      padding:0.75rem 1.5rem;
      border-radius:12px;
      margin:0.25rem;
      border:none;
      font-weight:600;
      cursor:pointer;
      color:#fff;
      font-size:0.95rem;
      transition: all 0.2s ease;
      position:relative;
      overflow:hidden;
    }
    
    .btn::before {
      content:'';
      position:absolute;
      top:50%;
      left:50%;
      width:0;
      height:0;
      border-radius:50%;
      background:rgba(255,255,255,0.3);
      transform:translate(-50%,-50%);
      transition: width 0.6s ease, height 0.6s ease;
    }
    
    .btn:active::before {
      width:300px;
      height:300px;
    }
    
    .btn-primary { background:var(--primary); }
    .btn-primary:hover { background:var(--primary-dark); transform:translateY(-2px); box-shadow:0 4px 12px var(--shadow); }
    .btn-primary:active { transform:translateY(0); }
    
    .btn-secondary { background:var(--ink-light); }
    .btn-secondary:hover { background:var(--ink); transform:translateY(-2px); }
    
    .btn-success { background:var(--success); }
    .btn-success:hover { filter:brightness(1.1); transform:translateY(-2px); }
    
    .btn-warning { background:var(--warning); }
    .btn-danger { background:var(--danger); }
    .btn-accent { background:var(--accent); }
    .btn-accent:hover { background:var(--accent-light); transform:translateY(-2px); }
    
    .btn-large {
      padding:1rem 2rem;
      font-size:1.1rem;
      border-radius:16px;
    }
    
    .btn:disabled {
      opacity:0.5;
      cursor:not-allowed;
      transform:none !important;
    }
    
    .grid {
      display:grid;
      gap:1rem;
    }
    
    .grid-cols-2 { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .grid-cols-3 { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
    
    .option-btn {
      width:100%;
      padding:0.875rem 1rem;
      border-radius:12px;
      margin:0.35rem 0;
      color:#fff;
      border:2px solid transparent;
      cursor:pointer;
      font-weight:600;
      font-size:1rem;
      transition: all 0.2s ease;
      position:relative;
      text-align:left;
    }
    
    .option-btn:hover:not(:disabled) {
      transform:translateX(4px);
      border-color:rgba(255,255,255,0.3);
    }
    
    .option-btn:disabled {
      cursor:not-allowed;
      opacity:0.7;
    }
    
    .option-btn.correct {
      background:var(--success) !important;
      animation: correctPulse 0.5s ease;
    }
    
    .option-btn.incorrect {
      background:var(--danger) !important;
      animation: shake 0.4s ease;
    }
    
    @keyframes correctPulse {
      0%, 100% { transform:scale(1); }
      50% { transform:scale(1.03); }
    }
    
    @keyframes shake {
      0%, 100% { transform:translateX(0); }
      25% { transform:translateX(-8px); }
      75% { transform:translateX(8px); }
    }
    
    @keyframes slideIn {
      from { opacity:0; transform:translateY(20px); }
      to { opacity:1; transform:translateY(0); }
    }
    
    @keyframes celebrate {
      0%, 100% { transform:scale(1) rotate(0deg); }
      25% { transform:scale(1.1) rotate(-5deg); }
      75% { transform:scale(1.1) rotate(5deg); }
    }
    
    .stat-card {
      background:linear-gradient(135deg, var(--primary), var(--primary-dark));
      color:#fff;
      padding:1.25rem;
      border-radius:12px;
      text-align:center;
      box-shadow:0 4px 16px var(--shadow);
    }
    
    .stat-value {
      font-size:2.5rem;
      font-weight:800;
      line-height:1;
      margin:0.5rem 0;
    }
    
    .stat-label {
      font-size:0.9rem;
      opacity:0.9;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    
    .progress-bar {
      height:12px;
      background:var(--border);
      border-radius:9999px;
      overflow:hidden;
      position:relative;
    }
    
    .progress-fill {
      height:100%;
      background:linear-gradient(90deg, var(--gradient-1), var(--gradient-2));
      border-radius:9999px;
      transition: width 0.5s ease;
      position:relative;
    }
    
    .progress-fill::after {
      content:'';
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 2s infinite;
    }
    
    @keyframes shimmer {
      0% { transform:translateX(-100%); }
      100% { transform:translateX(100%); }
    }
    
    .badge {
      display:inline-flex;
      align-items:center;
      gap:0.35rem;
      padding:0.35rem 0.75rem;
      background:var(--accent);
      color:#fff;
      border-radius:9999px;
      font-size:0.85rem;
      font-weight:600;
      margin:0.25rem;
    }
    
    .badge-large {
      padding:0.75rem 1.25rem;
      font-size:1.1rem;
      animation: celebrate 1s ease;
    }
    
    .streak-fire {
      font-size:1.5rem;
      animation: flicker 1.5s infinite alternate;
    }
    
    @keyframes flicker {
      0%, 100% { opacity:1; transform:scale(1); }
      50% { opacity:0.8; transform:scale(1.1); }
    }
    
    .heat-cell {
      height:2.5rem;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:0.8rem;
      font-weight:600;
      color:#fff;
      border-radius:6px;
      transition: transform 0.2s ease;
      cursor:help;
    }
    
    .heat-cell:hover {
      transform:scale(1.05);
      box-shadow:0 2px 8px var(--shadow);
    }
    
    .toast {
      position:fixed;
      top:20px;
      right:20px;
      background:var(--card);
      border:2px solid var(--border);
      border-radius:12px;
      padding:1rem 1.5rem;
      box-shadow:0 8px 24px var(--shadow);
      animation: slideIn 0.3s ease;
      z-index:1000;
      max-width:320px;
    }
    
    .toast-success { border-color:var(--success); }
    .toast-warning { border-color:var(--warning); }
    
    .pulse-ring {
      position:absolute;
      border:3px solid var(--success);
      border-radius:50%;
      animation: pulse-ring 1.5s ease-out infinite;
    }
    
    @keyframes pulse-ring {
      0% { transform:scale(0.8); opacity:1; }
      100% { transform:scale(1.4); opacity:0; }
    }
    
    .metronome-beat {
      width:60px;
      height:60px;
      border-radius:50%;
      background:var(--primary);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.5rem;
      color:#fff;
      font-weight:700;
      position:relative;
    }
    
    .metronome-beat.active {
      background:var(--success);
      animation: beatPulse 0.3s ease;
    }
    
    @keyframes beatPulse {
      0%, 100% { transform:scale(1); }
      50% { transform:scale(1.2); }
    }
    
    .tutorial-highlight {
      position:relative;
      z-index:10;
      box-shadow:0 0 0 4px var(--accent), 0 0 0 8px rgba(139, 92, 246, 0.3);
      border-radius:12px;
    }
    
    .sr-only {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
    
    .btn:focus-visible,
    .option-btn:focus-visible {
      outline:3px solid var(--accent);
      outline-offset:3px;
    }
    
    .achievement-popup {
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%, -50%) scale(0);
      background:var(--card);
      border-radius:20px;
      padding:2rem;
      box-shadow:0 20px 60px rgba(0,0,0,0.3);
      z-index:2000;
      text-align:center;
      animation: achievementPop 0.6s ease forwards;
    }
    
    @keyframes achievementPop {
      0% { transform:translate(-50%, -50%) scale(0) rotate(-180deg); opacity:0; }
      60% { transform:translate(-50%, -50%) scale(1.1) rotate(10deg); opacity:1; }
      100% { transform:translate(-50%, -50%) scale(1) rotate(0deg); opacity:1; }
    }
    
    .confetti {
      position:fixed;
      width:10px;
      height:10px;
      background:var(--accent);
      position:fixed;
      animation: confettiFall 3s ease-out forwards;
    }
    
    @keyframes confettiFall {
      to {
        transform:translateY(100vh) rotate(360deg);
        opacity:0;
      }
    }
    
    @media (max-width:640px) {
      .container { padding:0.75rem; }
      .card { padding:1rem 1.25rem; border-radius:12px; }
      h1 { font-size:1.5rem; }
      h2 { font-size:1.25rem; }
      .btn { padding:0.65rem 1rem; font-size:0.9rem; }
      .stat-value { font-size:2rem; }
    }
    
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.001ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.001ms !important;
      }
    }
  </style>
  <script>
    (function () {
      const KEY = 'vmq.theme';
      const saved = localStorage.getItem(KEY);
  
      // Screen reader status helper
      window.speakSR = (txt) => {
        const el = document.getElementById('sr');
        if (el) el.textContent = txt;
      };
  
      const prefers =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches;
  
      const dark = saved ? saved === 'dark' : prefers;
      document.documentElement.classList.toggle('dark', dark);
  
      window.__setTheme = (d) => {
        localStorage.setItem(KEY, d ? 'dark' : 'light');
        document.documentElement.classList.toggle('dark', d);
      };
    })();
  </script>
  <!--
    Load React and ReactDOM from a CDN. Using the `defer` attribute ensures that
    these external scripts do not block HTML parsing. The `crossorigin`
    attribute is added so that if subresource integrity attributes are added
    later, the requests will be CORS-enabled. Order is preserved: React
    must load before ReactDOM and Babel so that the Babel-compiled JSX can
    resolve React properly.
  -->
  <!-- React + ReactDOM + Babel (synchronous, in this order) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <!--
    The application is built entirely in React and requires JavaScript to function.
    If JavaScript is disabled in the user's browser, display a friendly message
    encouraging them to enable it. This content will only appear when scripts
    are blocked.
  -->
  <noscript>
    <p style="padding:1rem;color:#b91c1c;">This application requires JavaScript to run properly. Please enable JavaScript in your browser settings.</p>
  </noscript>
  <div id="sr" class="sr-only" aria-live="polite" aria-atomic="true"></div>
  <script
    type="text/babel"
    data-presets="react"
    data-plugins="transform-optional-chaining,transform-nullish-coalescing-operator">
    // ============================================================================
    // CONSTANTS & DATA STRUCTURES
    // ============================================================================
    
    const STRINGS = ['G','D','A','E'];
    const POSITIONS = [1,2,3,4,5,6,7,8,9,10];
    const FINGERS = [1,2,3,4];
    const VISUAL_STRING_ORDER = ['E', 'A', 'D', 'G']; // display order: what the player sees, top â†’ bottom
    const OPEN_PC = {G:7, D:2, A:9, E:4};
    const BASE_OFF = {1:2, 2:4, 3:5, 4:7};
    const POS_SHIFT = {1:0, 2:2, 3:3, 4:5, 5:7, 6:9, 7:10, 8:12, 9:14, 10:16};
    const NOTE_NAME = {0:'C',1:'Db',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};
    const NOTE_TO_PC = Object.fromEntries(Object.entries(NOTE_NAME).map(([k,v])=>[v,Number(k)]));
    const MIDI_BASE = {G:55, D:62, A:69, E:76};
    
    // Interval definitions with semitones
    const INTERVALS = {
      'Minor 2nd': 1,
      'Major 2nd': 2,
      'Minor 3rd': 3,
      'Major 3rd': 4,
      'Perfect 4th': 5,
      'Tritone': 6,
      'Perfect 5th': 7,
      'Minor 6th': 8,
      'Major 6th': 9,
      'Minor 7th': 10,
      'Major 7th': 11,
      'Octave': 12
    };
    
    // Rhythm patterns (in terms of beat subdivisions)
    const RHYTHM_PATTERNS = {
      'Quarter Notes': [1,1,1,1],
      'Eighth Notes': [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5],
      'Quarter-Eighth': [1,0.5,0.5,1,1],
      'Dotted Quarter-Eighth': [1.5,0.5,1,1],
      'Syncopation': [0.5,1,0.5,1,1],
      'Triplets': [0.66,0.66,0.66,1,1]
    };
    
    // Achievement definitions
    const ACHIEVEMENTS = [
      { id:'first_note', name:'First Steps', desc:'Play your first note', icon:'ðŸŽµ', xp:0 },
      { id:'speed_10', name:'Quick Learner', desc:'Answer 10 speed drill questions', icon:'âš¡', xp:10 },
      { id:'speed_50', name:'Speed Demon', desc:'Answer 50 speed drill questions', icon:'ðŸ”¥', xp:50 },
      { id:'perfect_5', name:'Perfectionist', desc:'Get 5 correct answers in a row', icon:'âœ¨', xp:15 },
      { id:'perfect_10', name:'Flawless', desc:'Get 10 correct answers in a row', icon:'ðŸ’Ž', xp:25 },
      { id:'streak_3', name:'Committed', desc:'Maintain a 3-day streak', icon:'ðŸ“…', xp:3 },
      { id:'streak_7', name:'Dedicated', desc:'Maintain a 7-day streak', icon:'ðŸŒŸ', xp:7 },
      { id:'streak_30', name:'Legend', desc:'Maintain a 30-day streak', icon:'ðŸ†', xp:30 },
      { id:'level_5', name:'Apprentice', desc:'Reach Level 5', icon:'ðŸŽ“', xp:5 },
      { id:'level_10', name:'Expert', desc:'Reach Level 10', icon:'ðŸŽ¯', xp:10 },
      { id:'interval_master', name:'Interval Master', desc:'Master all interval recognition', icon:'ðŸŽ¶', xp:20 },
      { id:'rhythm_master', name:'Rhythm Master', desc:'Master all rhythm patterns', icon:'ðŸ¥', xp:20 },
      { id:'all_positions', name:'Position Expert', desc:'Practice all 10 positions', icon:'ðŸŽ»', xp:15 },
      { id:'bieler_scholar', name:'Bieler Scholar', desc:'Complete Technique Lab', icon:'ðŸ“š', xp:25 },
      { id:'reflection_10', name:'Thoughtful Practitioner', desc:'Write 10 reflection entries', icon:'ðŸ“', xp:15 }
    ];
    
    // Encouraging messages
    const PRAISE_MESSAGES = [
      "Outstanding! ðŸŒŸ", "Perfect! âœ¨", "Excellent work! ðŸŽµ", "Brilliant! ðŸ’Ž",
      "You're on fire! ðŸ”¥", "Magnificent! ðŸŽ»", "Superb! â­", "Incredible! ðŸŽ¶",
      "Amazing job! ðŸ†", "You're a natural! ðŸŽ¯", "Flawless! ðŸ’«", "Phenomenal! ðŸŒˆ"
    ];
    
    const ENCOURAGEMENT_MESSAGES = [
      "Keep trying! ðŸ’ª", "Almost there! ðŸŽµ", "You're learning! ðŸ“š", "Good effort! â­",
      "Practice makes perfect! ðŸŽ»", "You'll get it! ðŸŒŸ", "Keep going! ðŸŽ¯", "Nice try! ðŸ’«"
    ];
    
    // ============================================================================
    // STORAGE KEYS
    // ============================================================================
    
    const XP_KEY = 'vmq.v6.xp';
    const STATS_KEY = 'vmq.v6.stats';
    const PREFS_KEY = 'vmq.v6.prefs';
    const FLASH_KEY = 'vmq.v6.flashcards';
    const FLASH_SIG_KEY = 'vmq.v6.flashcards.sig';
    const ACHIEVEMENTS_KEY = 'vmq.v6.achievements';
    const STREAK_KEY = 'vmq.v6.streak';
    const LAST_VISIT_KEY = 'vmq.v6.lastVisit';
    const TUTORIAL_KEY = 'vmq.v6.tutorialComplete';
    const REFLECTIONS_KEY = 'vmq.v6.reflections';

    const INTERVAL_STATS_KEY = 'vmq.v6.intervalStats';
    const RHYTHM_STATS_KEY = 'vmq.v6.rhythmStats';
    const BIELER_STATS_KEY = 'vmq.v6.bielerStats';  
    
    const BKT_KEY = 'vmq.v6.bkt';

    const BKT_DEFAULT_PARAMS = {
      pInit: 0.25,   // initial belief student knows a new cell
      pSlip: 0.10,   // chance of error despite knowing
      pGuess: 0.20,  // chance of correct despite not knowing
      pLearn: 0.08   // learning per exposure
    };
    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    
    const loadJSON = (k,fb) => {
      try {
        const v = JSON.parse(localStorage.getItem(k));
        return v ?? fb;
      } catch {
        return fb;
      }
    };
    
    const saveJSON = (k,v) => {
      try {
        localStorage.setItem(k, JSON.stringify(v));
      } catch {}
    };
    
    // ----- BKT core helpers -----

    // Key for any (string, position, finger) triple
    const cellKey = (s, p, f) => `${s}:${p}:${f}`;
    
    // Load full BKT map: { [key]: { pKnow, seen, last, params? } }
    const loadBKT = () => loadJSON(BKT_KEY, {});
    
    // Save BKT
    const saveBKT = (state) => saveJSON(BKT_KEY, state);
    
    // Get current BKT state for a cell, with sensible defaults
    const getBKTForCell = (bktState, s, p, f) => {
      const key = cellKey(s, p, f);
      const existing = bktState[key];
      if (existing) return existing;
      return {
        pKnow: BKT_DEFAULT_PARAMS.pInit,
        seen: 0,
        last: null
      };
    };
    
    // One BKT update step given previous P(K) and an observed correctness
    const updateBKTProbability = (pKnowPrev, correct, params = BKT_DEFAULT_PARAMS) => {
      const { pSlip, pGuess, pLearn } = params;
    
      // P(L_t | observation)
      let num, den, pGivenObs;
    
      if (correct) {
        num = pKnowPrev * (1 - pSlip);
        den = num + (1 - pKnowPrev) * pGuess;
      } else {
        num = pKnowPrev * pSlip;
        den = num + (1 - pKnowPrev) * (1 - pGuess);
      }
    
      // Guard against weird edge cases
      pGivenObs = den > 0 ? num / den : pKnowPrev;
    
      // Apply learning transition to get P(L_{t+1})
      const pNext = pGivenObs + (1 - pGivenObs) * pLearn;
    
      // Clamp to [0,1]
      return Math.min(0.999, Math.max(0.001, pNext));
    };
    
    // Update the BKT store for a single cell after a response
    const recordBKTObservation = (s, p, f, correct) => {
      const bkt = loadBKT();
      const key = cellKey(s, p, f);
      const prev = getBKTForCell(bkt, s, p, f);
    
      const pNext = updateBKTProbability(prev.pKnow, correct);
      bkt[key] = {
        ...prev,
        pKnow: pNext,
        seen: (prev.seen || 0) + 1,
        last: Date.now()
      };
    
      saveBKT(bkt);
      return bkt;
    };
    
    // Weight for item selection: low-mastery cells are picked more often
    const bktPracticeWeight = (bktState, s, p, f) => {
      const { pKnow, seen } = getBKTForCell(bktState, s, p, f);
    
      // Base weight: inverse of mastery
      let w = 1 - pKnow;
    
      // Light boost if the cell has never or rarely been seen
      if (!seen || seen < 3) {
        w += 0.25;
      }
    
      // Keep everything above a small floor to avoid "dead" items
      return Math.max(0.05, w);
    };
  
    const shuffle = a => {
      const arr = [...a];
      for(let i=arr.length-1; i>0; i--) {
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    };
    
    const getRandom = a => a[Math.floor(Math.random()*a.length)];
    
    // ---------------------------------------------------------------------------
    // Shared ordinal helpers (single source of truth)
    // ---------------------------------------------------------------------------
    
    const ordinal = n => {
      if (n == null) return '';
      const s = String(n);
      const last = s[s.length - 1];
      const last2 = s.length > 1 ? s.slice(-2) : s;
    
      if (last2 === '11' || last2 === '12' || last2 === '13') return `${s}th`;
      if (last === '1') return `${s}st`;
      if (last === '2') return `${s}nd`;
      if (last === '3') return `${s}rd`;
      return `${s}th`;
    };
    
    // Short variant â€“ currently identical, but easy to style differently later
    const ordinalShort = n => ordinal(n);
    
    // Position label â€“ kept separate for possible "half position" etc. later
    const positionLabelShort = n => ordinalShort(n);
    
    const canonicalBase = (s,p,f) => {
      const semi = OPEN_PC[s] + POS_SHIFT[p] + BASE_OFF[f];
      return NOTE_NAME[((semi%12)+12)%12];
    };
    
    const levelForXP = (xp) => Math.floor(Math.pow(xp/300, 0.75)) + 1;
    const nextLevelXP = (lvl) => Math.round(300 * Math.pow(lvl, 1.4));
    
    const addXP = (amt) => {
      const xp = loadJSON(XP_KEY, 0) + amt;
      saveJSON(XP_KEY, xp);
      return xp;
    };
    
    const updateStat = (key, ok) => {
      const stats = loadJSON(STATS_KEY, {});
      const st = stats[key] || {correct:0, total:0, lastPracticed: Date.now()};
      st.total += 1;
      if(ok) st.correct += 1;
      st.lastPracticed = Date.now();
      stats[key] = st;
      saveJSON(STATS_KEY, stats);
    };
    
    const checkAchievement = (achievementId) => {
      const unlocked = loadJSON(ACHIEVEMENTS_KEY, []);
      if(!unlocked.includes(achievementId)) {
        unlocked.push(achievementId);
        saveJSON(ACHIEVEMENTS_KEY, unlocked);
        return true;
      }
      return false;
    };
    
    const updateStreak = () => {
      const streak = loadJSON(STREAK_KEY, {current:0, longest:0, lastDate:null});
      const lastVisit = loadJSON(LAST_VISIT_KEY, null);
      const today = new Date().toDateString();
      
      if(lastVisit === today) {
        return streak;
      }
      
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = yesterday.toDateString();
      
      if(lastVisit === yesterdayStr) {
        streak.current += 1;
      } else if(lastVisit !== null) {
        streak.current = 1;
      } else {
        streak.current = 1;
      }
      
      streak.longest = Math.max(streak.longest, streak.current);
      streak.lastDate = today;
      
      saveJSON(STREAK_KEY, streak);
      saveJSON(LAST_VISIT_KEY, today);
      
      // Check streak achievements
      if(streak.current >= 3) checkAchievement('streak_3');
      if(streak.current >= 7) checkAchievement('streak_7');
      if(streak.current >= 30) checkAchievement('streak_30');
      
      return streak;
    };
    
    const CELLS = [];
    for(const s of STRINGS) {
      for(const p of POSITIONS) {
        for(const f of FINGERS) {
          CELLS.push({s, p, f, canon: canonicalBase(s,p,f)});
        }
      }
    }
    
    const defaultPrefs = {
      strings: Object.fromEntries(STRINGS.map(s=>[s,true])),
      positions: Object.fromEntries(POSITIONS.map(p=>[p,true])),
      flashLevel: 'Professional',
      difficulty: 'medium',
      soundEnabled: true,
      hapticEnabled: true,
      tutorialComplete: false
    };
    
    const filteredCells = prefs => CELLS.filter(c => prefs.strings[c.s] && prefs.positions[c.p]);
    
    // --------------------------------------------------------------------------
    // Mastery helpers for the current selection (based on BKT)
    // --------------------------------------------------------------------------
    
    // Average P(know) across all currently-enabled cells
    const avgMasteryForSelection = (prefs) => {
      const cells = filteredCells(prefs);
      if (!cells.length) return 0;
      const bkt = loadBKT();
      const total = cells.reduce((sum, c) =>
        sum + getBKTForCell(bkt, c.s, c.p, c.f).pKnow, 0);
      return total / cells.length;
    };
    
    // Convert an average mastery score into a human-friendly difficulty tier
    const difficultyTierFromMastery = (m) => {
      if (m < 0.5) return 'easy';     // student is still stabilizing basics
      if (m < 0.85) return 'medium';  // solid but still room to grow
      return 'hard';                  // ready for challenge / transfer tasks
    };
    
    // Build a per-position, per-string mastery grid (average P(know))
    // Used for heatmaps / progress visualizations.
    const buildPositionHeat = () => {
      const bkt = loadBKT();
      const result = {}; // { position: { string: {sum,count} } }
    
      for (const { s, p, f } of CELLS) {
        const state = getBKTForCell(bkt, s, p, f);
        if (!result[p]) result[p] = {};
        if (!result[p][s]) result[p][s] = { sum: 0, count: 0 };
        result[p][s].sum   += state.pKnow;
        result[p][s].count += 1;
      }
    
      const out = {};
      for (const p of POSITIONS) {
        out[p] = {};
        for (const s of STRINGS) {
          const cell = result[p]?.[s];
          out[p][s] = cell ? cell.sum / cell.count : 0;
        }
      }
      return out;
    };
    
    // ============================================================================
    // AUDIO ENGINE (Enhanced)
    // ============================================================================
    
    class AudioEngine {
      constructor() {
        this.ctx = null;
        this.mute = loadJSON('vmq.v6.mute', false);
      }
      
      ensure() {
        if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if(this.ctx.state === 'suspended') this.ctx.resume();
        return this.ctx;
      }
      
      playNote({midi, durationMs = 800, waveform = 'sine'}) {
        if(this.mute) return;
        const ctx = this.ensure();
        const now = ctx.currentTime;
        const freq = 440 * Math.pow(2, (midi-69)/12);
        
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.frequency.value = freq;
        osc.type = waveform;
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.8, now+0.01);
        gain.gain.exponentialRampToValueAtTime(0.1, now+durationMs/1000*0.8);
        gain.gain.linearRampToValueAtTime(0, now+durationMs/1000);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now+durationMs/1000);
        
        osc.onended = () => {
          try { osc.disconnect(); gain.disconnect(); } catch {}
        };
      }
      
      playInterval({rootMidi, semitones, gapMs = 150, durationMs = 600, simultaneous = false}) {
        if(this.mute) return;
        const ctx = this.ensure();
        const t0 = ctx.currentTime + 0.01;
        
        const note = (midi, t) => {
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = 440 * Math.pow(2, (midi-69)/12);
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(0.8, t+0.01);
          g.gain.exponentialRampToValueAtTime(0.1, t+durationMs/1000*0.8);
          g.gain.linearRampToValueAtTime(0, t+durationMs/1000);
          osc.connect(g);
          g.connect(ctx.destination);
          osc.start(t);
          osc.stop(t+durationMs/1000);
          osc.onended = () => { try { osc.disconnect(); g.disconnect(); } catch {} };
        };
        
        note(rootMidi, t0);
        note(rootMidi + semitones, simultaneous ? t0 : t0 + gapMs/1000);
      }
      
      playFeedback(ok) {
        if(this.mute) return;
        const ctx = this.ensure();
        const now = ctx.currentTime;
        const freq = ok ? 880 : 220;
        
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.frequency.value = freq;
        osc.type = 'square';
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.3, now+0.01);
        gain.gain.linearRampToValueAtTime(0, now+0.2);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now+0.2);
        
        osc.onended = () => {
          try { osc.disconnect(); gain.disconnect(); } catch {}
        };
      }
      
      playCelebration() {
        if(this.mute) return;
        const notes = [60, 64, 67, 72]; // C major chord + octave
        notes.forEach((midi, i) => {
          setTimeout(() => this.playNote({midi, durationMs:300}), i*100);
        });
      }
      
      setMute(m) {
        this.mute = m;
        saveJSON('vmq.v6.mute', m);
      }
    }
    
    const audioEngine = new AudioEngine();
    
    // Unlock audio on first interaction
    window.addEventListener('pointerdown', () => {
      try { audioEngine.ensure(); } catch {}
    }, { once: true });
    
    // ============================================================================
    // SPEECH SYNTHESIS (Enhanced)
    // ============================================================================
    
    function speak(text, { rate = 0.9, pitch = 1, lang, voiceName } = {}) {
      try {
        if (!text) return;
        const synth = window.speechSynthesis;
        const Utterance = window.SpeechSynthesisUtterance;
        if (!synth || !Utterance) return;
        
        let voices = [];
        try {
          voices = synth.getVoices?.() || [];
          if (typeof synth.onvoiceschanged === 'undefined') {
            void voices.length;
          }
        } catch {}
        
        const u = new Utterance(String(text));
        u.rate = rate;
        u.pitch = pitch;
        
        if (lang) u.lang = lang;
        if (voiceName && Array.isArray(voices)) {
          const v = voices.find(v => v.name === voiceName);
          if (v) u.voice = v;
        }
        
        try { synth.cancel(); } catch {}
        synth.speak(u);
      } catch {}
    }
    
    // ============================================================================
    // HAPTIC FEEDBACK
    // ============================================================================
    
    const vibrate = (pattern = [50]) => {
      try {
        if(navigator.vibrate && loadJSON(PREFS_KEY, defaultPrefs).hapticEnabled) {
          navigator.vibrate(pattern);
        }
      } catch {}
    };
    
    // ============================================================================
    // REACT HOOKS
    // ============================================================================
    
    function useAnswerHotkeys(enabled, onIndex, onBack, count = 4) {
      const cursorRef = React.useRef(-1);
      
      React.useEffect(() => {
        if (!enabled) return;
        const handler = (e) => {
          const t = e.target;
          const tag = (t && t.tagName || '').toLowerCase();
          if (tag === 'input' || tag === 'select' || tag === 'textarea' || (t && t.isContentEditable)) return;
          
          const k = e.key;
          const max = (count ?? 4) - 1;
          let handled = false;
          
          if (k >= '1' && k <= '9') {
            const idx = Number(k) - 1;
            if (idx <= max) {
              cursorRef.current = idx;
              onIndex(idx);
              handled = true;
            }
          } else if (k === 'Enter') {
            cursorRef.current = 0;
            onIndex(0);
            handled = true;
          } else if (k === 'Escape') {
            onBack();
            handled = true;
          } else if (k === 'ArrowRight' || k === 'ArrowDown') {
            const next = Math.min((cursorRef.current < 0 ? 0 : cursorRef.current) + 1, max);
            cursorRef.current = next;
            onIndex(next);
            handled = true;
          } else if (k === 'ArrowLeft' || k === 'ArrowUp') {
            const prev = Math.max((cursorRef.current < 0 ? 0 : cursorRef.current) - 1, 0);
            cursorRef.current = prev;
            onIndex(prev);
            handled = true;
          }
          
          if (handled) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
        window.addEventListener('keydown', handler);
        return () => window.removeEventListener('keydown', handler);
      }, [enabled, onIndex, onBack, count]);
      
      React.useEffect(() => {
        cursorRef.current = -1;
      }, [enabled, count]);
    }
    
    // ============================================================================
    // REUSABLE COMPONENTS
    // ============================================================================
    
    function OptionButton({
      label,
      selected,
      onClick,
      shortcut,
      disabled,
      correct,
      incorrect,
      ...rest    // âœ… rest props
    }) {
      const bg = correct
        ? 'var(--success)'
        : incorrect
        ? 'var(--danger)'
        : selected
        ? 'var(--primary-dark)'
        : 'var(--primary)';
    
      const className = `option-btn ${correct ? 'correct' : ''} ${incorrect ? 'incorrect' : ''}`;
    
      return (
        <button
          type="button"
          className={className}
          role="button"
          aria-keyshortcuts={shortcut ?? ''}
          style={{ background: bg }}
          onClick={onClick}
          disabled={disabled}
          {...rest}   // âœ… spread the rest props
        >
          {label}
          {correct && ' âœ“'}
          {incorrect && ' âœ•'}
          {shortcut && <span className="sr-only"> (Shortcut {shortcut})</span>}
        </button>
      );
    }
    
    function ProgressBar({ current, max, label }) {
      const percent = Math.min(100, Math.max(0, (current / max) * 100));
      return (
        <div style={{margin:'1rem 0'}}>
          {label && <div style={{marginBottom:'0.5rem',fontSize:'0.9rem',color:'var(--ink-light)'}}>{label}</div>}
          <div className="progress-bar">
            <div className="progress-fill" style={{width:`${percent}%`}} />
          </div>
          <div style={{marginTop:'0.25rem',fontSize:'0.85rem',color:'var(--ink-light)',textAlign:'right'}}>
            {current} / {max}
          </div>
        </div>
      );
    }
    
    function AchievementPopup({ achievement, onClose }) {
      React.useEffect(() => {
        audioEngine.playCelebration();
        vibrate([50, 100, 50]);
        speak(`Achievement unlocked: ${achievement.name}`);
        
        // Create confetti
        for(let i=0; i<30; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.background = ['var(--success)','var(--primary)','var(--accent)','var(--warning)'][Math.floor(Math.random()*4)];
            confetti.style.animationDelay = Math.random() * 0.5 + 's';
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 3000);
          }, i*50);
        }
        
        const timer = setTimeout(onClose, 4000);
        return () => clearTimeout(timer);
      }, [achievement, onClose]);
      
      return (
        <div className="achievement-popup">
          <div style={{fontSize:'4rem',marginBottom:'0.5rem'}}>{achievement.icon}</div>
          <h2 style={{marginBottom:'0.5rem'}}>Achievement Unlocked!</h2>
          <h3 style={{color:'var(--accent)',marginBottom:'0.5rem'}}>{achievement.name}</h3>
          <p style={{color:'var(--ink-light)',marginBottom:'0.5rem'}}>{achievement.desc}</p>
          <div className="badge badge-large">+{achievement.xp} XP</div>
        </div>
      );
    }
    
    function Toast({ message, type = 'success', onClose }) {
      React.useEffect(() => {
        const timer = setTimeout(onClose, 3000);
        return () => clearTimeout(timer);
      }, [onClose]);
      
      const className = `toast toast-${type}`;
      
      return (
        <div className={className}>
          <strong>{message}</strong>
        </div>
      );
    }
    
    // ============================================================================
    // BIELER METHOD CONTENT (Enhanced)
    // ============================================================================
    
    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1stâ€“2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shiftingâ€”moving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibratoâ€”finger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'DeÌtacheÌ', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'ColleÌ', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'MarteleÌ', def:'Accented, stopped strokeâ€”bite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance pointâ€”vertical energy, horizontal timing.' },
      { term:'SautilleÌ', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term: 'Nature', def: "Use body's natural alignmentsâ€”economy, ease, resonance." },
      { term:'Nurture', def:'Stepwise trainingâ€”patterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];
    
    const BIELER_CONCEPT_QA = [
      { q:'Why does "hand frame" matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautilleÌ?', a:'Spiccato is placed/rebounded; sautilleÌ is natural spring at faster tempi.', wrong:['Spiccato is legato','SautilleÌ is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];
    
    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy marteleÌ at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist colleÌ','Firm staccato','Always play sul ponticello'] },
    ];
    
    // ============================================================================
    // VISUAL FINGERBOARD (Enhanced)
    // ============================================================================
    
    function VisualFingerboard({
      highlight = [],
      onSelect,
      disabled,
      showNotes = false
    }) {
      // Map highlight array to quick lookup
      const hiMap = {};
      for (const h of highlight) {
        hiMap[`${h.s}:${h.p}:${h.f}`] = h.kind || 'correct';
      }
    
      const width = 760;
      const height = 220;
      const leftMargin = 60;
      const rightMargin = 24;
      const topMargin = 40;
      const bottomMargin = 32;
    
      const boardWidth = width - leftMargin - rightMargin;
      const boardHeight = height - topMargin - bottomMargin;
    
      const visualStrings = VISUAL_STRING_ORDER; // E, A, D, G (what we draw)
      const posCount = POSITIONS.length;
      const stringCount = visualStrings.length;
    
      const colWidth = boardWidth / posCount;
      const rowHeight = boardHeight / stringCount;
    
      const stringColors = {
        G: '#b45309', // warm brown / rust
        D: '#16a34a', // green
        A: '#ea580c', // orange
        E: '#2563eb'  // blue
      };
    
      const vibrateSafe = (pattern) => {
        try {
          if (window.navigator && window.navigator.vibrate) {
            window.navigator.vibrate(pattern);
          }
        } catch {}
      };
    
      const act = (cell) => {
        if (!disabled && onSelect) {
          onSelect(cell);
          vibrateSafe([30]);
        }
      };
    
      return (
        <svg
          viewBox={`0 0 ${width} ${height}`}
          width="100%"
          height="auto"
          role="grid"
          aria-label="Interactive violin fingerboard"
          aria-rowcount={stringCount}
          aria-colcount={posCount * FINGERS.length}
        >
          <defs>
            {/* Ebony-style gradient for the main board */}
            <linearGradient id="fingerboardEbony" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stopColor="#1f2430" />
              <stop offset="100%" stopColor="#05070b" />
            </linearGradient>
    
            {/* Soft highlight for correct notes */}
            <linearGradient id="fingerboardHighlight" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stopColor="#fbbf24" stopOpacity="0.95" />
              <stop offset="100%" stopColor="#f97316" stopOpacity="0.95" />
            </linearGradient>
    
            {/* Optional cross-hatch for distractors / alternates */}
            <pattern
              id="fingerboardAltPattern"
              patternUnits="userSpaceOnUse"
              width="8"
              height="8"
            >
              <rect width="8" height="8" fill="#facc15" />
              <path
                d="M0 0 L8 8 M8 0 L0 8"
                stroke="#fefce8"
                strokeWidth="1"
              />
            </pattern>
          </defs>
    
          {/* Nut / scroll side */}
          <text
            x={leftMargin}
            y={18}
            fontSize="10"
            fill="rgba(148, 163, 184, 0.9)"
            textAnchor="start"
          >
            Nut
          </text>
    
          {/* Bridge side */}
          <text
            x={leftMargin + boardWidth}
            y={18}
            fontSize="10"
            fill="rgba(148, 163, 184, 0.9)"
            textAnchor="end"
          >
            Toward bridge
          </text>
    
          {/* Position labels above the board (1stâ€“7th) */}
          {POSITIONS.map((p, idx) => {
            const xCenter = leftMargin + colWidth * (idx + 0.5);
            return (
              <text
                key={`pos-label-${p}`}
                x={xCenter}
                y={topMargin - 10}
                fontSize="12"
                fontWeight="600"
                fill="rgba(148, 163, 184, 0.95)"
                textAnchor="middle"
              >
                {ordinal(p)}   {/* e.g. 1st, 2nd, 3rd, ... */}
              </text>
            );
          })}
    
          {/* Main ebony fingerboard */}
          <rect
            x={leftMargin}
            y={topMargin}
            width={boardWidth}
            height={boardHeight}
            rx={10}
            fill="url(#fingerboardEbony)"
            stroke="rgba(15, 23, 42, 0.9)"
            strokeWidth="2"
          />
    
          {/* Vertical position bands */}
          {POSITIONS.map((p, idx) => {
            const x = leftMargin + colWidth * idx;
            return (
              <line
                key={`pos-line-${p}`}
                x1={x}
                x2={x}
                y1={topMargin}
                y2={topMargin + boardHeight}
                stroke="rgba(148, 163, 184, 0.28)"
                strokeWidth={idx === 0 ? 1.5 : 1}
              />
            );
          })}
    
          {/* String lanes in visual order: E (top) â†’ G (bottom) */}
          {visualStrings.map((s, rowIndex) => {
            const yMid = topMargin + rowHeight * (rowIndex + 0.5);
            const color = stringColors[s] || 'rgba(148, 163, 184, 0.85)';
    
            return (
              <g key={`string-${s}`}>
                {/* tinted lane */}
                <rect
                  x={leftMargin}
                  y={yMid - rowHeight * 0.45}
                  width={boardWidth}
                  height={rowHeight * 0.9}
                  fill="rgba(15, 23, 42, 0.45)"
                />
                {/* actual string line */}
                <line
                  x1={leftMargin + 4}
                  x2={leftMargin + boardWidth - 4}
                  y1={yMid}
                  y2={yMid}
                  stroke={color}
                  strokeWidth="2.2"
                  strokeLinecap="round"
                  strokeOpacity="0.85"
                />
                {/* string label on the left */}
                <text
                  x={leftMargin - 16}
                  y={yMid + 4}
                  fontSize="12"
                  fontWeight="600"
                  fill={color}
                  textAnchor="end"
                >
                  {s}
                </text>
              </g>
            );
          })}
    
          {/* Clickable pads: one per (string, position, finger), aligned with visual rows */}
          {visualStrings.map((s, rowIndex) =>
            POSITIONS.map((p, pIdx) =>
              FINGERS.map((f) => {
                const yMid = topMargin + rowHeight * (rowIndex + 0.5);
                const bandX = leftMargin + colWidth * pIdx;
    
                // Slight â€œtoward bridgeâ€ compression in higher positions
                const innerWidth = colWidth * (0.82 - pIdx * 0.03); // stays > 0
                const fingerGap = innerWidth / (FINGERS.length + 1);
    
                const padWidth = Math.min(fingerGap * 0.9, 30);
                const padHeight = rowHeight * 0.46;
    
                const x = bandX + fingerGap * f - padWidth / 2;
                const y = yMid - padHeight / 2;
    
                const key = `${s}:${p}:${f}`;
                const kind = hiMap[key];
                const note = canonicalBase(s, p, f);
    
                const isCorrect = kind === 'correct';
                const isChosen = kind === 'chosen';
                const isDistractor = kind === 'distractor';
    
                let fill = 'rgba(248, 250, 252, 0.05)';
                let stroke = 'rgba(148, 163, 184, 0.4)';
                let strokeWidth = 1;
    
                if (isCorrect) {
                  fill = 'url(#fingerboardHighlight)';
                  stroke = '#92400e';
                  strokeWidth = 1.6;
                } else if (isChosen && !isCorrect) {
                  fill = 'rgba(37, 99, 235, 0.12)';
                  stroke = '#2563eb';
                  strokeWidth = 1.6;
                } else if (isDistractor) {
                  fill = 'url(#fingerboardAltPattern)';
                  stroke = 'rgba(202, 138, 4, 0.9)';
                  strokeWidth = 1.2;
                }
    
                return (
                  <g key={key}>
                    <rect
                      x={x}
                      y={y}
                      width={padWidth}
                      height={padHeight}
                      rx={6}
                      ry={6}
                      fill={fill}
                      stroke={stroke}
                      strokeWidth={strokeWidth}
                      role="gridcell"
                      aria-selected={isCorrect || isChosen}
                      aria-label={`${s} string, ${ordinal(p)} position, finger ${f}, note ${note}`}
                      tabIndex={disabled ? -1 : 0}
                      style={{ cursor: disabled ? 'default' : 'pointer' }}
                      onClick={() => act({ s, p, f })}
                      onKeyDown={(e) => {
                        if (!disabled && (e.key === 'Enter' || e.key === ' ')) {
                          e.preventDefault();
                          e.stopPropagation();
                          act({ s, p, f });
                        }
                      }}
                    />
                    {/* Optional note-name overlay for study mode */}
                    {showNotes && (
                      <text
                        x={x + padWidth / 2}
                        y={y + padHeight / 2 + 4}
                        textAnchor="middle"
                        fontSize="10"
                        fontWeight="600"
                        fill="#e5e7eb"
                        pointerEvents="none"
                      >
                        {note}
                      </text>
                    )}
                    {/* Check / X icons, smaller and centered */}
                    {isCorrect && (
                      <text
                        x={x + padWidth / 2}
                        y={y + padHeight / 2 + 4}
                        textAnchor="middle"
                        fontSize="12"
                        fill="#111827"
                        pointerEvents="none"
                      >
                        âœ“
                      </text>
                    )}
                    {isChosen && !isCorrect && (
                      <text
                        x={x + padWidth / 2}
                        y={y + padHeight / 2 + 4}
                        textAnchor="middle"
                        fontSize="12"
                        fill="#eff6ff"
                        pointerEvents="none"
                      >
                        âœ•
                      </text>
                    )}
                  </g>
                );
              })
            )
          )}
        </svg>
      );
    }
    
    // ============================================================================
    // SPEED DRILL (Enhanced with Adaptive Difficulty)
    // ============================================================================
    
    function SpeedDrill({ prefs, onBack }) {
      const [stats, setStats] = React.useState(() => loadJSON(STATS_KEY, {}));
      const cells = React.useMemo(() => filteredCells(prefs), [prefs]);
      const [time, setTime] = React.useState(90);
      const [paused, setPaused] = React.useState(false);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      const [streak, setStreak] = React.useState(0);
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [feedback, setFeedback] = React.useState(null);
      const [showCelebration, setShowCelebration] = React.useState(false);
      
      // Mastery + recommended difficulty for the cells currently in play
      const avgMastery = React.useMemo(
        () => avgMasteryForSelection(prefs),
        [prefs]
      );
      const difficultyTier = React.useMemo(
        () => difficultyTierFromMastery(avgMastery),
        [avgMastery]
      );
      
      const pick = React.useCallback(() => {
        if (!cells.length) {
          setQ(null);
          return;
        }
      
        const bkt = loadBKT();
      
        // Weighted random draw over filtered cells using BKT weights
        const weights = cells.map(c => bktPracticeWeight(bkt, c.s, c.p, c.f));
        const total = weights.reduce((sum, w) => sum + w, 0) || 1;
      
        let r = Math.random() * total;
        let chosen = cells[cells.length - 1];
      
        for (let i = 0; i < cells.length; i++) {
          r -= weights[i];
          if (r <= 0) {
            chosen = cells[i];
            break;
          }
        }
      
        const correct = chosen.canon;
        const pool = [...new Set(cells.map(c => c.canon))].filter(n => n !== correct);
        const opts = shuffle([correct, ...shuffle(pool).slice(0, 3)]);
      
        setQ({ cell: chosen, options: opts });
        setSelected(null);
        setFeedback(null);
      
        try {
          const midi = MIDI_BASE[chosen.s] + POS_SHIFT[chosen.p] + BASE_OFF[chosen.f];
          audioEngine.playNote({ midi });
        } catch {}
      }, [cells]);
      
      React.useEffect(() => {
        pick();
      }, [cells]);
      
      React.useEffect(() => {
        if (paused) return;
        const id = setInterval(() => setTime(t => t <= 1 ? 0 : t - 1), 1000);
        return () => clearInterval(id);
      }, [paused]);
      
      const answer = (opt, idx) => {
        if (selected !== null) return;
        setSelected(idx);
        
        setTimeout(() => {
          const ok = opt === q.cell.canon;
          
          // Update mastery model for this note-frame
          recordBKTObservation(q.cell.s, q.cell.p, q.cell.f, ok);
          
          if (ok) {
            setScore(s => s + 1);
            setStreak(s => {
              const newStreak = s + 1;
              if (newStreak === 5) {
                checkAchievement('perfect_5');
                setShowCelebration(true);
                setTimeout(() => setShowCelebration(false), 2000);
              }
              if (newStreak === 10) {
                checkAchievement('perfect_10');
                setShowCelebration(true);
                setTimeout(() => setShowCelebration(false), 2000);
              }
              return newStreak;
            });
            setFeedback({ type: 'success', message: getRandom(PRAISE_MESSAGES) });
          } else {
            setStreak(0);
            setFeedback({ type: 'error', message: `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct answer: ${q.cell.canon}` });
          }
          
          setAnswered(a => {
            const newAnswered = a + 1;
            if (newAnswered === 10) checkAchievement('speed_10');
            if (newAnswered === 50) checkAchievement('speed_50');
            return newAnswered;
          });
          
          speakSR(ok ? getRandom(PRAISE_MESSAGES) : `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct answer was ${q.cell.canon}`);
          audioEngine.playFeedback(ok);
          vibrate(ok ? [50] : [50, 100, 50]);
          
          setStats(prev => {
            const k = `${q.cell.s}:${q.cell.p}:${q.cell.f}`;
            const st = prev[k] || { correct: 0, total: 0 };
            const next = {
              ...prev,
              [k]: {
                correct: st.correct + (ok ? 1 : 0),
                total: st.total + 1,
                lastPracticed: Date.now()
              }
            };
            saveJSON(STATS_KEY, next);
            setTimeout(() => pick(), ok ? 500 : 1500);
            return next;
          });
          
          addXP(ok ? 8 : 2);
          
          setTimeout(() => setFeedback(null), ok ? 500 : 1500);
        }, 200);
      };
      
      useAnswerHotkeys(
        !!q && !paused,
        (i) => {
          if (q && q.options[i]) answer(q.options[i], i);
        },
        onBack,
        q?.options?.length ?? 4
      );
      
      if (time === 0) {
        return (
          <div>
            <div className="card">
              <h2>ðŸŽ¯ Speed Drill Complete!</h2>
              <div className="stat-card" style={{margin:'1.5rem 0'}}>
                <div className="stat-label">Final Score</div>
                <div className="stat-value">{score} / {answered}</div>
                <div className="stat-label">
                  {answered > 0 ? `${Math.round((score/answered)*100)}% Accuracy` : ''}
                </div>
              </div>
              {streak > 0 && (
                <div style={{textAlign:'center',margin:'1rem 0'}}>
                  <div className="badge badge-large">
                    ðŸ”¥ Best Streak: {streak}
                  </div>
                </div>
              )}
              <p style={{textAlign:'center',color:'var(--ink-light)'}}>
                {score === answered ? 'Perfect score! You\'re amazing! ðŸŒŸ' :
                 score > answered * 0.8 ? 'Excellent work! Keep practicing! ðŸŽµ' :
                 score > answered * 0.6 ? 'Good job! You\'re improving! ðŸ’ª' :
                 'Keep practicing! You\'ll get better! ðŸŽ»'}
              </p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }
      
      if (!cells.length) {
        return (
          <div>
            <div className="card">
              <h2>âš ï¸ No Practice Items</h2>
              <p>Please enable at least one string and position in Settings.</p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }
      
      return (
        <div>
          <div className="card">
            <div
              style={{
                display:'flex',
                justifyContent:'space-between',
                alignItems:'center',
                marginBottom:'1rem'
              }}
            >
              <div>
                <h2 style={{margin:0}}>âš¡ Speed Drill</h2>
                <p
                  style={{
                    margin:0,
                    marginTop:'0.25rem',
                    fontSize:'0.8rem',
                    color:'var(--ink-light)'
                  }}
                >
                  Recommended difficulty:{' '}
                  <strong>{difficultyTier}</strong>
                  {' Â· '}Avg mastery in this range:{' '}
                  {Math.round(avgMastery * 100)}%
                </p>
              </div>
              <button
                className="btn btn-secondary"
                onClick={() => setPaused(p => !p)}
              >
                {paused ? 'â–¶ï¸ Resume' : 'â¸ï¸ Pause'}
              </button>
            </div>
            
            <div className="grid grid-cols-3" style={{marginBottom:'1.5rem'}}>
              <div className="stat-card card-compact">
                <div className="stat-label">Time</div>
                <div className="stat-value" style={{fontSize:'1.8rem'}}>{time}s</div>
              </div>
              <div className="stat-card card-compact">
                <div className="stat-label">Score</div>
                <div className="stat-value" style={{fontSize:'1.8rem'}}>{score}/{answered}</div>
              </div>
              <div className="stat-card card-compact">
                <div className="stat-label">Streak</div>
                <div className="stat-value" style={{fontSize:'1.8rem'}}>
                  {streak > 0 ? `ðŸ”¥ ${streak}` : '-'}
                </div>
              </div>
            </div>
            
            {showCelebration && (
              <div style={{
                textAlign:'center',
                padding:'1rem',
                background:'linear-gradient(135deg, var(--gradient-1), var(--gradient-2))',
                color:'#fff',
                borderRadius:'12px',
                marginBottom:'1rem',
                animation:'celebrate 1s ease'
              }}>
                <h3 style={{margin:0,color:'#fff'}}>ðŸŒŸ Amazing Streak! ðŸŒŸ</h3>
              </div>
            )}
            
            {q && !paused && (
              <div>
                <p style={{fontSize:'1.1rem',fontWeight:600,marginBottom:'1rem'}}>
                  What is the base note at <strong style={{color:'var(--primary)'}}>{ordinal(q.cell.p)} position, {ordinal(q.cell.f)} finger on {q.cell.s}</strong> string?
                </p>
                
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selected === i}
                      correct={selected === i && opt === q.cell.canon}
                      incorrect={selected === i && opt !== q.cell.canon}
                      onClick={() => answer(opt, i)}
                      disabled={selected !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
                
                {feedback && (
                  <div style={{
                    marginTop:'1rem',
                    padding:'0.75rem',
                    borderRadius:'8px',
                    background: feedback.type === 'success' ? 'var(--success)' : 'var(--warning)',
                    color:'#fff',
                    fontWeight:600,
                    textAlign:'center'
                  }}>
                    {feedback.message}
                  </div>
                )}
              </div>
            )}
            
            {paused && (
              <div style={{textAlign:'center',padding:'2rem',color:'var(--ink-light)'}}>
                <h3>â¸ï¸ Paused</h3>
                <p>Press Resume when you're ready to continue!</p>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // INTERVAL TRAINING (NEW)
    // ============================================================================
    
    function IntervalTraining({ onBack }) {
      const [mode, setMode] = React.useState('listen'); // 'listen' or 'identify'
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      const [feedback, setFeedback] = React.useState(null);
      
      const generateQuestion = React.useCallback(() => {
        const intervalNames = Object.keys(INTERVALS);
        const correctInterval = getRandom(intervalNames);
        const rootMidi = 60 + Math.floor(Math.random() * 12);
        const semitones = INTERVALS[correctInterval];
        
        const wrongIntervals = shuffle(
          intervalNames.filter(i => i !== correctInterval)
        ).slice(0, 3);
        
        const options = shuffle([correctInterval, ...wrongIntervals]);
        
        setQ({ rootMidi, correct: correctInterval, semitones, options });
        setSelected(null);
        setFeedback(null);
      }, []);
      
      React.useEffect(() => {
        generateQuestion();
      }, []);
      
      const playInterval = () => {
        if (q) {
          audioEngine.playInterval({
            rootMidi: q.rootMidi,
            semitones: q.semitones,
            simultaneous: mode === 'listen'
          });
        }
      };
      
      const answer = (opt, idx) => {
        if (selected !== null) return;
        setSelected(idx);
        
        setTimeout(() => {
          const ok = opt === q.correct;
          
          if (ok) {
            setScore(s => s + 1);
            setFeedback({ type: 'success', message: getRandom(PRAISE_MESSAGES) });
          } else {
            setFeedback({ type: 'error', message: `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct: ${q.correct}` });
          }
          
          setAnswered(a => a + 1);
          
          speakSR(ok ? getRandom(PRAISE_MESSAGES) : `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct answer was ${q.correct}`);
          audioEngine.playFeedback(ok);
          vibrate(ok ? [50] : [50, 100, 50]);
          addXP(ok ? 10 : 3);

        // Track interval mastery
        if (ok) {
          const intervalStats = loadJSON(INTERVAL_STATS_KEY, {});
          const key = q.correct;
          const st = intervalStats[key] || { correct: 0, total: 0 };
          st.correct += 1;
          st.total += 1;
          intervalStats[key] = st;
          saveJSON(INTERVAL_STATS_KEY, intervalStats);

          // Check for interval_master achievement
          const allIntervals = Object.keys(INTERVALS);
          const masteredCount = allIntervals.filter(int => {
            const stat = intervalStats[int];
            return stat && stat.total >= 10 && (stat.correct / stat.total) >= 0.8;
          }).length;

          if (masteredCount === allIntervals.length) {
            checkAchievement('interval_master');
          }
        } else {
          // Track failed attempts
          const intervalStats = loadJSON(INTERVAL_STATS_KEY, {});
          const key = q.correct;
          const st = intervalStats[key] || { correct: 0, total: 0 };
          st.total += 1;
          intervalStats[key] = st;
          saveJSON(INTERVAL_STATS_KEY, intervalStats);
        }
          
          setTimeout(() => {
            generateQuestion();
            setFeedback(null);
          }, ok ? 800 : 2000);
        }, 200);
      };
      
      useAnswerHotkeys(
        !!q,
        (i) => {
          if (q && q.options[i]) answer(q.options[i], i);
        },
        onBack,
        q?.options?.length ?? 4
      );
      
      return (
        <div>
          <div className="card">
            <h2>ðŸŽ¶ Interval Training</h2>
            
            <div style={{display:'flex',gap:'0.5rem',margin:'1rem 0'}}>
              <button
                className={`btn ${mode === 'listen' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('listen')}
              >
                Harmonic (Together)
              </button>
              <button
                className={`btn ${mode === 'identify' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('identify')}
              >
                Melodic (Sequential)
              </button>
            </div>
            
            <div className="stat-card" style={{margin:'1rem 0'}}>
              <div className="stat-label">Score</div>
              <div className="stat-value" style={{fontSize:'1.5rem'}}>
                {score} / {answered}
                {answered > 0 && ` (${Math.round((score/answered)*100)}%)`}
              </div>
            </div>
            
            {q && (
              <div>
                <div style={{textAlign:'center',margin:'1.5rem 0'}}>
                  <button
                    className="btn btn-accent btn-large"
                    onClick={playInterval}
                  >
                    ðŸ”Š Play Interval
                  </button>
                </div>
                
                <p style={{fontWeight:600,textAlign:'center',marginBottom:'1rem'}}>
                  What interval do you hear?
                </p>
                
                <div role="radiogroup" aria-label="Interval choices">
                  {q.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selected === i}
                      correct={selected === i && opt === q.correct}
                      incorrect={selected === i && opt !== q.correct}
                      onClick={() => answer(opt, i)}
                      disabled={selected !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
                
                {feedback && (
                  <div style={{
                    marginTop:'1rem',
                    padding:'0.75rem',
                    borderRadius:'8px',
                    background: feedback.type === 'success' ? 'var(--success)' : 'var(--warning)',
                    color:'#fff',
                    fontWeight:600,
                    textAlign:'center'
                  }}>
                    {feedback.message}
                  </div>
                )}
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // RHYTHM TRAINER (NEW)
    // ============================================================================
    
    function RhythmTrainer({ onBack }) {
      const [bpm, setBpm] = React.useState(80);
      const [playing, setPlaying] = React.useState(false);
      const [currentBeat, setCurrentBeat] = React.useState(0);
      const [pattern, setPattern] = React.useState('Quarter Notes');
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      
      const patterns = Object.keys(RHYTHM_PATTERNS);
      
      const generateQuestion = React.useCallback(() => {
        const correctPattern = getRandom(patterns);
        const wrongPatterns = shuffle(
          patterns.filter(p => p !== correctPattern)
        ).slice(0, 3);
        const options = shuffle([correctPattern, ...wrongPatterns]);
        
        setQ({ correct: correctPattern, options });
        setSelected(null);
      }, []);
      
      React.useEffect(() => {
        generateQuestion();
      }, []);
      
      const playPattern = (patternName) => {
        const beats = RHYTHM_PATTERNS[patternName];
        const beatInterval = (60 / bpm) * 1000;
        
        setPlaying(true);
        setCurrentBeat(0);
        
        let currentTime = 0;
        beats.forEach((duration, i) => {
          setTimeout(() => {
            audioEngine.playNote({ midi: 69, durationMs: duration * beatInterval * 0.8 });
            setCurrentBeat(i);
            if (i === beats.length - 1) {
              setTimeout(() => {
                setPlaying(false);
                setCurrentBeat(0);
              }, duration * beatInterval);
            }
          }, currentTime);
          currentTime += duration * beatInterval;
        });
      };
      
      const answer = (opt, idx) => {
        if (selected !== null) return;
        setSelected(idx);
        
        setTimeout(() => {
          const ok = opt === q.correct;
          
          if (ok) {
            setScore(s => s + 1);
          }
          setAnswered(a => a + 1);
          
          speakSR(ok ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
          audioEngine.playFeedback(ok);
          vibrate(ok ? [50] : [50, 100, 50]);
          addXP(ok ? 10 : 3);

        // Track rhythm mastery
        if (ok) {
          const rhythmStats = loadJSON(RHYTHM_STATS_KEY, {});
          const key = q.correct;
          const st = rhythmStats[key] || { correct: 0, total: 0 };
          st.correct += 1;
          st.total += 1;
          rhythmStats[key] = st;
          saveJSON(RHYTHM_STATS_KEY, rhythmStats);

          // Check for rhythm_master achievement
          const allPatterns = Object.keys(RHYTHM_PATTERNS);
          const masteredCount = allPatterns.filter(pattern => {
            const stat = rhythmStats[pattern];
            return stat && stat.total >= 10 && (stat.correct / stat.total) >= 0.8;
          }).length;

          if (masteredCount === allPatterns.length) {
            checkAchievement('rhythm_master');
          }
        } else {
          const rhythmStats = loadJSON(RHYTHM_STATS_KEY, {});
          const key = q.correct;
          const st = rhythmStats[key] || { correct: 0, total: 0 };
          st.total += 1;
          rhythmStats[key] = st;
          saveJSON(RHYTHM_STATS_KEY, rhythmStats);
        }
          
          setTimeout(() => {
            generateQuestion();
          }, ok ? 800 : 2000);
        }, 200);
      };
      
      useAnswerHotkeys(
        !!q && !playing,
        (i) => {
          if (q && q.options[i]) answer(q.options[i], i);
        },
        onBack,
        q?.options?.length ?? 4
      );
      
      return (
        <div>
          <div className="card">
            <h2>ðŸ¥ Rhythm Trainer</h2>
            
            <div style={{margin:'1.5rem 0'}}>
              <label style={{display:'block',marginBottom:'0.5rem',fontWeight:600}}>
                Tempo: {bpm} BPM
              </label>
              <input
                type="range"
                min="40"
                max="200"
                value={bpm}
                onChange={(e) => setBpm(Number(e.target.value))}
                style={{width:'100%'}}
              />
            </div>
            
            <div className="stat-card" style={{margin:'1rem 0'}}>
              <div className="stat-label">Score</div>
              <div className="stat-value" style={{fontSize:'1.5rem'}}>
                {score} / {answered}
                {answered > 0 && ` (${Math.round((score/answered)*100)}%)`}
              </div>
            </div>
            
            {q && (
              <div>
                <div style={{textAlign:'center',margin:'1.5rem 0'}}>
                  <button
                    className="btn btn-accent btn-large"
                    onClick={() => playPattern(q.correct)}
                    disabled={playing}
                  >
                    {playing ? 'â¸ï¸ Playing...' : 'ðŸ”Š Play Rhythm'}
                  </button>
                </div>
                
                {playing && (
                  <div style={{display:'flex',justifyContent:'center',gap:'0.5rem',margin:'1rem 0'}}>
                    {RHYTHM_PATTERNS[q.correct].map((_, i) => (
                      <div
                        key={i}
                        className={`metronome-beat ${i === currentBeat ? 'active' : ''}`}
                        style={{
                          width:'40px',
                          height:'40px',
                          fontSize:'0.8rem'
                        }}
                      >
                        {i + 1}
                      </div>
                    ))}
                  </div>
                )}
                
                <p style={{fontWeight:600,textAlign:'center',marginBottom:'1rem'}}>
                  What rhythm pattern did you hear?
                </p>
                
                <div role="radiogroup" aria-label="Rhythm pattern choices">
                  {q.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selected === i}
                      correct={selected === i && opt === q.correct}
                      incorrect={selected === i && opt !== q.correct}
                      onClick={() => answer(opt, i)}
                      disabled={selected !== null || playing}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // BIELER TECHNIQUE LAB (Enhanced)
    // ============================================================================
    
    function BielerLab({ onBack }) {
      const [mode, setMode] = React.useState('vocab');
      const [vi, setVi] = React.useState(0);
      const [reveal, setReveal] = React.useState(false);
      
      const nextV = () => {
        setReveal(false);
        setVi((vi + 1) % BIELER_VOCAB.length);
      };
      
      const prevV = () => {
        setReveal(false);
        setVi((vi - 1 + BIELER_VOCAB.length) % BIELER_VOCAB.length);
      };
      
      const makeConceptQ = React.useCallback(() => {
        const item = getRandom(BIELER_CONCEPT_QA);
        return {
          prompt: item.q,
          correct: item.a,
          options: shuffle([item.a, ...shuffle(item.wrong).slice(0, 3)])
        };
      }, []);
      
      const makeApplyQ = React.useCallback(() => {
        const item = getRandom(BIELER_APPLY);
        return {
          prompt: item.scenario,
          correct: item.answer,
          options: shuffle([item.answer, ...shuffle(item.wrong).slice(0, 3)])
        };
      }, []);
      
      const [cq, setCq] = React.useState(makeConceptQ);
      const [aq, setAq] = React.useState(makeApplyQ);
      const [selC, setSelC] = React.useState(null);
      const [selA, setSelA] = React.useState(null);
      const [scoreC, setScoreC] = React.useState(0);
      const [answeredC, setAnsweredC] = React.useState(0);
      const [scoreA, setScoreA] = React.useState(0);
      const [answeredA, setAnsweredA] = React.useState(0);
      
      const answerConcept = (opt, idx) => {
        if (selC !== null) return;
        setSelC(idx);
        const ok = opt === cq.correct;
        speakSR(ok ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
        if (ok) setScoreC(s => s + 1);
        setAnsweredC(a => a + 1);
        addXP(ok ? 5 : 2);

        // Track Bieler concept mastery
        if (ok) {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.conceptCorrect = (bielerStats.conceptCorrect || 0) + 1;
          bielerStats.conceptTotal = (bielerStats.conceptTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);
        } else {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.conceptTotal = (bielerStats.conceptTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);
        }
        audioEngine.playFeedback(ok);
        vibrate(ok ? [50] : [50, 100, 50]);
        setTimeout(() => {
          setCq(makeConceptQ());
          setSelC(null);
        }, ok ? 500 : 1200);
      };
      
      const answerApply = (opt, idx) => {
        if (selA !== null) return;
        setSelA(idx);
        const ok = opt === aq.correct;
        speakSR(ok ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
        if (ok) setScoreA(s => s + 1);
        setAnsweredA(a => a + 1);
        addXP(ok ? 6 : 2);

        // Track Bieler application mastery
        if (ok) {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.applyCorrect = (bielerStats.applyCorrect || 0) + 1;
          bielerStats.applyTotal = (bielerStats.applyTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);

          // Check for bieler_scholar achievement
          if ((bielerStats.conceptCorrect || 0) >= 20 && 
              (bielerStats.applyCorrect || 0) >= 10 &&
              (bielerStats.conceptTotal || 0) >= 25) {
            checkAchievement('bieler_scholar');
          }
        } else {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.applyTotal = (bielerStats.applyTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);
        }
        audioEngine.playFeedback(ok);
        vibrate(ok ? [50] : [50, 100, 50]);
        setTimeout(() => {
          setAq(makeApplyQ());
          setSelA(null);
        }, ok ? 500 : 1200);
      };
      
      useAnswerHotkeys(
        mode !== 'vocab',
        (i) => {
          if (mode === 'concept' && cq.options[i]) answerConcept(cq.options[i], i);
          if (mode === 'apply' && aq.options[i]) answerApply(aq.options[i], i);
        },
        onBack,
        mode === 'concept' ? (cq.options?.length || 4) : (aq.options?.length || 4)
      );
      
      React.useEffect(() => {
        const onKey = (e) => {
          if (e.key === 'Escape') {
            onBack();
          }
          if (mode === 'vocab') {
            if (e.key === 'ArrowRight') nextV();
            if (e.key === 'ArrowLeft') prevV();
            if (e.key === ' ') {
              e.preventDefault();
              setReveal(true);
            }
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [mode, vi, onBack]);
      
      return (
        <div>
          <div className="card">
            <h2>ðŸ“š Technique Lab</h2>
            <p style={{color:'var(--ink-light)', marginTop:'-6px', marginBottom:'1rem'}}>
              Master violin technique through progressive study: vocabulary â†’ concepts â†’ applications
            </p>
            
            <div style={{display:'flex', gap:'0.5rem', flexWrap:'wrap', marginBottom:'1rem'}}>
              <button
                className={`btn ${mode === 'vocab' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('vocab')}
              >
                ðŸ“– Vocabulary
              </button>
              <button
                className={`btn ${mode === 'concept' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('concept')}
              >
                ðŸ§  Concepts
              </button>
              <button
                className={`btn ${mode === 'apply' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('apply')}
              >
                ðŸŽ¯ Applications
              </button>
            </div>
            
            {mode === 'vocab' && (
              <div>
                <div className="card" style={{padding:'1.5rem', textAlign:'center', marginBottom:'1rem', background:'var(--primary)', color:'#fff'}}>
                  <div style={{fontWeight:700, fontSize:'1.3rem', marginBottom:'0.75rem'}}>
                    {BIELER_VOCAB[vi].term}
                  </div>
                  {reveal ? (
                    <div style={{marginTop:'0.75rem', fontSize:'1.05rem', lineHeight:'1.6'}}>
                      {BIELER_VOCAB[vi].def}
                    </div>
                  ) : (
                    <div style={{marginTop:'0.75rem', fontStyle:'italic', opacity:0.9}}>
                      Press Reveal to show definition
                    </div>
                  )}
                </div>
                
                <div style={{display:'flex', gap:'0.5rem', justifyContent:'center', flexWrap:'wrap'}}>
                  <button className="btn btn-accent" onClick={() => setReveal(true)}>
                    ðŸ‘ï¸ Reveal
                  </button>
                  <button className="btn btn-secondary" onClick={prevV}>
                    â† Previous
                  </button>
                  <button className="btn btn-secondary" onClick={nextV}>
                    Next â†’
                  </button>
                </div>
                
                <ProgressBar
                  current={vi + 1}
                  max={BIELER_VOCAB.length}
                  label={`Card ${vi + 1} of ${BIELER_VOCAB.length}`}
                />
              </div>
            )}
            
            {mode === 'concept' && (
              <div>
                <div className="stat-card" style={{margin:'1rem 0'}}>
                  <div className="stat-label">Score</div>
                  <div className="stat-value" style={{fontSize:'1.5rem'}}>
                    {scoreC} / {answeredC}
                    {answeredC > 0 && ` (${Math.round((scoreC/answeredC)*100)}%)`}
                  </div>
                </div>
                
                <p style={{fontWeight:600, marginBottom:'1rem'}}>{cq.prompt}</p>
                
                <div role="radiogroup" aria-label="Concept answers">
                  {cq.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selC === i}
                      correct={selC === i && opt === cq.correct}
                      incorrect={selC === i && opt !== cq.correct}
                      onClick={() => answerConcept(opt, i)}
                      disabled={selC !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
              </div>
            )}
            
            {mode === 'apply' && (
              <div>
                <div className="stat-card" style={{margin:'1rem 0'}}>
                  <div className="stat-label">Score</div>
                  <div className="stat-value" style={{fontSize:'1.5rem'}}>
                    {scoreA} / {answeredA}
                    {answeredA > 0 && ` (${Math.round((scoreA/answeredA)*100)}%)`}
                  </div>
                </div>
                
                <p><em>Scenario:</em> {aq.prompt}</p>
                <p style={{fontWeight:600, marginTop:'0.5rem', marginBottom:'1rem'}}>
                  Choose the best practice approach:
                </p>
                
                <div role="radiogroup" aria-label="Application answers">
                  {aq.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selA === i}
                      correct={selA === i && opt === aq.correct}
                      incorrect={selA === i && opt !== aq.correct}
                      onClick={() => answerApply(opt, i)}
                      disabled={selA !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // FLASHCARDS (Enhanced with SM-2 Algorithm)
    // ============================================================================
    
    function Flashcards({ prefs, onBack }) {
      const buildCards = React.useCallback(() => {
        const cells = filteredCells(prefs);
        const cards = [];
        
        cells.forEach(c => {
          cards.push({
            type: 'cell',
            q: `Note at ${ordinal(c.p)} pos, ${ordinal(c.f)} finger on ${c.s}`,
            a: c.canon,
            easeFactor: 2.5,
            interval: 1,
            repetitions: 0,
            due: Date.now()
          });
        });
        
        const unique = [...new Set(cells.map(c => c.canon))];
        unique.forEach(n => {
          cards.push({
            type: 'note',
            q: `All locations for note ${n}?`,
            a: n,
            easeFactor: 2.5,
            interval: 1,
            repetitions: 0,
            due: Date.now()
          });
        });
        
        return cards;
      }, [prefs]);
      
      const [deck, setDeck] = React.useState(() => {
        const saved = loadJSON(FLASH_KEY, null);
        const savedSig = localStorage.getItem(FLASH_SIG_KEY);
        const curSig = JSON.stringify({
          strings: prefs.strings,
          positions: prefs.positions
        });
        
        if (saved && savedSig === curSig) return saved;
        
        const cards = buildCards();
        saveJSON(FLASH_KEY, cards);
        localStorage.setItem(FLASH_SIG_KEY, curSig);
        return cards;
      });
      
      React.useEffect(() => {
        const curSig = JSON.stringify({
          strings: prefs.strings,
          positions: prefs.positions
        });
        const savedSig = localStorage.getItem(FLASH_SIG_KEY);
        
        if (curSig !== savedSig) {
          const cards = buildCards();
          saveJSON(FLASH_KEY, cards);
          localStorage.setItem(FLASH_SIG_KEY, curSig);
          setDeck(cards);
        }
      }, [prefs, buildCards]);
      
      const [card, setCard] = React.useState(null);
      const [show, setShow] = React.useState(false);
      
      const pick = () => {
        if (!deck.length) {
          setCard(null);
          return;
        }
        
        const now = Date.now();
        const due = deck.filter(c => c.due <= now).sort((a, b) => a.due - b.due);
        const next = due.length ? due[0] : getRandom(deck);
        
        setCard(next);
        setShow(false);
      };
      
      React.useEffect(() => {
        pick();
      }, [deck]);
      
      // SM-2 Algorithm implementation
      const mark = (quality) => {
        // quality: 0-2 (forgot), 3-5 (remembered)
        const remembered = quality >= 3;
        
        setDeck(prev => {
          const upd = prev.map(c => {
            if (c === card) {
              let newEF = c.easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
              newEF = Math.max(1.3, newEF);
              
              let newInterval;
              let newReps;
              
              if (quality < 3) {
                newInterval = 1;
                newReps = 0;
              } else {
                if (c.repetitions === 0) {
                  newInterval = 1;
                } else if (c.repetitions === 1) {
                  newInterval = 6;
                } else {
                  newInterval = Math.round(c.interval * newEF);
                }
                newReps = c.repetitions + 1;
              }
              
              return {
                ...c,
                easeFactor: newEF,
                interval: newInterval,
                repetitions: newReps,
                due: Date.now() + newInterval * 24 * 3600 * 1000
              };
            }
            return c;
          });
          
          saveJSON(FLASH_KEY, upd);
          return upd;
        });
        
        addXP(remembered ? 5 : 2);
        speakSR(remembered ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
        audioEngine.playFeedback(remembered);
        vibrate(remembered ? [50] : [50, 100, 50]);
        
        pick();
      };
      
      if (!deck.length) {
        return (
          <div>
            <div className="card">
              <h2>âš ï¸ No Flashcards</h2>
              <p>Please enable at least one string and position in Settings.</p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }
      
      const dueCount = deck.filter(c => c.due <= Date.now()).length;
      
      return (
        <div>
          <div className="card">
            <h2>ðŸ—‚ï¸ Flashcards</h2>
            
            <div className="stat-card" style={{margin:'1rem 0'}}>
              <div className="stat-label">Cards Due for Review</div>
              <div className="stat-value" style={{fontSize:'1.8rem'}}>
                {dueCount} / {deck.length}
              </div>
            </div>
            
            {card && (
              <div>
                <div className="card" style={{
                  padding:'2rem',
                  textAlign:'center',
                  minHeight:'150px',
                  display:'flex',
                  flexDirection:'column',
                  justifyContent:'center',
                  background:'linear-gradient(135deg, var(--primary), var(--primary-dark))',
                  color:'#fff',
                  marginBottom:'1rem'
                }}>
                  <p style={{fontSize:'1.2rem', fontWeight:600, marginBottom:'1rem', color:'#fff'}}>
                    {card.q}
                  </p>
                  
                  {show ? (
                    <div>
                      <p style={{
                        fontWeight:700,
                        fontSize:'2rem',
                        margin:'1rem 0',
                        color:'#fff'
                      }}>
                        {card.a}
                      </p>
                      {card.type === 'note' && (
                        <p style={{fontSize:'0.9rem', opacity:0.9, color:'#fff'}}>
                          (Multiple positions may apply)
                        </p>
                      )}
                    </div>
                  ) : (
                    <button
                      className="btn btn-accent btn-large"
                      onClick={() => setShow(true)}
                    >
                      ðŸ‘ï¸ Reveal Answer
                    </button>
                  )}
                </div>
                
                {show && (
                  <div>
                    <p style={{textAlign:'center', marginBottom:'0.75rem', fontWeight:600}}>
                      How well did you remember?
                    </p>
                    <div className="grid grid-cols-2" style={{gap:'0.5rem'}}>
                      <button
                        className="btn btn-danger"
                        onClick={() => mark(1)}
                      >
                        ðŸ˜” Forgot
                      </button>
                      <button
                        className="btn btn-warning"
                        onClick={() => mark(3)}
                      >
                        ðŸ¤” Hard
                      </button>
                      <button
                        className="btn btn-primary"
                        onClick={() => mark(4)}
                      >
                        ðŸ˜Š Good
                      </button>
                      <button
                        className="btn btn-success"
                        onClick={() => mark(5)}
                      >
                        ðŸŽ‰ Easy
                      </button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // PROGRESS & ANALYTICS (NEW)
    // ============================================================================
    
    

    // ============================================================================
    // REFLECTION LAB - Journal & Metacognitive Practice
    // ============================================================================

    function loadReflections() {
      try {
        const raw = localStorage.getItem(REFLECTIONS_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (err) {
        console.warn('Failed to load reflections', err);
        return [];
      }
    }

    function saveReflections(entries) {
      try {
        localStorage.setItem(REFLECTIONS_KEY, JSON.stringify(entries));
      } catch (err) {
        console.warn('Failed to save reflections', err);
      }
    }

    function useReflectionJournal(defaultModule) {
      const [entries, setEntries] = React.useState(() => loadReflections());
      const [filterModule, setFilterModule] = React.useState('all');

      React.useEffect(() => {
        saveReflections(entries);
      }, [entries]);

      const addEntry = React.useCallback(
        ({ module, focus, wins, challenges, nextSteps, mood }) => {
          const now = new Date();
          const payload = {
            id: now.getTime(),
            createdAt: now.toISOString(),
            module: module || defaultModule || 'general',
            focus: (focus || '').trim(),
            wins: (wins || '').trim(),
            challenges: (challenges || '').trim(),
            nextSteps: (nextSteps || '').trim(),
            mood: mood || 'neutral',
          };

          // Ignore totally empty notes
          if (
            !payload.focus &&
            !payload.wins &&
            !payload.challenges &&
            !payload.nextSteps
          ) {
            return;
          }

          setEntries(prev => {
            const next = [payload, ...prev].slice(0, 300);

            const reflectionCount = prev.length + 1;
            if (reflectionCount === 10 && checkAchievement('reflection_10')) {
              // Achievement unlocked - will be caught by App's achievement watcher
            }

            // Reward XP for reflection
            addXP(3);
            speakSR('Reflection saved! +3 XP');

            return next;
          });
        },
        [defaultModule]
      );

      const clearAll = React.useCallback(() => {
        if (!window.confirm('Clear all reflections? This cannot be undone.')) return;
        setEntries([]);
        saveReflections([]);
      }, []);

      const filteredEntries = React.useMemo(() => {
        if (filterModule === 'all') return entries;
        return entries.filter(e => e.module === filterModule);
      }, [entries, filterModule]);

      return {
        entries,
        filteredEntries,
        filterModule,
        setFilterModule,
        addEntry,
        clearAll,
      };
    }

    
    function PracticeReflectionJournal({ currentModule, onBack }) {
            const streak = loadJSON(STREAK_KEY, { current: 0, longest: 0 });
      const xp = loadJSON(XP_KEY, 0);
      const level = levelForXP(xp);

      const moduleOptions = [
        { value: 'general', label: 'General' },
        { value: 'interval', label: 'Interval Training' },
        { value: 'rhythm', label: 'Rhythm Trainer' },
        { value: 'speed', label: 'Speed Drill' },
        { value: 'bieler', label: 'Technique Lab' }
      ];

      const defaultModuleValue =
        currentModule && moduleOptions.some(m => m.value === currentModule)
          ? currentModule
          : 'general';

      const [moduleValue, setModuleValue] = React.useState(defaultModuleValue);
      const [focus, setFocus] = React.useState('');
      const [wins, setWins] = React.useState('');
      const [challenges, setChallenges] = React.useState('');
      const [nextSteps, setNextSteps] = React.useState('');
      const [mood, setMood] = React.useState('neutral');

      const {
        entries,
        filteredEntries,
        filterModule,
        setFilterModule,
        addEntry,
        clearAll
      } = useReflectionJournal(defaultModuleValue);

      const handleTemplate = (template) => {
        if (template === 'interval') {
          setFocus('Intonation and interval recognition');
          setNextSteps(
            '1) Sing target intervals before playing\n' +
            '2) Slow double-stop checks in problem spots\n' +
            '3) Link intervals to fingerboard shapes'
          );
          setMood('focused');
        } else if (template === 'rhythm') {
          setFocus('Pulse, subdivision, and bow coordination');
          setNextSteps(
            '1) Clap and count out loud with a metronome\n' +
            '2) Tap foot only on beats 1 and 3, feel 2 & 4\n' +
            '3) Bow open strings to the same rhythm'
          );
          setMood('energized');
        } else if (template === 'speed') {
          setFocus('Quick note recognition and accuracy');
          setNextSteps(
            '1) Name notes aloud while playing slow scales\n' +
            '2) Practice position shifts with anchor notes\n' +
            '3) Review one fingerboard pattern each day'
          );
          setMood('curious');
        } else if (template === 'bieler') {
          setFocus('Sound quality, bow contact point, and leverage');
          setNextSteps(
            '1) Slow tone work near the bridge with full bow\n' +
            '2) Experiment with "polishing" vs "dusting" the string\n' +
            '3) Apply to 2â€“3 bars from current piece'
          );
          setMood('thoughtful');
        }
      };

      const handleSubmit = event => {
        event.preventDefault();
        addEntry({
          module: moduleValue,
          focus,
          wins,
          challenges,
          nextSteps,
          mood
        });

        audioEngine.playFeedback(true);
        vibrate([50]);
        speakSR('Reflection saved!');

        // soft reset
        setWins('');
        setChallenges('');
        setNextSteps('');
      };

      const mostRecent = entries[0];

      return (
        <div>
          <div className="card">
            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'1rem'}}>
              <h2 style={{margin:0}}>ðŸ“ Reflection Lab</h2>
              <div style={{display:'flex', gap:'0.5rem'}}>
                <div className="badge">
                  ðŸ”¥ Streak: {streak.current}
                </div>
                <div className="badge">
                  ðŸŽ® Level {level}
                </div>
              </div>
            </div>
            <p style={{color:'var(--ink-light)', marginTop:'-0.5rem', marginBottom:'1.5rem'}}>
              Capture what you learned so each session builds on the last.
            </p>

            <div className="grid grid-cols-2" style={{gap:'1.5rem'}}>
              {/* Left: entry form */}
              <div>
                <h3>Log today's session</h3>
                <p style={{fontSize:'0.9rem', color:'var(--ink-light)', marginBottom:'1rem'}}>
                  Use short, honest notesâ€”future-you will thank you tomorrow.
                </p>

                <form onSubmit={handleSubmit} style={{display:'flex', flexDirection:'column', gap:'1rem'}}>
                  <div>
                    <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                      Module
                    </label>
                    <select
                      style={{
                        width:'100%',
                        padding:'0.65rem',
                        borderRadius:'8px',
                        border:'2px solid var(--border)',
                        background:'var(--card)',
                        color:'var(--ink)',
                        fontSize:'0.95rem'
                      }}
                      value={moduleValue}
                      onChange={e => setModuleValue(e.target.value)}
                    >
                      {moduleOptions.map(opt => (
                        <option key={opt.value} value={opt.value}>
                          {opt.label}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                      Main focus
                    </label>
                    <input
                      style={{
                        width:'100%',
                        padding:'0.65rem',
                        borderRadius:'8px',
                        border:'2px solid var(--border)',
                        background:'var(--card)',
                        color:'var(--ink)',
                        fontSize:'0.95rem'
                      }}
                      type="text"
                      placeholder="e.g. clean 6ths in 2nd position"
                      value={focus}
                      onChange={e => setFocus(e.target.value)}
                    />
                  </div>

                  <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:'1rem'}}>
                    <div>
                      <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Biggest win(s)
                      </label>
                      <textarea
                        style={{
                          width:'100%',
                          padding:'0.65rem',
                          borderRadius:'8px',
                          border:'2px solid var(--border)',
                          background:'var(--card)',
                          color:'var(--ink)',
                          fontSize:'0.95rem',
                          fontFamily:'inherit',
                          resize:'vertical'
                        }}
                        rows={3}
                        placeholder="What went well today?"
                        value={wins}
                        onChange={e => setWins(e.target.value)}
                      />
                    </div>
                    <div>
                      <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Challenge(s)
                      </label>
                      <textarea
                        style={{
                          width:'100%',
                          padding:'0.65rem',
                          borderRadius:'8px',
                          border:'2px solid var(--border)',
                          background:'var(--card)',
                          color:'var(--ink)',
                          fontSize:'0.95rem',
                          fontFamily:'inherit',
                          resize:'vertical'
                        }}
                        rows={3}
                        placeholder="What felt hard?"
                        value={challenges}
                        onChange={e => setChallenges(e.target.value)}
                      />
                    </div>
                  </div>

                  <div>
                    <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                      Next tiny step
                    </label>
                    <textarea
                      style={{
                        width:'100%',
                        padding:'0.65rem',
                        borderRadius:'8px',
                        border:'2px solid var(--border)',
                        background:'var(--card)',
                        color:'var(--ink)',
                        fontSize:'0.95rem',
                        fontFamily:'inherit',
                        resize:'vertical'
                      }}
                      rows={3}
                      placeholder="One small thing to improve next time."
                      value={nextSteps}
                      onChange={e => setNextSteps(e.target.value)}
                    />
                  </div>

                  <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:'1rem'}}>
                    <div>
                      <span style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Mood
                      </span>
                      <div style={{display:'flex', flexWrap:'wrap', gap:'0.5rem'}}>
                        {[
                          { value: 'energized', label: 'âš¡ Energized' },
                          { value: 'focused', label: 'ðŸŽ¯ Focused' },
                          { value: 'tired', label: 'ðŸ˜´ Tired' },
                          { value: 'frustrated', label: 'ðŸ˜• Frustrated' },
                          { value: 'proud', label: 'ðŸ† Proud' }
                        ].map(m => (
                          <button
                            key={m.value}
                            type="button"
                            className="badge"
                            style={{
                              cursor:'pointer',
                              background: mood === m.value ? 'var(--accent)' : 'var(--neutral)',
                              border: mood === m.value ? '2px solid var(--accent-light)' : '2px solid transparent'
                            }}
                            onClick={() => setMood(m.value)}
                          >
                            {m.label}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <span style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Quick templates
                      </span>
                      <div style={{display:'flex', flexWrap:'wrap', gap:'0.5rem'}}>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('interval')}
                        >
                          ðŸŽ¶ Interval
                        </button>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('rhythm')}
                        >
                          ðŸ¥ Rhythm
                        </button>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('speed')}
                        >
                          âš¡ Speed
                        </button>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('bieler')}
                        >
                          ðŸ“š Technique
                        </button>
                      </div>
                    </div>
                  </div>

                  <div style={{marginTop:'0.5rem'}}>
                    <button type="submit" className="btn btn-primary btn-large" style={{width:'100%'}}>
                      ðŸ’¾ Save Reflection
                    </button>
                  </div>
                </form>
              </div>

              {/* Right: history and filters */}
              <div>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'1rem'}}>
                  <h3 style={{margin:0}}>Past Reflections</h3>
                  <button
                    type="button"
                    className="btn btn-secondary"
                    style={{padding:'0.5rem 1rem', fontSize:'0.85rem'}}
                    onClick={clearAll}
                  >
                    ðŸ—‘ï¸ Clear all
                  </button>
                </div>
                <p style={{fontSize:'0.9rem', color:'var(--ink-light)', marginBottom:'1rem'}}>
                  Scan your recent notes to remember what you're building on today.
                </p>

                <div style={{marginBottom:'1rem'}}>
                  <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                    Filter by module
                  </label>
                  <select
                    style={{
                      width:'100%',
                      padding:'0.65rem',
                      borderRadius:'8px',
                      border:'2px solid var(--border)',
                      background:'var(--card)',
                      color:'var(--ink)',
                      fontSize:'0.95rem'
                    }}
                    value={filterModule}
                    onChange={e => setFilterModule(e.target.value)}
                  >
                    <option value="all">All modules</option>
                    {moduleOptions.map(opt => (
                      <option key={opt.value} value={opt.value}>
                        {opt.label}
                      </option>
                    ))}
                  </select>
                </div>

                <div style={{maxHeight:'500px', overflowY:'auto'}}>
                  {filteredEntries.length === 0 && (
                    <p style={{
                      textAlign:'center',
                      color:'var(--ink-light)',
                      padding:'2rem 1rem',
                      fontStyle:'italic'
                    }}>
                      No reflections yet. After your next practice session, jot down one win and one next step.
                    </p>
                  )}

                  {filteredEntries.map(entry => {
                    const date = new Date(entry.createdAt);
                    return (
                      <div
                        key={entry.id}
                        style={{
                          padding:'1rem',
                          marginBottom:'0.75rem',
                          border:'1px solid var(--border)',
                          borderRadius:'8px',
                          background:'var(--card)'
                        }}
                      >
                        <div style={{
                          display:'flex',
                          gap:'0.75rem',
                          alignItems:'center',
                          marginBottom:'0.5rem',
                          fontSize:'0.85rem',
                          color:'var(--ink-light)'
                        }}>
                          <span style={{fontWeight:600}}>
                            {date.toLocaleDateString()} Â· {date.toLocaleTimeString([], {
                              hour: '2-digit',
                              minute: '2-digit'
                            })}
                          </span>
                          <span className="badge" style={{fontSize:'0.75rem'}}>
                            {moduleOptions.find(m => m.value === entry.module)?.label || 'General'}
                          </span>
                          {entry.mood && (
                            <span style={{fontSize:'1.2rem'}}>
                              {entry.mood === 'energized' && 'âš¡'}
                              {entry.mood === 'focused' && 'ðŸŽ¯'}
                              {entry.mood === 'tired' && 'ðŸ˜´'}
                              {entry.mood === 'frustrated' && 'ðŸ˜•'}
                              {entry.mood === 'proud' && 'ðŸ†'}
                            </span>
                          )}
                        </div>
                        {entry.focus && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--primary)'}}>Focus:</strong> {entry.focus}
                          </p>
                        )}
                        {entry.wins && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--success)'}}>Wins:</strong> {entry.wins}
                          </p>
                        )}
                        {entry.challenges && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--warning)'}}>Challenges:</strong> {entry.challenges}
                          </p>
                        )}
                        {entry.nextSteps && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--accent)'}}>Next step:</strong> {entry.nextSteps}
                          </p>
                        )}
                      </div>
                    );
                  })}

                  {mostRecent && (
                    <div style={{
                      background:'linear-gradient(135deg, var(--primary-light), var(--primary))',
                      color:'#fff',
                      padding:'1rem',
                      borderRadius:'12px',
                      marginTop:'1rem'
                    }}>
                      <h3 style={{marginTop:0, color:'#fff'}}>Most recent theme</h3>
                      <p style={{marginBottom:'0.5rem'}}>
                        <strong>
                          {moduleOptions.find(m => m.value === mostRecent.module)?.label}:
                        </strong>{' '}
                        {mostRecent.focus || 'No focus recorded.'}
                      </p>
                      {mostRecent.nextSteps && (
                        <p style={{marginBottom:0, fontSize:'0.9rem', opacity:0.95}}>
                          {mostRecent.nextSteps}
                        </p>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    
    // ============================================================================
    // DAILY QUEST - Interleaved Practice Mode (NEW)
    // ============================================================================

    function DailyQuest({ prefs, onBack }) {
      const QUEST_KEY = 'vmq.v6.dailyQuest';
      const QUEST_DATE_KEY = 'vmq.v6.questDate';

      const [questData, setQuestData] = React.useState(() => {
        const today = new Date().toDateString();
        const lastDate = localStorage.getItem(QUEST_DATE_KEY);

        if (lastDate === today) {
          return loadJSON(QUEST_KEY, null);
        }

        // Generate new quest
        return {
          speedDrill: 5,
          interval: 3,
          rhythm: 2,
          bieler: 1,
          completed: {
            speedDrill: 0,
            interval: 0,
            rhythm: 0,
            bieler: 0
          },
          bonusEarned: false
        };
      });

      React.useEffect(() => {
        const today = new Date().toDateString();
        localStorage.setItem(QUEST_DATE_KEY, today);
        saveJSON(QUEST_KEY, questData);
      }, [questData]);

      const totalRequired = questData.speedDrill + questData.interval + questData.rhythm + questData.bieler;
      const totalCompleted = Object.values(questData.completed).reduce((a, b) => a + b, 0);
      const progressPercent = (totalCompleted / totalRequired) * 100;
      const isComplete = totalCompleted >= totalRequired;

      React.useEffect(() => {
        if (isComplete && !questData.bonusEarned) {
          addXP(50); // Bonus XP for completing quest
          audioEngine.playCelebration();
          vibrate([50, 100, 50, 100, 50]);
          speakSR('Daily Quest complete! Bonus 50 XP earned!');
          setQuestData(prev => ({ ...prev, bonusEarned: true }));
        }
      }, [isComplete, questData.bonusEarned]);

      const startModule = (moduleName) => {
        // This would navigate to the specific module
        // For now, just show a message
        alert(`Starting ${moduleName}. Complete your practice, then return here!`);
      };

      return (
        <div>
          <div className="card">
            <h2>ðŸ“… Daily Quest</h2>
            <p style={{ color: 'var(--ink-light)', marginTop: '-0.5rem' }}>
              Complete today's interleaved practice for bonus XP!
            </p>

            <ProgressBar
              current={totalCompleted}
              max={totalRequired}
              label={`${totalCompleted} / ${totalRequired} tasks complete`}
            />

            {isComplete && (
              <div style={{
                marginTop: '1rem',
                padding: '1rem',
                background: 'linear-gradient(135deg, var(--success), var(--primary))',
                color: '#fff',
                borderRadius: '12px',
                textAlign: 'center'
              }}>
                <h3 style={{ margin: 0, color: '#fff' }}>ðŸŽ‰ Quest Complete!</h3>
                <p style={{ margin: '0.5rem 0 0' }}>+50 Bonus XP â€¢ Come back tomorrow for a new quest!</p>
              </div>
            )}

            <div style={{ marginTop: '1.5rem', display: 'grid', gap: '1rem' }}>
              {/* Speed Drill Tasks */}
              <div className="card card-compact">
                <h3>âš¡ Speed Drill</h3>
                <p style={{ fontSize: '0.9rem', color: 'var(--ink-light)' }}>
                  Complete {questData.speedDrill} speed drill questions
                </p>
                <ProgressBar
                  current={questData.completed.speedDrill}
                  max={questData.speedDrill}
                  label={`${questData.completed.speedDrill} / ${questData.speedDrill}`}
                />
                {questData.completed.speedDrill < questData.speedDrill && (
                  <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                    <button 
                      className="btn btn-primary"
                      onClick={() => startModule('Speed Drill')}
                    >
                      Practice Now
                    </button>
                    <button 
                      className="btn btn-secondary"
                       // Speed Drill â€œMark 1 Done"
                      onClick={() =>
                        setQuestData(prev => ({
                          ...prev,
                          completed: {
                            ...prev.completed,
                            speedDrill: Math.min(
                              prev.speedDrill, 
                              prev.completed.speedDrill + 1
                            ),
                          },
                        }))
                      }
                    >
                      âœ”ï¸ Mark 1 Done
                    </button>
                  </div>
                )}
              </div>

              {/* Interval Tasks */}
              <div className="card card-compact">
                <h3>ðŸŽ¶ Interval Training</h3>
                <p style={{ fontSize: '0.9rem', color: 'var(--ink-light)' }}>
                  Complete {questData.interval} interval recognition tasks
                </p>
                <ProgressBar
                  current={questData.completed.interval}
                  max={questData.interval}
                  label={`${questData.completed.interval} / ${questData.interval}`}
                />
                {questData.completed.interval < questData.interval && (
                  <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                    <button 
                      className="btn btn-primary"
                      onClick={() => startModule('Interval Training')}
                    >
                      Practice Now
                    </button>
                    <button 
                      className="btn btn-secondary"
                       // Interval "Mark 1 Done"
                      onClick={() =>
                        setQuestData(prev => ({
                          ...prev,
                          completed: {
                            ...prev.completed,
                            interval: Math.min(
                              prev.interval,
                              prev.completed.interval + 1
                            ),
                          },
                        }))
                      }
                    >
                      âœ”ï¸ Mark 1 Done
                    </button>
                  </div>
                )}
              </div>

              {/* Rhythm Tasks */}
              <div className="card card-compact">
                <h3>ðŸ¥ Rhythm Trainer</h3>
                <p style={{ fontSize: '0.9rem', color: 'var(--ink-light)' }}>
                  Complete {questData.rhythm} rhythm patterns
                </p>
                <ProgressBar
                  current={questData.completed.rhythm}
                  max={questData.rhythm}
                  label={`${questData.completed.rhythm} / ${questData.rhythm}`}
                />
                {questData.completed.rhythm < questData.rhythm && (
                  <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                    <button 
                      className="btn btn-primary"
                      onClick={() => startModule('Rhythm Trainer')}
                    >
                      Practice Now
                    </button>
                    <button 
                      className="btn btn-secondary"
                       // Rhythm "Mark 1 Done"
                      onClick={() =>
                        setQuestData(prev => ({
                          ...prev,
                          completed: {
                            ...prev.completed,
                            rhythm: Math.min(
                              prev.rhythm,
                              prev.completed.rhythm + 1
                            ),
                          },
                        }))
                      }
                    >
                      âœ”ï¸ Mark 1 Done
                    </button>
                  </div>
                )}
              </div>

              {/* Bieler Tasks */}
              <div className="card card-compact">
                <h3>ðŸ“š Technique Lab</h3>
                <p style={{ fontSize: '0.9rem', color: 'var(--ink-light)' }}>
                  Answer {questData.bieler} technique concept
                </p>
                <ProgressBar
                  current={questData.completed.bieler}
                  max={questData.bieler}
                  label={`${questData.completed.bieler} / ${questData.bieler}`}
                />
                {questData.completed.bieler < questData.bieler && (
                  <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                    <button 
                      className="btn btn-primary"
                      onClick={() => startModule('Technique Lab')}
                    >
                      Practice Now
                    </button>
                    <button 
                      className="btn btn-secondary"
                       // Bieler "Mark 1 Done"
                      onClick={() =>
                        setQuestData(prev => ({
                          ...prev,
                          completed: {
                            ...prev.completed,
                            bieler: Math.min(
                              prev.bieler,
                              prev.completed.bieler + 1
                            ),
                          },
                        }))
                      }
                    >
                      âœ”ï¸ Mark 1 Done
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>

          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    
    // ============================================================================
    // FINGERBOARD QUIZ - Interactive Board Mode (NEW)
    // ============================================================================

    function FingerboardQuiz({ prefs, onBack }) {
      const cells = React.useMemo(() => filteredCells(prefs), [prefs]);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [feedback, setFeedback] = React.useState(null);

      const generateQuestion = React.useCallback(() => {
        if (!cells.length) {
          setQ(null);
          return;
        }
      
        const bkt = loadBKT();
      
        // Weighted selection of target using BKT mastery
        const weights = cells.map(c => bktPracticeWeight(bkt, c.s, c.p, c.f));
        const total = weights.reduce((sum, w) => sum + w, 0) || 1;
      
        let r = Math.random() * total;
        let chosen = cells[cells.length - 1];
      
        for (let i = 0; i < cells.length; i++) {
          r -= weights[i];
          if (r <= 0) {
            chosen = cells[i];
            break;
          }
        }
      
        const target = chosen;
        const highlights = [];
      
        // Add 3 distractors (still random, but could also be mastery-aware later)
        const distractors = shuffle(
          cells.filter(c => c.canon !== target.canon)
        ).slice(0, 3);
      
        distractors.forEach(d => {
          highlights.push({ s: d.s, p: d.p, f: d.f, kind: 'distractor' });
        });
      
        setQ({ target, highlights });
        setSelected(null);
        setFeedback(null);
      }, [cells]);

      React.useEffect(() => {
        generateQuestion();
      }, [generateQuestion]);

      const handleSelect = (cell) => {
        if (selected) return;

        const cellKey = `${cell.s}:${cell.p}:${cell.f}`;
        const targetKey = `${q.target.s}:${q.target.p}:${q.target.f}`;
        const ok = cellKey === targetKey;
        
        // Update BKT mastery for this frame
        recordBKTObservation(q.target.s, q.target.p, q.target.f, ok);

        setSelected(cell);
        setAnswered(a => a + 1);

        if (ok) {
          setScore(s => s + 1);
          setFeedback({ type: 'success', message: getRandom(PRAISE_MESSAGES) });
          audioEngine.playFeedback(true);
          vibrate([50]);
          addXP(10);
        } else {
          setFeedback({ 
            type: 'error', 
            message: `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct: ${q.target.s} string, ${ordinal(q.target.p)} pos, finger ${q.target.f}`
          });
          audioEngine.playFeedback(false);
          vibrate([50, 100, 50]);
          addXP(2);
        }

        updateStat(targetKey, ok);

        setTimeout(() => {
          generateQuestion();
        }, ok ? 1000 : 2000);
      };

      if (!cells.length) {
        return (
          <div>
            <div className="card">
              <h2>No Practice Items</h2>
              <p>Please enable at least one string and position in Settings.</p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }

      if (!q) return null;

      const highlightedCells = [
        ...q.highlights,
        selected ? { 
          s: selected.s, 
          p: selected.p, 
          f: selected.f, 
          kind: `${selected.s}:${selected.p}:${selected.f}` === `${q.target.s}:${q.target.p}:${q.target.f}` ? 'correct' : 'chosen'
        } : null
      ].filter(Boolean);

      return (
        <div>
          <div className="card">
            <h2>ðŸŽ¯ Fingerboard Quiz</h2>

            <div className="stat-card" style={{ margin: '1rem 0' }}>
              <div className="stat-label">Score</div>
              <div className="stat-value" style={{ fontSize: '1.5rem' }}>
                {score} / {answered} {answered > 0 && `(${Math.round((score / answered) * 100)}%)`}
              </div>
            </div>

            <p style={{ fontSize: '1.2rem', fontWeight: 600, textAlign: 'center', marginBottom: '1.5rem' }}>
              Find: <strong style={{ color: 'var(--primary)' }}>{q.target.canon}</strong> on 
              <strong style={{ color: 'var(--primary)' }}> {q.target.s} string</strong>, 
              <strong style={{ color: 'var(--primary)' }}> {ordinal(q.target.p)} position</strong>
            </p>

            <VisualFingerboard
              highlight={highlightedCells}
              onSelect={handleSelect}
              disabled={!!selected}
              showNotes={false}
            />

            {feedback && (
              <div style={{
                marginTop: '1rem',
                padding: '0.75rem',
                borderRadius: '8px',
                background: feedback.type === 'success' ? 'var(--success)' : 'var(--warning)',
                color: '#fff',
                fontWeight: 600,
                textAlign: 'center'
              }}>
                {feedback.message}
              </div>
            )}
          </div>

          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    function ProgressScreen({ onBack }) {
      const stats = loadJSON(STATS_KEY, {});
      const xp = loadJSON(XP_KEY, 0);
      const level = levelForXP(xp);
      const nextXP = nextLevelXP(level);
      const currentLevelXP = level > 1 ? nextLevelXP(level - 1) : 0;
      const progressInLevel = xp - currentLevelXP;
      const xpNeeded = nextXP - currentLevelXP;
      const percentToNext = (progressInLevel / xpNeeded) * 100;
      
      const achievements = loadJSON(ACHIEVEMENTS_KEY, []);
      const unlockedAchievements = ACHIEVEMENTS.filter(a => achievements.includes(a.id));
      
      const streak = loadJSON(STREAK_KEY, { current: 0, longest: 0 });
      
      // Calculate accuracy by position and string
      const positionStats = {};
      const stringStats = {};
      
      Object.entries(stats).forEach(([key, st]) => {
        const [s, p, f] = key.split(':');
        const acc = st.total > 0 ? (st.correct / st.total) * 100 : 0;
        
        if (!positionStats[p]) positionStats[p] = { correct: 0, total: 0 };
        positionStats[p].correct += st.correct;
        positionStats[p].total += st.total;
        
        if (!stringStats[s]) stringStats[s] = { correct: 0, total: 0 };
        stringStats[s].correct += st.correct;
        stringStats[s].total += st.total;
      });
      
      // ðŸ”¥ BKT-based mastery grid, string Ã— position
      const positionHeat = buildPositionHeat(); // 0â€“1 P(know) per [position][string]
      
      const getHeatColor = (acc) => {
        if (acc >= 90) return 'var(--success)';
        if (acc >= 75) return 'var(--primary)';
        if (acc >= 60) return 'var(--warning)';
        return 'var(--danger)';
      };
      
      return (
        <div>
          <div className="card">
            <h2>ðŸ“Š Your Progress</h2>
            
            <div className="grid grid-cols-3" style={{marginBottom:'1.5rem'}}>
              <div className="stat-card">
                <div className="stat-label">Level</div>
                <div className="stat-value">{level}</div>
              </div>
              <div className="stat-card">
                <div className="stat-label">Total XP</div>
                <div className="stat-value">{xp.toLocaleString()}</div>
              </div>
              <div className="stat-card">
                <div className="stat-label">Streak</div>
                <div className="stat-value">
                  {streak.current > 0 && <span className="streak-fire">ðŸ”¥</span>}
                  {streak.current}
                </div>
              </div>
            </div>
            
            <ProgressBar
              current={progressInLevel}
              max={xpNeeded}
              label={`Level ${level} Progress`}
            />
            
            <div style={{marginTop:'2rem'}}>
              <h3>ðŸ† Achievements ({unlockedAchievements.length} / {ACHIEVEMENTS.length})</h3>
              <div style={{display:'flex', flexWrap:'wrap', gap:'0.5rem', marginTop:'0.75rem'}}>
                {ACHIEVEMENTS.map(ach => {
                  const unlocked = achievements.includes(ach.id);
                  return (
                    <div
                      key={ach.id}
                      className="badge"
                      style={{
                        opacity: unlocked ? 1 : 0.3,
                        background: unlocked ? 'var(--accent)' : 'var(--neutral)'
                      }}
                      title={`${ach.name}: ${ach.desc}`}
                    >
                      {ach.icon} {ach.name}
                    </div>
                  );
                })}
              </div>
            </div>
            
            <div style={{ marginTop: '2rem' }}>
              <h3>ðŸ§  Mastery Map (BKT)</h3>
              <p style={{ marginTop: '0.25rem', color: 'var(--ink-light)', fontSize: '0.9rem' }}>
                Average mastery per string and position (0â€“100%). Darker green = stronger, red = needs attention.
              </p>
              <div
                style={{
                  marginTop: '0.75rem',
                  overflowX: 'auto',
                }}
              >
                <div
                  className="grid"
                  style={{
                    gridTemplateColumns: `repeat(${POSITIONS.length + 1}, minmax(70px, 1fr))`,
                    gap: '0.25rem',
                    alignItems: 'stretch',
                  }}
                >
                  {/* Header row: empty corner + position labels */}
                  <div style={{ fontWeight: 600, fontSize: '0.85rem' }}></div>
                  {POSITIONS.map(p => (
                    <div
                      key={p}
                      style={{
                        textAlign: 'center',
                        fontWeight: 600,
                        fontSize: '0.85rem',
                        padding: '0.25rem 0',
                      }}
                    >
                      {positionLabelShort(p)}
                    </div>
                  ))}

                  {/* Rows per string */}
                  {STRINGS.map(s => (
                    <React.Fragment key={s}>
                      <div
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          fontWeight: 600,
                          fontSize: '0.9rem',
                        }}
                      >
                        {s} string
                      </div>
                      {POSITIONS.map(p => {
                        const v = positionHeat[p]?.[s] || 0;   // 0â€“1
                        const pct = Math.round(v * 100);
                        const bg = getHeatColor(pct);          // reuse your existing helper

                        return (
                          <div
                            key={`${s}-${p}`}
                            className="heat-cell"
                            style={{
                              background: bg,
                              textAlign: 'center',
                              fontSize: '0.8rem',
                              lineHeight: 1.2,
                            }}
                            title={`${s} string, ${positionLabelShort(p)}: ${pct}% mastery`}
                          >
                            {pct}%
                          </div>
                        );
                      })}
                    </React.Fragment>
                  ))}
                </div>
              </div>
            </div>
            
            <div style={{marginTop:'2rem'}}>
              <h3>ðŸ“ˆ Accuracy by Position</h3>
              <div className="grid" style={{gridTemplateColumns:'repeat(auto-fit, minmax(100px, 1fr))', gap:'0.5rem', marginTop:'0.75rem'}}>
                {POSITIONS.map(p => {
                  const st = positionStats[p] || { correct: 0, total: 0 };
                  const acc = st.total > 0 ? (st.correct / st.total) * 100 : 0;
                  return (
                    <div
                      key={p}
                       className="heat-cell"
                       title={`${positionLabelShort(p)} Position: ${Math.round(acc)}% (${st.correct}/${st.total})`}
                    >
                       {positionLabelShort(p)}<br />{Math.round(acc)}%
                    </div>
                  );
                })}
              </div>
            </div>
            
            <div style={{marginTop:'2rem'}}>
              <h3>ðŸŽ» Accuracy by String</h3>
                          <div className="grid" style={{gridTemplateColumns:'repeat(auto-fit, minmax(100px, 1fr))', gap:'0.5rem', marginTop:'0.75rem'}}>
                {STRINGS.map(s => {
                  const st = stringStats[s] || { correct: 0, total: 0 };
                  const acc = st.total > 0 ? (st.correct / st.total) * 100 : 0;
                  return (
                    <div
                      key={s}
                      className="heat-cell"
                      style={{background: getHeatColor(acc)}}
                      title={`${s} String: ${Math.round(acc)}% (${st.correct}/${st.total})`}
                    >
                      {s} String<br/>{Math.round(acc)}%
                    </div>
                  );
                })}
              </div>
            </div>
            
            {streak.longest > 0 && (
              <div style={{marginTop:'2rem', textAlign:'center'}}>
                <div className="badge badge-large">
                  ðŸ† Longest Streak: {streak.longest} {streak.longest === 1 ? 'day' : 'days'}
                </div>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    /*** Position Reference â€“ Violin Note Chart by Position
     *
     * Shows a table of notes for each string and finger in the selected position.
     * Layout can be viewed as Strings Ã— Fingers or Fingers Ã— Strings, and colors
     * can either follow the string tints or the pitch class. Uses the same
     * canonical pitch logic as the trainers so everything stays consistent.
     */
    function PositionReference({ position, onBack }) {
      // If a position prop is provided and valid, use it as the initial position.
      // Otherwise, default to the first entry in POSITIONS.
      const initialPos =
        typeof position === 'number' && POSITIONS.includes(position)
          ? position
          : POSITIONS[0];
    
      const [pos, setPos] = React.useState(initialPos);
      const [layoutCols, setLayoutCols] = React.useState('strings'); // 'strings' | 'fingers'
      const [colorMode, setColorMode]   = React.useState('strings'); // 'strings' | 'notes'
    
      const next = () =>
        setPos(p => (p === POSITIONS[POSITIONS.length - 1] ? POSITIONS[0] : p + 1));
      const prev = () =>
        setPos(p => (p === POSITIONS[0] ? POSITIONS[POSITIONS.length - 1] : p - 1));
    
      // Pitch-class helper for a given string / position / finger
      const pcAt = (s, p, f) =>
        ((OPEN_PC[s] + POS_SHIFT[p] + BASE_OFF[f]) % 12 + 12) % 12;
    
      const ENH = {
        0:  'C',
        1:  'Câ™¯/Dâ™­',
        2:  'D',
        3:  'Dâ™¯/Eâ™­',
        4:  'E',
        5:  'F',
        6:  'Fâ™¯/Gâ™­',
        7:  'G',
        8:  'Gâ™¯/Aâ™­',
        9:  'A',
        10: 'Aâ™¯/Bâ™­',
        11: 'B'
      };
    
      const labelFor = pc => ENH[pc] || NOTE_NAME[pc];
    
      // Color schemes
      const stringTint = {
        E: 'rgba(58,91,160,0.15)',
        A: 'rgba(230,159,0,0.15)',
        D: 'rgba(0,158,115,0.15)',
        G: 'rgba(213,94,0,0.15)'
      };
    
      const noteHue = pc => `hsla(${(pc * 30) % 360}, 65%, 70%, 0.28)`;
      const bgForCell = (s, pc) =>
        colorMode === 'strings' ? stringTint[s] : noteHue(pc);
    
      const cols = layoutCols === 'strings' ? STRINGS : FINGERS;
      const rows = layoutCols === 'strings' ? FINGERS : STRINGS;
    
      // Header labels / aria helpers (using global ordinal helpers)
    
      const colHead = c =>
        layoutCols === 'strings' ? c : `${ordinal(c)} finger`;
      
      const rowHeadVisible = r =>
        layoutCols === 'strings' ? ordinalShort(r) : r;
      
      const rowHeadAria = r =>
        layoutCols === 'strings'
          ? `${ordinal(r)} finger`
          : `${r} string`;
    
      const cellSF = (row, col) =>
        layoutCols === 'strings'
          ? { s: col, f: row }
          : { s: row, f: col };
    
      const CELL_STYLE = {
        height: 56,
        minHeight: 56,
        border: '1px solid var(--border)',
        borderRadius: 10,
        padding: '10px 12px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        textAlign: 'center',
        fontWeight: 600,
        lineHeight: 1.1,
        whiteSpace: 'nowrap'
      };
    
      const HEAD_COL_W = 'clamp(4ch, 9.5vw, 7ch)';
    
      return (
        <div>
          <div className="card">
            <h2>Positions Charts</h2>
    
            {/* Layout & color controls */}
            <div
              className="grid"
              style={{
                gridTemplateColumns: '1fr 1fr',
                gap: '1rem',
                marginBottom: '0.25rem'
              }}
            >
              <div role="radiogroup" aria-label="Layout (columns)">
                <div style={{ fontWeight: 600, marginBottom: 6 }}>Layout</div>
                <OptionButton
                  label="Strings"
                  selected={layoutCols === 'strings'}
                  onClick={() => setLayoutCols('strings')}
                />
                <OptionButton
                  label="Fingers"
                  selected={layoutCols === 'fingers'}
                  onClick={() => setLayoutCols('fingers')}
                />
              </div>
    
              <div role="radiogroup" aria-label="Color mode">
                <div style={{ fontWeight: 600, marginBottom: 6 }}>Colors</div>
                <OptionButton
                  label="Strings"
                  selected={colorMode === 'strings'}
                  onClick={() => setColorMode('strings')}
                />
                <OptionButton
                  label="Notes"
                  selected={colorMode === 'notes'}
                  onClick={() => setColorMode('notes')}
                />
              </div>
            </div>
    
            {/* Position chip */}
            <div
              style={{
                display: 'flex',
                justifyContent: 'center',
                margin: '10px 0 6px'
              }}
            >
              <span
                aria-label={`Notes of ${positionLabelShort(pos)} position`}
                style={{
                  display: 'inline-flex',
                  alignItems: 'center',
                  padding: '0.35rem 0.75rem',
                  borderRadius: 9999,
                  border: '1px solid var(--border)',
                  fontWeight: 700,
                  letterSpacing: '.01em',
                  color: 'var(--ink)',
                  background: 'var(--card)',
                  boxShadow: '0 1px 0 rgba(0,0,0,0.02)'
                }}
              >
                {positionLabelShort(pos)} position
              </span>
            </div>
    
            {/* Note table */}
            <table
              style={{
                width: '100%',
                borderCollapse: 'separate',
                borderSpacing: '8px',
                tableLayout: 'fixed'
              }}
            >
              <thead>
                <tr>
                  <th scope="col" style={{ width: HEAD_COL_W }} />
                  {cols.map(c => (
                    <th
                      scope="col"
                      key={String(c)}
                      style={{ textAlign: 'center', fontWeight: 700 }}
                    >
                      {colHead(c)}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {rows.map(r => (
                  <tr key={String(r)}>
                    <th
                      scope="row"
                      aria-label={rowHeadAria(r)}
                      style={{
                        width: HEAD_COL_W,
                        textAlign: 'right',
                        paddingRight: 8,
                        whiteSpace: 'nowrap',
                        fontWeight: 600
                      }}
                    >
                      {rowHeadVisible(r)}
                    </th>
                    {cols.map(c => {
                      const { s, f } = cellSF(r, c);
                      const pc = pcAt(s, pos, f);
                      return (
                        <td key={`${s}-${f}`} style={{ padding: 0 }}>
                          <div
                            style={{
                              ...CELL_STYLE,
                              background: bgForCell(s, pc)
                            }}
                            title={`${s} string â€¢ ${ordinal(f)} finger`}
                          >
                            {labelFor(pc)}
                          </div>
                        </td>
                      );
                    })}
                  </tr>
                ))}
              </tbody>
            </table>
    
            {/* Position selector */}
            <div
              role="radiogroup"
              aria-label="Select position"
              style={{
                display: 'flex',
                gap: '.5rem',
                justifyContent: 'center',
                marginTop: '.75rem'
              }}
            >
              {POSITIONS.map(n => (
                // now uses global positionLabelShort helper
                <OptionButton
                  key={n}
                  label={positionLabelShort(n)}
                  selected={pos === n}
                  onClick={() => setPos(n)}
                />
              ))}
            </div>
    
            {/* Previous / Next helpers */}
            <div
              style={{
                display: 'flex',
                gap: '.5rem',
                justifyContent: 'center',
                marginTop: '.75rem'
              }}
            >
              <button className="btn btn-secondary" type="button" onClick={prev}>
                â† Previous
              </button>
              <button className="btn btn-secondary" type="button" onClick={next}>
                Next â†’
              </button>
            </div>
          </div>
    
          <button className="btn btn-secondary" onClick={onBack}>
            Back
          </button>
        </div>
      );
    }
    
    // ============================================================================
    // SETTINGS SCREEN (Enhanced)
    // ============================================================================
    
    function Settings({ prefs, setPrefs, onBack }) {
      const [localPrefs, setLocalPrefs] = React.useState(prefs);
      const [muted, setMuted] = React.useState(audioEngine.mute);
      const [dark, setDark] = React.useState(
        document.documentElement.classList.contains('dark')
      );
      
      // BKT-based mastery for progressive unlock (positions 6â€“10)
      const positionHeat = buildPositionHeat();

      let baseSum = 0;
      let baseCount = 0;
      for (const p of [1, 2, 3, 4, 5]) {
        for (const s of STRINGS) {
          const v = positionHeat[p]?.[s] ?? 0;
          baseSum += v;
          baseCount += 1;
        }
      }
      const baseMastery = baseCount ? baseSum / baseCount : 0; // 0â€“1
      const POS_UNLOCK_THRESHOLD = 0.75;

      const isPositionLocked = (p) =>
        p > 5 && baseMastery < POS_UNLOCK_THRESHOLD;
    
      const save = () => {
        // Keep prefs.soundEnabled and audioEngine.mute aligned
        const nextPrefs = {
          ...localPrefs,
          soundEnabled: !muted,
        };
    
        setPrefs(nextPrefs);
        saveJSON(PREFS_KEY, nextPrefs);
    
        audioEngine.setMute(muted);
        window.__setTheme(dark);
    
        // Check all_positions achievement
        const allEnabled = POSITIONS.every(p => nextPrefs.positions[p]);
        if (allEnabled) {
          const stats = loadJSON(STATS_KEY, {});
          const practiceAllPos = POSITIONS.every(p => {
            return Object.keys(stats).some(key => {
              const [, pos] = key.split(':');
              return pos == p;
            });
          });
          if (practiceAllPos) {
            checkAchievement('all_positions');
          }
        }
    
        onBack();
      };
    
      const resetProgress = () => {
        if (confirm('Are you sure you want to reset ALL progress? This cannot be undone!')) {
          localStorage.removeItem(XP_KEY);
          localStorage.removeItem(STATS_KEY);
          localStorage.removeItem(ACHIEVEMENTS_KEY);
          localStorage.removeItem(STREAK_KEY);
          localStorage.removeItem(FLASH_KEY);
          alert('Progress reset! Reloading...');
          window.location.reload();
        }
      };
    
      return (
        <div>
          <div className="card">
            <h2>âš™ï¸ Settings</h2>
    
            {/* Practice Strings */}
            <div style={{ marginTop: '1.5rem' }}>
              <h3>ðŸŽ» Practice Strings</h3>
              <div className="grid grid-cols-2" style={{ gap: '0.5rem', marginTop: '0.75rem' }}>
                {STRINGS.map(s => (
                  <button
                    key={s}
                    className={`btn ${localPrefs.strings[s] ? 'btn-primary' : 'btn-secondary'}`}
                    onClick={() =>
                      setLocalPrefs(p => ({
                        ...p,
                        strings: { ...p.strings, [s]: !p.strings[s] },
                      }))
                    }
                  >
                    {s} String {localPrefs.strings[s] ? 'âœ“' : ''}
                  </button>
                ))}
              </div>
            </div>
    
            {/* Practice Positions */}
            <div style={{ marginTop: '1.5rem' }}>
              <h3>ðŸ“ Practice Positions</h3>
              <p
                style={{
                  marginTop: '0.25rem',
                  color: 'var(--ink-light)',
                  fontSize: '0.9rem',
                }}
              >
                Positions 1â€“5 are your foundation. Positions 6â€“10 unlock once your average mastery
                in 1stâ€“5th position reaches about 75%.
              </p>
              <div
                className="grid grid-cols-3"
                style={{ gap: '0.5rem', marginTop: '0.75rem' }}
              >
                {POSITIONS.map(p => {
                  const locked = isPositionLocked(p);
                  const pressed = !!localPrefs.positions[p];

                  return (
                    <button
                      key={p}
                      className={`btn ${
                        pressed && !locked ? 'btn-primary' : 'btn-secondary'
                      }`}
                      disabled={locked}
                      onClick={() => {
                        if (locked) return;
                        setLocalPrefs(pr => ({
                          ...pr,
                          positions: { ...pr.positions, [p]: !pr.positions[p] },
                        }));
                      }}
                      title={
                        locked
                          ? 'Keep practicing positions 1â€“5; higher positions unlock at ~75% average mastery.'
                          : `Toggle practice in position ${p}`
                      }
                      style={{
                        opacity: locked ? 0.5 : 1,
                        cursor: locked ? 'not-allowed' : 'pointer',
                      }}
                    >
                      {locked ? 'ðŸ”’ ' : ''}
                      Pos {p} {pressed && !locked ? 'âœ“' : ''}
                    </button>
                  );
                })}
              </div>
            </div>
    
            {/* Appearance & Sound */}
            <div style={{ marginTop: '1.5rem' }}>
              <h3>ðŸŽ¨ Appearance & Sound</h3>
              <div
                style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '0.75rem',
                  marginTop: '0.75rem',
                }}
              >
                {/* Dark Mode */}
                <label
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.75rem',
                    cursor: 'pointer',
                  }}
                >
                  <input
                    type="checkbox"
                    checked={dark}
                    onChange={e => setDark(e.target.checked)}
                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                  />
                  <span style={{ fontWeight: 600 }}>ðŸŒ™ Dark Mode</span>
                </label>
    
                {/* Sound Effects */}
                <label
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.75rem',
                    cursor: 'pointer',
                  }}
                >
                  <input
                    type="checkbox"
                    checked={!muted}
                    onChange={e => {
                      const enabled = e.target.checked;
                      setMuted(!enabled); // muted is the inverse of enabled
                      setLocalPrefs(p => ({
                        ...p,
                        soundEnabled: enabled,
                      }));
                    }}
                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                  />
                  <span style={{ fontWeight: 600 }}>ðŸ”Š Sound Effects</span>
                </label>
    
                {/* Haptic Feedback */}
                <label
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.75rem',
                    cursor: 'pointer',
                  }}
                >
                  <input
                    type="checkbox"
                    checked={localPrefs.hapticEnabled}
                    onChange={e =>
                      setLocalPrefs(p => ({
                        ...p,
                        hapticEnabled: e.target.checked,
                      }))
                    }
                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                  />
                  <span style={{ fontWeight: 600 }}>ðŸ“³ Haptic Feedback</span>
                </label>
              </div>
            </div>
    
            {/* Danger Zone */}
            <div style={{ marginTop: '1.5rem' }}>
              <h3>âš ï¸ Danger Zone</h3>
              <button
                className="btn btn-danger"
                onClick={resetProgress}
                style={{ marginTop: '0.75rem' }}
              >
                ðŸ—‘ï¸ Reset All Progress
              </button>
            </div>
    
            {/* Footer Actions */}
            <div
              style={{
                marginTop: '2rem',
                display: 'flex',
                gap: '0.5rem',
                justifyContent: 'flex-end',
              }}
            >
              <button className="btn btn-secondary" onClick={onBack}>
                Cancel
              </button>
              <button className="btn btn-primary" onClick={save}>
                ðŸ’¾ Save Settings
              </button>
            </div>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // TUTORIAL / ONBOARDING (NEW)
    // ============================================================================
    
    function Tutorial({ onComplete }) {
      const [step, setStep] = React.useState(0);
      
      const steps = [
        {
          title: 'Welcome to Violin Mastery Quest! ðŸŽ»',
          content: 'This app will help you master the violin fingerboard through fun, adaptive practice. Let\'s take a quick tour!',
          icon: 'ðŸ‘‹'
        },
        {
          title: 'Earn XP & Level Up ðŸ“ˆ',
          content: 'Every correct answer earns you experience points (XP). Level up to unlock achievements and track your progress!',
          icon: 'â­'
        },
        {
          title: 'Build Your Streak ðŸ”¥',
          content: 'Practice daily to build your streak! The longer your streak, the more achievements you\'ll unlock.',
          icon: 'ðŸ“…'
        },
        {
          title: 'Multiple Learning Modes ðŸŽ¯',
          content: 'Speed Drill for quick practice, Flashcards for spaced repetition, Interval Training for ear development, and more!',
          icon: 'ðŸŽ®'
        },
        {
          title: 'Adaptive Learning ðŸ§ ',
          content: 'The app tracks your weak spots and gives you more practice on challenging notes and positions.',
          icon: 'ðŸ“Š'
        },
        {
          title: 'You\'re Ready! ðŸš€',
          content: 'Start with Speed Drill or explore the other modes. Remember: consistent practice is the key to mastery!',
          icon: 'ðŸŽ‰'
        }
      ];
      
      const currentStep = steps[step];
      
      const next = () => {
        if (step < steps.length - 1) {
          setStep(step + 1);
        } else {
          saveJSON(TUTORIAL_KEY, true);
          onComplete();
        }
      };
      
      const skip = () => {
        saveJSON(TUTORIAL_KEY, true);
        onComplete();
      };
      
      return (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'rgba(0,0,0,0.85)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 9999,
          padding: '1rem'
        }}>
          <div className="card" style={{
            maxWidth: '500px',
            textAlign: 'center',
            animation: 'slideIn 0.4s ease'
          }}>
            <div style={{fontSize: '4rem', marginBottom: '1rem'}}>
              {currentStep.icon}
            </div>
            
            <h2 style={{marginBottom: '1rem'}}>{currentStep.title}</h2>
            
            <p style={{
              fontSize: '1.1rem',
              color: 'var(--ink-light)',
              marginBottom: '2rem',
              lineHeight: '1.6'
            }}>
              {currentStep.content}
            </p>
            
            <div style={{marginBottom: '1rem'}}>
              <ProgressBar
                current={step + 1}
                max={steps.length}
                label={`Step ${step + 1} of ${steps.length}`}
              />
            </div>
            
            <div style={{display: 'flex', gap: '0.5rem', justifyContent: 'center'}}>
              <button className="btn btn-secondary" onClick={skip}>
                Skip Tutorial
              </button>
              <button className="btn btn-primary btn-large" onClick={next}>
                {step < steps.length - 1 ? 'Next â†’' : 'Get Started! ðŸŽ»'}
              </button>
            </div>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // MAIN APP COMPONENT
    // ============================================================================
    
    function App() {
      const [prefs, setPrefs] = React.useState(() => loadJSON(PREFS_KEY, defaultPrefs));
      const [screen, setScreen] = React.useState('menu');
      const [xp, setXP] = React.useState(() => loadJSON(XP_KEY, 0));
      const [showTutorial, setShowTutorial] = React.useState(() => !loadJSON(TUTORIAL_KEY, false));
      const [achievementToShow, setAchievementToShow] = React.useState(null);
      const [toast, setToast] = React.useState(null);
      
      const level = levelForXP(xp);
      const nextXP = nextLevelXP(level);
      const currentLevelXP = level > 1 ? nextLevelXP(level - 1) : 0;
      const progressInLevel = xp - currentLevelXP;
      const xpNeeded = nextXP - currentLevelXP;
      const percentToNext = (progressInLevel / xpNeeded) * 100;
      
      const streak = React.useMemo(() => updateStreak(), []);
      
      // Refresh XP display
      React.useEffect(() => {
        const interval = setInterval(() => {
          const newXP = loadJSON(XP_KEY, 0);
          if (newXP !== xp) {
            setXP(newXP);
            
            const newLevel = levelForXP(newXP);
            if (newLevel > level) {
              setToast({ message: `ðŸŽ‰ Level ${newLevel} Reached!`, type: 'success' });
              audioEngine.playCelebration();
              vibrate([50, 100, 50, 100, 50]);
              speak(`Congratulations! You reached level ${newLevel}!`);
              
              if (newLevel >= 5 && checkAchievement('level_5')) {
                setTimeout(() => {
                  const ach = ACHIEVEMENTS.find(a => a.id === 'level_5');
                  setAchievementToShow(ach);
                }, 1000);
              }
              if (newLevel >= 10 && checkAchievement('level_10')) {
                setTimeout(() => {
                  const ach = ACHIEVEMENTS.find(a => a.id === 'level_10');
                  setAchievementToShow(ach);
                }, 1000);
              }
            }
          }
        }, 1000);
        
        return () => clearInterval(interval);
      }, [xp, level]);
      
      // Check for first note achievement
      React.useEffect(() => {
        checkAchievement('first_note');
      }, []);
      
      const menuItems = [
        { id: 'quest', label: 'Daily Quest', icon: 'ðŸ“…', desc: 'Interleaved practice for bonus XP' },
        { id: 'speed', label: 'Speed Drill', icon: 'âš¡', desc: 'Timed note identification practice' },
        { id: 'fingerboard', label: 'Fingerboard Quiz', icon: 'ðŸŽ¯', desc: 'Click notes on the interactive board' },
        { id: 'flash', label: 'Flashcards', icon: 'ðŸ—‚ï¸', desc: 'Spaced repetition learning' },
        { id: 'interval', label: 'Interval Training', icon: 'ðŸŽ¶', desc: 'Develop your musical ear' },
        { id: 'rhythm', label: 'Rhythm Trainer', icon: 'ðŸ¥', desc: 'Master rhythm patterns' },
        { id: 'bieler', label: 'Technique Lab', icon: 'ðŸ“š', desc: 'Violin technique concepts' },
        { id: 'positionRef', label: 'Positions Charts', icon: 'ðŸ“–', desc: 'Reference every note by position on all four strings.' },
        { id: 'reflection', label: 'Reflection Lab', icon: 'ðŸ“', desc: 'Journal your practice insights' },
        { id: 'progress', label: 'Progress', icon: 'ðŸ“Š', desc: 'View your stats & achievements' },
        { id: 'settings', label: 'Settings', icon: 'âš™ï¸', desc: 'Customize your experience' }
      ];
      
      if (showTutorial) {
        return <Tutorial onComplete={() => setShowTutorial(false)} />;
      }
      
      return (
        <div className="container">
          {achievementToShow && (
            <AchievementPopup
              achievement={achievementToShow}
              onClose={() => setAchievementToShow(null)}
            />
          )}
          
          {toast && (
            <Toast
              message={toast.message}
              type={toast.type}
              onClose={() => setToast(null)}
            />
          )}
          
          {screen === 'menu' && (
            <>
              <div className="card" style={{textAlign:'center', marginTop:'1rem'}}>
                <h1>ðŸŽ» Violin Mastery Quest</h1>
                <p style={{color:'var(--ink-light)', fontSize:'1.1rem', marginTop:'0.5rem'}}>
                  An adaptive learning experience
                </p>
                
                <div className="grid grid-cols-3" style={{marginTop:'1.5rem'}}>
                  <div className="stat-card card-compact">
                    <div className="stat-label">Level</div>
                    <div className="stat-value" style={{fontSize:'1.5rem'}}>{level}</div>
                  </div>
                  <div className="stat-card card-compact">
                    <div className="stat-label">XP</div>
                    <div className="stat-value" style={{fontSize:'1.5rem'}}>{xp.toLocaleString()}</div>
                  </div>
                  <div className="stat-card card-compact">
                    <div className="stat-label">Streak</div>
                    <div className="stat-value" style={{fontSize:'1.5rem'}}>
                      {streak.current > 0 && <span className="streak-fire">ðŸ”¥</span>}
                      {streak.current}
                    </div>
                  </div>
                </div>
                
                <ProgressBar
                  current={progressInLevel}
                  max={xpNeeded}
                  label={`${progressInLevel} / ${xpNeeded} XP to Level ${level + 1}`}
                />
              </div>
              
              <div className="card">
                <h2>ðŸŽ® Practice Modes</h2>
                <div className="grid grid-cols-2" style={{marginTop:'1rem'}}>
                  {menuItems.map(item => (
                    <button
                      key={item.id}
                      className="card card-compact"
                      onClick={() => setScreen(item.id)}
                      style={{
                        cursor: 'pointer',
                        border: '2px solid var(--border)',
                        textAlign: 'left',
                        transition: 'all 0.2s ease',
                        background: 'var(--card)'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.borderColor = 'var(--primary)';
                        e.currentTarget.style.transform = 'translateY(-4px)';
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.borderColor = 'var(--border)';
                        e.currentTarget.style.transform = 'translateY(0)';
                      }}
                    >
                      <div style={{fontSize:'2rem', marginBottom:'0.5rem'}}>{item.icon}</div>
                      <h3 style={{margin:'0 0 0.25rem 0', color:'var(--ink)'}}>{item.label}</h3>
                      <p style={{margin:0, fontSize:'0.9rem', color:'var(--ink-light)'}}>
                        {item.desc}
                      </p>
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{textAlign:'center', padding:'1rem', color:'var(--ink-light)'}}>
                <small>
                  ðŸ’¡ Tip: Practice daily to maintain your streak!
                  {streak.current > 0 && ` You're on day ${streak.current}!`}
                </small>
              </div>
            </>
          )}
          
          {screen === 'speed' && (
            <SpeedDrill prefs={prefs} onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'flash' && (
            <Flashcards prefs={prefs} onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'interval' && (
            <IntervalTraining onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'rhythm' && (
            <RhythmTrainer onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'bieler' && (
            <BielerLab onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'reflection' && (
            <PracticeReflectionJournal
              currentModule={screen}
              onBack={() => setScreen('menu')}
            />
          )}

          {screen === 'fingerboard' && (
            <FingerboardQuiz prefs={prefs} onBack={() => setScreen('menu')} />
          )}

          {screen === 'quest' && (
            <DailyQuest prefs={prefs} onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'positionRef' && (
            <PositionReference onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'progress' && (
            <ProgressScreen onBack={() => setScreen('menu')} />
          )}
      
          {screen === 'settings' && (
            <Settings
              prefs={prefs}
              setPrefs={setPrefs}
              onBack={() => setScreen('menu')}
            />
          )}
        </div>
      );
    }
    
    // ============================================================================
    // ============================================================================
    // RENDER (with safety checks)
    // ============================================================================
    
    (function () {
      const container = document.getElementById('root');
    
      if (!container) {
        console.error('Violin Mastery Quest: #root container not found.');
        const fallback = document.createElement('div');
        fallback.textContent =
          'Error: #root container not found. Check the HTML structure.';
        document.body.appendChild(fallback);
        return;
      }
    
      if (!window.React || !window.ReactDOM) {
        console.error('Violin Mastery Quest: React or ReactDOM not loaded.');
        container.innerHTML =
          '<p style="padding:1rem;color:#b91c1c;">Error: React/ReactDOM failed to load. Check your script tags and network.</p>';
        return;
      }
    
      if (typeof ReactDOM.createRoot !== 'function') {
        console.error(
          'Violin Mastery Quest: ReactDOM.createRoot is not available. You may have the wrong ReactDOM version.'
        );
        container.innerHTML =
          '<p style="padding:1rem;color:#b91c1c;">Error: This app expects React 18 (createRoot). Make sure the ReactDOM script is @18.</p>';
        return;
      }
    
      try {
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
      } catch (err) {
        console.error('Violin Mastery Quest: error while rendering App:', err);
        container.innerHTML =
          '<p style="padding:1rem;color:#b91c1c;">An unexpected error occurred while starting the app. Check the JavaScript console for details.</p>';
      }
    })();
  </script>
</body>
</html>