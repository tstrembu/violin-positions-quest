<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Mastery Quest</title>

  <!-- Responsive layout & dark-mode support -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />

  <!-- Short description for sharing -->
  <meta name="description" content="Master violin positions, notes, theory and technique with evidenceâ€‘based drills and games." />

  <!-- Base styles: modern look with light/dark variables -->
  <style>
    :root {
      --bg: #f6f7fb;
      --card: #fff;
      --ink-900: #0b1220;
      --ink-700: #374151;
      --ink-600: #6b7280;
      --accent: #6d28d9;
      --shadow: 0 8px 20px rgba(0,0,0,.08);
      --hairline: rgba(0,0,0,.12);
      --gridline: rgba(0,0,0,.2);
    }
    :root.dark {
      --bg:#0b1020;
      --card:#0f172a;
      --ink-900:#e5e7eb;
      --ink-700:#cbd5e1;
      --ink-600:#94a3b8;
      --accent:#a78bfa;
      --shadow:0 14px 28px rgba(0,0,0,.34);
      --hairline: rgba(255,255,255,.14);
      --gridline: rgba(255,255,255,.2);
    }
    html,body { height: 100%; margin:0; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink-900);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .card {
      background: var(--card);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 1rem;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.6rem 1rem;
      border-radius: 9999px;
      color: white;
      font-weight: bold;
      text-decoration: none;
      cursor: pointer;
      user-select: none;
      transition: transform 0.1s;
    }
    .btn:active { transform: scale(0.98); }
    .btn-primary { background: var(--accent); }
    .btn-gray { background: #4b5563; }
    .btn-green { background: #10b981; }
    .container { max-width: 860px; margin:auto; padding: 1rem; }
    h1,h2 { margin: 0 0 0.5rem 0; }
    h1 { font-size: 1.8rem; }
    h2 { font-size: 1.4rem; margin-top:1rem; }
    .grid { display: grid; gap: 1rem; }
    @media(min-width: 640px){ .grid-cols-2 { grid-template-columns: repeat(2, 1fr);} }
    @media(min-width: 1024px){ .grid-cols-3 { grid-template-columns: repeat(3, 1fr);} }
    /* Badge for progress */
    .badge { font-size: 0.8rem; padding: 0.1rem 0.5rem; border-radius: 6px; background: var(--accent); color:#fff; }
    /* Heatmap style for stats grid */
    .heat-tile {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding: 0.5rem;
      border-radius:6px;
      height:3rem;
      position:relative;
    }
    .heat-dot { position:absolute; top:4px; right:4px; width:6px; height:6px; border-radius:50%; background:#9ca3af; }
  </style>

  <!-- React & Babel via CDN -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    // Evidence-based helpers
    // These functions implement spaced repetition and retrieval practice basics. For simplicity, spaced repetition uses
    // exponential review intervals and retrieval practice uses repeated testing in drills.

    // Save and load JSON safely
    const saveJSON = (key, value) => {
      try { localStorage.setItem(key, JSON.stringify(value)); } catch {};
    };
    const loadJSON = (key, fallback = {}) => {
      try { const v = JSON.parse(localStorage.getItem(key)); return v ?? fallback; } catch { return fallback; };
    };

    // Gamification: convert XP to level (superlinear growth) and next level requirement
    const levelForXP = xp => Math.floor(Math.pow(xp/120, 0.75)) + 1;
    const nextLevelXP = lvl => Math.round(120 * Math.pow(lvl, 1.33));

    // Weighted random selection: used to pick weaker notes for drills (retrieval practice on weakest items)
    function pickWeighted(items, weightFn){
      if(!items.length) return null;
      const weights = items.map(weightFn);
      const total = weights.reduce((a,b)=>a+b,0);
      let r = Math.random() * total;
      for(let i=0;i<items.length;i++){ r -= weights[i]; if(r <= 0) return items[i]; }
      return items[items.length-1];
    }

    // Wilson lower bound for accuracy (confidence interval) to drive adaptive weighting
    const wilsonLB = (c,t,z=1.96) => {
      if(!t) return 0;
      const p = c/t;
      const denom = 1 + z*z/t;
      const centre = p + z*z/(2*t);
      const adj = z * Math.sqrt((p*(1-p)+z*z/(4*t))/t);
      return Math.max(0, (centre - adj)/denom);
    };

    // Components and app logic
    const STRINGS=['G','D','A','E'];
    const POSITIONS=[1,2,3,4,5];
    const FINGERS=[1,2,3,4];

    // Build model of fingerboard: base note per cell using semitone math
    const OPEN_PC={G:7,D:2,A:9,E:4};
    const BASE_OFF={1:2,2:4,3:5,4:7};
    const POS_SHIFT={1:0,2:2,3:3,4:5,5:7};
    const pc = n => ((n % 12)+12)%12;
    const names=(k)=>{
      const arr = {
        0:['C'],1:['C#','Db'],2:['D'],3:['D#','Eb'],4:['E'],5:['F'],6:['F#','Gb'],7:['G'],8:['G#','Ab'],9:['A'],10:['A#','Bb'],11:['B']
      };
      return arr[pc(k)];
    };
    const baseNamesFor=(s,p,f)=>{
      const k = OPEN_PC[s] + POS_SHIFT[p] + BASE_OFF[f];
      return names(k);
    };
    const CANON_NAME={0:'C',1:'Db',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};

    // Build valid cells and notes list
    const buildCells = () => {
      const cells=[];
      for(const s of STRINGS) for(const p of POSITIONS) for(const f of FINGERS){
        // base names (for reference)
        const bname = baseNamesFor(s,p,f);
        // build canonical base (first element of names set) as label
        const canon = CANON_NAME[pc(baseNamesFor(s,p,f)[0])];
        cells.push({s,p,f,canon});
      }
      return cells;
    };
    const CELLS=buildCells();

    // Stats keys
    const STATS_KEY='violinQuest.stats';
    const XP_KEY='violinQuest.xp';

    // Drills: Speed Ladder simplified (only base notes). Weighted selection on weaker stats.
    function SpeedDrill({onBack}){
      const [stats,setStats] = React.useState(loadJSON(STATS_KEY, {}));
      const [cell,setCell] = React.useState(null);
      const [options,setOptions] = React.useState([]);
      const [time,setTime]=React.useState(60);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);

      // Build weighting: 1 - Wilson lower bound encourages weaker items
      const cellWeight = key => {
        const st = stats[key] || {correct:0,total:0};
        const lb = wilsonLB(st.correct, st.total);
        return 1 - lb + 0.1; // constant to avoid zero
      };

      // Pick a new cell
      const pickCell = () => {
        const chosen = pickWeighted(CELLS, c => cellWeight(`${c.s}:${c.p}:${c.f}`));
        // correct answer canonical
        const correct = chosen.canon;
        // distractors
        const allCanon = [...new Set(CELLS.map(c=>c.canon))];
        const distract = allCanon.filter(n=>n!==correct);
        const randDistr = shuffleArray(distract).slice(0,3);
        const opts = shuffleArray([correct,...randDistr]);
        setCell(chosen);
        setOptions(opts);
      };

      // On mount: start timer and pick first
      React.useEffect(()=>{
        pickCell();
        const id = setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[]);

      // Save stats & XP after each answer
      const updateStats=(key,correct)=>{
        const st = stats[key] || {correct:0,total:0};
        const next = {...stats, [key]:{correct: st.correct + (correct?1:0), total: st.total+1}};
        setStats(next);
        saveJSON(STATS_KEY,next);
        // XP
        const xp = loadJSON(XP_KEY,0);
        const gain = correct?10:2;
        const newXP = xp + gain;
        saveJSON(XP_KEY, newXP);
      };

      // Answer selection
      const answer = opt => {
        if(!cell) return;
        const ok = opt===cell.canon;
        setAnswered(a=>a+1);
        if(ok) setScore(s=>s+1);
        updateStats(`${cell.s}:${cell.p}:${cell.f}`, ok);
        pickCell();
      };

      if(time===0){
        // show results
        return (
          <div className="card">
            <h2>Drill Complete</h2>
            <p>Score: {score} / {answered}</p>
            <button className="btn btn-primary" onClick={()=>onBack()}>Back to Home</button>
          </div>
        );
      }

      return (
        <div>
          <div className="card" style={{marginBottom:'1rem'}}>
            <h2>Speed Drill (Base Notes)</h2>
            <p>Time: {time}s | Score: {score}/{answered}</p>
            {cell && (
              <div style={{textAlign:'center'}}>
                <p>What is the base note at <strong>{ordinal(cell.p)} Position</strong>, <strong>{ordinal(cell.f)} finger</strong> on <strong>{cell.s} string</strong>?</p>
                <div className="grid grid-cols-2" style={{gap:'0.5rem'}}>
                  {options.map(opt=>(<button key={opt} className="btn btn-blue" onClick={()=>answer(opt)}>{opt}</button>))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-gray" onClick={()=>onBack()}>Back</button>
        </div>
      );
    }

    // Simple flashcards with spaced repetition scheduling. Each card knows its next review time.
    function Flashcards({onBack}){
      const [cards,setCards] = React.useState(()=>{
        const saved = loadJSON('violinQuest.flashcards', null);
        if(saved) return saved;
        // build initial deck: one card per unique note and one per cell
        const deck=[];
        for(const c of CELLS){ deck.push({type:'cell',question:`Note at ${ordinal(c.p)} Pos, ${ordinal(c.f)} finger on ${c.s}`, answer:c.canon, interval:1, due:Date.now()}); }
        const uniqueNotes=[...new Set(CELLS.map(c=>c.canon))];
        for(const n of uniqueNotes){ deck.push({type:'note',question:`Where can you play ${n}?`, answer: n, interval:1, due:Date.now()}); }
        saveJSON('violinQuest.flashcards', deck);
        return deck;
      });
      const [card,setCard]=React.useState(null);
      const [revealed,setRevealed]=React.useState(false);

      // pick next due card (spaced repetition). If none, pick random.
      const pickCard = () => {
        const now=Date.now();
        const dueCards = cards.filter(c=>c.due<=now);
        const next = dueCards.length? dueCards[0] : getRandom(cards);
        setCard(next);
        setRevealed(false);
      };

      React.useEffect(()=>{ pickCard(); },[]);

      // Mark correct: increase interval and schedule next review
      const markCorrect=()=>{
        const updated=cards.map(c=>{
          if(c===card){
            const newInterval = c.interval * 2;
            const due=Date.now()+newInterval*24*60*60*1000; // days in ms
            return {...c, interval:newInterval, due};
          }
          return c;
        });
        setCards(updated);
        saveJSON('violinQuest.flashcards', updated);
        pickCard();
      };
      const markIncorrect=()=>{
        const updated=cards.map(c=>{
          if(c===card){ return {...c, interval:1, due: Date.now()+24*60*60*1000}; }
          return c;
        });
        setCards(updated);
        saveJSON('violinQuest.flashcards', updated);
        pickCard();
      };

      return (
        <div>
          <div className="card">
            <h2>Flashcards</h2>
            {card && (
              <div style={{textAlign:'center'}}>
                <p>{card.question}</p>
                {revealed ? (<p style={{fontWeight:'bold',fontSize:'1.5rem'}}>{card.answer}</p>) : (<button className="btn btn-primary" onClick={()=>setRevealed(true)}>Reveal</button>)}
                {revealed && (
                  <div style={{marginTop:'1rem'}}>
                    <button className="btn btn-green" onClick={markCorrect}>I knew it</button>
                    <button className="btn btn-gray" onClick={markIncorrect}>I forgot</button>
                  </div>
                )}
              </div>
            )}
          </div>
          <button className="btn btn-gray" style={{marginTop:'1rem'}} onClick={()=>onBack()}>Back</button>
        </div>
      );
    }

    // Stats page: show heatmap of accuracy per cell and progress (level)
    function Stats(){
      const stats=loadJSON(STATS_KEY, {});
      const xp=loadJSON(XP_KEY,0);
      const level=levelForXP(xp);
      const nextXP=nextLevelXP(level);
      const prevXP=level>1?nextLevelXP(level-1):0;
      const progress=(xp-prevXP)/(nextXP-prevXP);

      return (
        <div>
          <div className="card">
            <h2>Your Progress</h2>
            <p>Level {level} (XP {xp-prevXP}/{nextXP-prevXP})</p>
            <div style={{background:'#e5e7eb', borderRadius:'6px', overflow:'hidden', height:'8px'}}>
              <div style={{height:'8px', width:`${progress*100}%`, background: 'var(--accent)'}}></div>
            </div>
          </div>
          <div className="card" style={{marginTop:'1rem'}}>
            <h2>Fingerboard Accuracy</h2>
            <div className="grid" style={{gridTemplateColumns:'repeat(4, 1fr)', gap:'0.5rem'}}>
              {CELLS.map(c=>{
                const key=`${c.s}:${c.p}:${c.f}`;
                const st=stats[key]||{correct:0,total:0};
                const acc = st.total? st.correct/st.total : 0;
                const color = acc<0.5? 'rgba(239,68,68,0.5)' : acc<0.8? 'rgba(234,179,8,0.5)' : 'rgba(16,185,129,0.5)';
                return (
                  <div key={key} className="heat-tile" style={{background:color}} title={`Pos ${c.p}, F${c.f} on ${c.s}: ${st.correct}/${st.total}` }>
                    {st.total? `${Math.round(acc*100)}%` : '-'}
                    {st.total<3 && <span className="heat-dot"></span>}
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      );
    }

    // Home component: menu & router
    function App(){
      const [page,setPage]=React.useState('home');
      const open = (p) => setPage(p);
      return (
        <div className="container">
          {page==='home' && (
            <div>
              <h1>Violin Mastery Quest</h1>
              <p className="muted">Practice violin positions, notes and techniques with drills built on evidenceâ€‘based learning: retrieval practice, spaced repetition and adaptive feedback.</p>
              <div className="grid grid-cols-2">
                <div className="card">
                  <h2>Drills</h2>
                  <button className="btn btn-primary" style={{marginBottom:'0.5rem'}} onClick={()=>open('drill')}>Speed Drill</button>
                  <button className="btn btn-primary" style={{marginBottom:'0.5rem'}} onClick={()=>open('flash')}>Flashcards</button>
                </div>
                <div className="card">
                  <h2>Stats</h2>
                  <button className="btn btn-primary" onClick={()=>open('stats')}>View Stats</button>
                </div>
              </div>
            </div>
          )}
          {page==='drill' && <SpeedDrill onBack={()=>open('home')}/>}
          {page==='flash' && <Flashcards onBack={()=>open('home')}/>}
          {page==='stats' && <div><Stats/><button className="btn btn-gray" style={{marginTop:'1rem'}} onClick={()=>open('home')}>Back</button></div>}
        </div>
      );
    }

    // Helper: shuffle array
    function shuffleArray(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    // Helper: ordinal suffix
    function ordinal(n){ const s=['th','st','nd','rd'], v=n%100; return n + (s[(v-20)%10]||s[v]||s[0]); }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>