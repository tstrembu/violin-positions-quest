<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Positions Quest</title>

  <!-- Viewport & Theme -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#6d28d9" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="VPQ" />

  <!-- PWA manifest & icons (GitHub Pages path) -->
  <link rel="manifest" href="/violin-positions-quest/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/violin-positions-quest/icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/violin-positions-quest/icons/icon-192.png" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- Base styles -->
  <style>
    :root {
      --bg: #f3f4f6;
      --card: #ffffff;
      --ink-900: #111827;
      --ink-800: #1f2937;
      --ink-700: #374151;
      --ink-600: #4b5563;
      --ink-500: #6b7280;
      --shadow: 0 10px 20px rgba(0,0,0,0.08);
      --accent: #6d28d9; /* theme accent */
    }
    body.dark {
      --bg: #0b1020;
      --card: #0f172a;
      --ink-900: #e5e7eb;
      --ink-800: #e2e8f0;
      --ink-700: #cbd5e1;
      --ink-600: #94a3b8;
      --ink-500: #64748b;
      --shadow: 0 12px 24px rgba(0,0,0,0.35);
    }
    /* NEW: dark-aware subtle surfaces & lines */
    :root{
      --surface-subtle: rgba(0,0,0,.04);   /* soft panel headers, subtle fills */
      --hairline:       rgba(0,0,0,.12);   /* borders, dividers */
      --gridline:       rgba(0,0,0,.20);   /* SVG guidelines */
    }
    body.dark{
      --surface-subtle: rgba(255,255,255,.06);
      --hairline:       rgba(255,255,255,.14);
      --gridline:       rgba(255,255,255,.16);
    }

    /* Make Tailwind's generic borders readable in dark */
    body.dark .border, body.dark .border-2 { border-color: var(--hairline) !important; }
    html, body { height:100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink-900);
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji';
    }
    .card { background: var(--card); box-shadow: var(--shadow); }
    .muted { color: var(--ink-600); }
    .ink700 { color: var(--ink-700); }
    .ink800 { color: var(--ink-800); }
    .linkish { text-decoration: underline; cursor: pointer; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { width:min(680px, 92vw); }
    .pill { border-radius: 9999px; padding: 4px 10px; display:inline-block; font-size:12px; }
    .badge { background:var(--accent); color:white; border-radius:9999px; padding:.25rem .6rem; font-weight:700; font-size:12px; }
    .help-dot { width: 22px; height: 22px; border-radius: 9999px; display:inline-flex; align-items:center; justify-content:center; background: var(--surface-subtle); color:var(--accent); font-weight:700; }
    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; z-index: 9998; }
    .btn {
      display:inline-flex; align-items:center; justify-content:center;
      padding: .75rem 1.25rem; border-radius: 9999px; color:white; font-weight:700;
      transition: transform .08s ease;
    }
    .btn:active { transform: scale(.98); }
    .btn-purple { background:var(--accent); }
    .btn-blue { background:#2563eb; }
    .btn-green { background:#059669; }
    .btn-gray { background:#4b5563; }
    .btn-rose { background:#e11d48; }
    .btn-amber { background:#d97706; }
    .grid-cards { display:grid; gap: 24px; grid-template-columns: repeat(1, minmax(0,1fr)); }
    @media(min-width:640px){ .grid-cards{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media(min-width:1024px){ .grid-cards{ grid-template-columns: repeat(3, minmax(0,1fr)); } }

    /* micro-animations for answers */
    @keyframes pulseCorrect { from{transform:scale(1)} 50%{transform:scale(1.03)} to{transform:scale(1)} }
    @keyframes pulseWrong   { from{transform:scale(1)} 50%{transform:scale(0.97)} to{transform:scale(1)} }
    .btn-hit.ok   { animation:pulseCorrect .25s ease; box-shadow:0 0 0 3px rgba(16,185,129,.25); }
    .btn-hit.miss { animation:pulseWrong   .25s ease; box-shadow:0 0 0 3px rgba(239,68,68,.25); }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }

    /* A11y live region */
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}
    *, *::before, *::after { box-sizing: border-box; }

    /* ---- Fingerboard heatmap layout (fixed overlap) ---- */
    :root{
      --posw: clamp(160px, 45%, 220px);
    }
    .fb-strip{
      display:flex;
      gap:12px;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      padding-bottom:6px;
      scroll-snap-type:x mandatory;
    }
    .fb-pos{
      flex: 0 0 var(--posw);
      min-width: var(--posw);
      scroll-snap-align: start;
      overflow:hidden;
    }
    .fb-grid{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:6px;
    }
    /* Make the grid clear space for the chip automatically */
    .fb-pos .fb-grid{ 
      padding-top: calc(8px + var(--pos-chip-clear)); /* 8px comes from your p-2 */
    }
    /* Chip styling (dark-aware tokens) */
    .pos-chip{
      position:absolute; top:6px; left:6px;
      padding:2px 6px; border-radius:6px; font-size:11px; line-height:1;
      background: var(--surface-subtle);
      color: var(--ink-800);
      border: 1px solid var(--hairline);
    }
    .fb-tile{
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      line-height: 1.1;
      aspect-ratio: 1 / 1.15;
      padding: 6px 4px;
      min-width: 0;
    }
    .fb-band{
      position: absolute;
      left: 6px; right: 6px; bottom: 6px;
      height: 10px; border-radius: 6px;
    }
    /* dual bands: top = Accuracy, bottom = Confidence (LB) */
    .fb-band--acc { bottom: 16px; height: 6px; border-radius: 6px; }
    .fb-band--lb  { bottom: 6px;  height: 6px; border-radius: 6px; }
    @media (min-width: 1024px){
      .fb-strip{
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 12px;
        overflow: visible;
      }
      .fb-pos{ flex: initial; min-width: 0; }
    }
    @supports not (aspect-ratio: 1){
      .fb-tile { height: 72px; }
    }
    @media (min-width: 768px) and (max-width: 1023px){
      .fb-strip{ flex-wrap: wrap; }
      .fb-pos{ flex: 1 1 calc(50% - 12px); min-width: 0; }
    }

    /* Avatar (simple layered SVG) */
    .avatar { width:56px; height:56px; border-radius:12px; overflow:hidden; border:2px solid rgba(0,0,0,.08); }
    .avatar-wrap { display:flex; align-items:center; gap:10px; }
    .avatar-label { font-size:12px; color:var(--ink-600); }

    /* XP bar */
    .xpbar { height:10px; border-radius:9999px; background:rgba(0,0,0,.1); overflow:hidden; }
    .xpbar-fill { height:100%; background:var(--accent); }
    
    .fb-pos{
      flex: 0 0 var(--posw);
      min-width: var(--posw);
      scroll-snap-align: start;
      overflow:hidden;
      /* ADD these two lines ‚Üì */
      position: relative;
      --pos-chip-clear: 18px; /* reserved space for the Pos chip */
    }
    
    /* Small position label that respects light/dark tokens */
    .pos-chip{
      position:absolute; top:6px; left:6px;
      padding:2px 6px; border-radius:6px; font-size:11px; font-weight:600;
      background: var(--surface-subtle);
      color: var(--ink-800);
      border: 1px solid var(--hairline);
    }
  </style>

  <!-- Tailwind (utility helpers only) -->
  <!-- Tailwind CDN (config first, then script) -->
  <script>
    window.tailwind = window.tailwind || {};
    window.tailwind.config = {
      darkMode: 'class',
      theme: { extend: { fontFamily: { inter: ['Inter','ui-sans-serif','system-ui'] } } }
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/violin-positions-quest/sw.js').catch(()=>{});
      });
    }
  </script>
  
  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <!-- A11y live region -->
  <div id="sr" aria-live="polite" class="sr-only"></div>

  <!-- App -->
  <script type="text/babel" data-presets="react,env">
    const { useState, useEffect, useMemo, useRef } = React;

    /* =========================================================
       Storage keys
    ========================================================== */
    const THEME_KEY = 'vpq.theme.v1';                   // light | dark
    const THEME_ACCENT_KEY = 'vpq.themeAccent.v1';      // symphony | rockstar | fantasy | lofi
    const BEST_KEY = 'positionsQuest.speed.best';
    const STATS_KEY = 'positionsQuest.speed.stats';
    const PREFS_KEY = 'positionsQuest.prefs';
    const PRESETS_KEY = 'positionsQuest.filterPresets.v1';
    const SESSIONLOG_KEY = 'positionsQuest.sessions.v1';
    const SCORE_KEY = 'positions.scoreboard.v1';
    const BADGES_KEY = 'positions.badges.v1';
    const STREAK_KEY = 'positions.streak.v1';
    const COSMETICS_KEY = 'positions.cosmetics.v1';
    const SM2_KEY = 'sm2.v1';

    const SEYBOLD_KEY = 'seybold.hub.v1';
    const TEMPO_STATS_KEY = 'positionsQuest.tempo.stats.v1';
    const TEMPO_BEST_KEY  = 'positionsQuest.tempo.best.v1';

    // NEW stats keys for added modes
    const HEIGHT_STATS_KEY  = 'positionsQuest.height.stats.v1';
    const LOCATOR_STATS_KEY = 'positionsQuest.locator.stats.v1';
    const SHIFT_STATS_KEY   = 'positionsQuest.shift.stats.v1';
    const HARM_STATS_KEY    = 'positionsQuest.harmonics.stats.v1';

    /* =========================================================
       Theme
    ========================================================== */
    const getTheme = () => (localStorage.getItem(THEME_KEY) || 'light');
    const setTheme = (t) => { localStorage.setItem(THEME_KEY, t); document.body.classList.toggle('dark', t === 'dark'); };
    (function bootTheme(){ setTheme(getTheme()); })();

    const THEMES = {
      symphony: { '--accent':'#6d28d9' },
      rockstar: { '--accent':'#e11d48' },
      fantasy:  { '--accent':'#22d3ee' },
      lofi:     { '--accent':'#10b981' }
    };
    const getAccent = () => localStorage.getItem(THEME_ACCENT_KEY) || 'symphony';
    const applyAccent = (name) => {
      const t = THEMES[name] || THEMES.symphony;
      Object.entries(t).forEach(([k,v])=>document.documentElement.style.setProperty(k, v));
      localStorage.setItem(THEME_ACCENT_KEY, name);
    };
    applyAccent(getAccent());

    /* =========================================================
       Utilities
    ========================================================== */
    const shuffle = (arr) => { const a = [...arr]; for (let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };
    const getRandomItem = (arr) => arr[Math.floor(Math.random()*arr.length)];
    const nowISO = () => new Date().toISOString();

    // ASCII accidental normalizer for display
    const NORM = {'A‚ô≠':'Ab','B‚ô≠':'Bb','E‚ô≠':'Eb','D‚ô≠':'Db','G‚ô≠':'Gb','C‚ô≠':'Cb','C‚ôØ':'C#','D‚ôØ':'D#','F‚ôØ':'F#','G‚ôØ':'G#','A‚ôØ':'A#'};
    const norm = n => NORM[n] || n;
    
    // Pitch-class (enharmonic) helpers
    const PC = { C:0,'C#':1,Db:1, D:2,'D#':3,Eb:3, E:4, F:5,'F#':6,Gb:6, G:7,'G#':8,Ab:8, A:9,'A#':10,Bb:10, B:11 };
    const pc = n => PC[(NORM[n] || n)]  // collapse D# and Eb, etc.
    
    // Label helpers
    const ordinal = n => { const x = Number(n);
      const suf = (x%10===1 && x%100!==11) ? 'st'
               : (x%10===2 && x%100!==12) ? 'nd'
               : (x%10===3 && x%100!==13) ? 'rd' : 'th';
      return `${x}${suf}`;
    };
    const posLabel    = p => `${ordinal(p)} Position`;
    const fingerLabel = f => `${ordinal(f)} Finger`;
    const stringLabel = s => `${s} string`;
    const fullLoc     = (s,p,f,withString=true) =>
      withString ? `${posLabel(p)}, ${fingerLabel(f)} on the ${stringLabel(s)}`
                 : `${posLabel(p)}, ${fingerLabel(f)}`;

    /* =========================================================
       Core enums (MUST be defined before use)
    ========================================================== */
    const STRINGS   = ['G','D','A','E'];
    const POSITIONS = [1,2,3,4,5];
    const FINGERS   = [1,2,3,4];

    /* =========================================================
       Fingerboard Data ‚Äî generated from semitone math
       (replaces the hand-typed NOTES_DATA object)
    ========================================================== */
    
    // 0=C ... 11=B; include both spellings where they exist
    const SEMI_TO_NAMES = {
      0:['C'],  1:['C#','Db'], 2:['D'], 3:['D#','Eb'],
      4:['E'],  5:['F'],       6:['F#','Gb'], 7:['G'],
      8:['G#','Ab'], 9:['A'], 10:['A#','Bb'], 11:['B']
    };
    
    // open-string pitch classes (C=0) for G D A E
    const OPEN_PC = { G:7, D:2, A:9, E:4 };
    
    // within each position, the ‚Äúbase‚Äù (natural) offsets for fingers 1‚Äì4
    const BASE_OFF = { 1:2, 2:4, 3:5, 4:7 };
 
    // position offsets measured in semitones from 1st position
    // 1‚Üí0, 2‚Üí+2, 3‚Üí+3, 4‚Üí+5, 5‚Üí+7
    const POS_SHIFT = { 1:0, 2:2, 3:3, 4:5, 5:7 };
    
    const wrap12 = n => ((n % 12) + 12) % 12;
    const names   = k => SEMI_TO_NAMES[wrap12(k)];
    const flatFirst  = a => (a.length===2 ? [a[1], a[0]] : a);  // e.g. ['Db','C#']
    const sharpFirst = a => (a.length===2 ? [a[0], a[1]] : a);  // e.g. ['C#','Db']
    
		// Normalize Unicode accidentals to ASCII and map all common enharmonics to pitch classes.
		const NORM = {
		  'A‚ô≠':'Ab','B‚ô≠':'Bb','E‚ô≠':'Eb','D‚ô≠':'Db','G‚ô≠':'Gb','C‚ô≠':'Cb','F‚ô≠':'Fb',
		  'C‚ôØ':'C#','D‚ôØ':'D#','F‚ôØ':'F#','G‚ôØ':'G#','A‚ôØ':'A#','E‚ôØ':'E#','B‚ôØ':'B#'
		};
		
		const PC = {
		   C:0, 'B#':0,
		  'C#':1, Db:1,
		   D:2,
		  'D#':3, Eb:3,
		   E:4, Fb:4,
		   F:5, 'E#':5,
		  'F#':6, Gb:6,
		   G:7,
		  'G#':8, Ab:8,
		   A:9,
		  'A#':10, Bb:10,
		   B:11, Cb:11
		};
		
		// Convert a note name (e.g., 'D‚ôØ', 'Eb', 'Cb') to pitch class (0‚Äì11)
		const pc = (n) => {
		  const k = NORM[n] || n;
		  const v = PC[k];
		  if (v === undefined) throw new Error(`Unknown note: ${String(n)}`);
		  return v;
		};
    
    function buildNotesData() {
      const data = {};
      for (const s of STRINGS) {
        data[s] = {};
        for (let p = 1; p <= 5; p++) {
          data[s][p] = {};
          for (const f of FINGERS) {
            const basePC = OPEN_PC[s] + POS_SHIFT[p] + BASE_OFF[f];
            if (f === 1 || f === 2) {
              // low (flat) + base
              data[s][p][f] = [...flatFirst(names(basePC-1)), ...names(basePC)];
            } else if (f === 3) {
              // base + high (sharp)
              data[s][p][3] = [...names(basePC), ...sharpFirst(names(basePC+1))];
            } else { // finger 4 varies by position per posters
              if (p === 1) {
                data[s][p][4] = [...names(basePC)];                       // natural only
              } else if (p === 2) {
                data[s][p][4] = [...flatFirst(names(basePC-1)), ...names(basePC)]; // low-4
              } else {
                data[s][p][4] = [...names(basePC), ...sharpFirst(names(basePC+1))]; // high-4
              }
            }
          }
        }
      }
      return data;
    }
    
    const NOTES_DATA = buildNotesData();
    
    // ---- Base-only helpers (natural/base note for each cell) ----
    const baseNamesFor = (s,p,f) => {
      const pc0 = OPEN_PC[s] + POS_SHIFT[p] + BASE_OFF[f];
      return names(pc0); // may return one or two spellings (e.g., ['C#','Db'])
    };
    
    const ALL_BASE_UNIQUE = (() => {
      const set = new Set();
      STRINGS.forEach(s => POSITIONS.forEach(p => FINGERS.forEach(f => {
        baseNamesFor(s,p,f).forEach(n => set.add(n));
      })));
      return [...set];
    })();
    
    function getDistractorsFromPool(correct, pool, forbidPCs = [], count = 3){
      const banned = new Set([pc(correct), ...forbidPCs]);
      const picks = [];
      const seen = new Set();
      const filtered = pool.filter(n => !banned.has(pc(n)));
      while (picks.length < Math.min(count, filtered.length)) {
        const cand = getRandomItem(filtered);
        const cls = pc(cand);
        if (!seen.has(cls)) { seen.add(cls); picks.push(cand); }
      }
      return picks;
    }
    
    // Quick data sanity check against a few poster anchor points
    (function selfTest(){
      const MUST = {
        'G:1:1':'A','G:1:2':'B','G:1:3':'C','G:1:4':'D',
        'D:1:1':'E','D:1:2':'F#','D:1:3':'G','D:1:4':'A',
        'A:1:1':'B','A:1:2':'C#','A:1:3':'D','A:1:4':'E',
        'E:1:1':'F#','E:1:2':'G#','E:1:3':'A','E:1:4':'B',
        // spot checks in higher positions that often get mistyped:
        'G:2:2':'C#', 'G:2:3':'D',
        'G:3:4':'F',          // fixed
        'A:4:1':'E',          // fixed
        'E:3:4':'D',          // new guard
        'G:3:1':'C'           // new guard
      };
      const ASCII = {'A‚ô≠':'Ab','B‚ô≠':'Bb','E‚ô≠':'Eb','D‚ô≠':'Db','G‚ô≠':'Gb','C‚ô≠':'Cb',
                     'C‚ôØ':'C#','D‚ôØ':'D#','F‚ôØ':'F#','G‚ôØ':'G#','A‚ôØ':'A#'};
      const bad=[];
      for (const k in MUST){
        const [s,p,f]=k.split(':');
        const cell = (NOTES_DATA[s] && NOTES_DATA[s][p] && NOTES_DATA[s][p][f]) || [];
        const ascii = cell.map(n=>ASCII[n]||n);
        if (!ascii.includes(MUST[k])) bad.push(`${k} expected ${MUST[k]} got [${ascii.join(', ')}]`);
      }
      if (bad.length) console.warn('Fingerboard data mismatches:', bad);
      else console.info('Fingerboard data ‚úì matches poster spec.');
    })();

    // Low/High helper
    function fingerHeight(note, options){
      if (!Array.isArray(options) || options.length <= 1) return 'natural';
      const low  = options[0];
      const high = options[options.length - 1];
      const k = pc(note);
      if (k === pc(low))  return 'low';
      if (k === pc(high)) return 'high';
      return 'natural';
    }

    // Simple harmonics set per string
    const HARMONICS = {
      G: { '1/2':['G','octave'], '1/3':['D','oct+5th'], '1/4':['G','2 oct'] },
      D: { '1/2':['D','octave'], '1/3':['A','oct+5th'], '1/4':['D','2 oct'] },
      A: { '1/2':['A','octave'], '1/3':['E','oct+5th'], '1/4':['A','2 oct'] },
      E: { '1/2':['E','octave'], '1/3':['B','oct+5th'], '1/4':['E','2 oct'] },
    };

    // Unique note list
    const ALL_NOTES_UNIQUE = (() => {
      const set = new Set();
      STRINGS.forEach(s => POSITIONS.forEach(p => FINGERS.forEach(f => {
        const cell = NOTES_DATA[s]?.[p]?.[f];
        if (Array.isArray(cell)) cell.forEach(n => set.add(n));
      })));
      return [...set];
    })();

    /* =========================================================
       Prefs & persistence
    ========================================================== */
    const defaultFilters = {
      strings: Object.fromEntries(STRINGS.map(s => [s, true])),
      positions: Object.fromEntries(POSITIONS.map(p => [p, true])),
      fingers: Object.fromEntries(FINGERS.map(f => [f, true])),
    };
    const loadPrefs = () => {
      try {
        const p = JSON.parse(localStorage.getItem(PREFS_KEY));
        return {
          sound: true, confetti: true, adaptive: true, coach: true, coachRetry: true,
          callouts: true, roundLen: 120, goalEnabled: false, goalTarget: 10,
          filters: { ...defaultFilters, ...(p?.filters || {}) }, ...(p || {})
        };
      } catch { return { sound:true, confetti:true, adaptive:true, coach:true, coachRetry:true, callouts:true, roundLen:120, goalEnabled:false, goalTarget:10, filters: defaultFilters }; }
    };
    const savePrefs = (obj) => { try { localStorage.setItem(PREFS_KEY, JSON.stringify(obj)); } catch {} };
    const loadBest = () => { try { return JSON.parse(localStorage.getItem(BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveBest = (obj) => { try { localStorage.setItem(BEST_KEY, JSON.stringify(obj)); } catch {} };
    const loadStats = () => { try { return JSON.parse(localStorage.getItem(STATS_KEY)) || {}; } catch { return {}; } };
    const saveStats = (obj) => { try { localStorage.setItem(STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoStats = () => { try { return JSON.parse(localStorage.getItem(TEMPO_STATS_KEY)) || {}; } catch { return {}; } };
    const saveTempoStats = (obj) => { try { localStorage.setItem(TEMPO_STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoBest = () => { try { return JSON.parse(localStorage.getItem(TEMPO_BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveTempoBest = (obj) => { try { localStorage.setItem(TEMPO_BEST_KEY, JSON.stringify(obj)); } catch {} };
    const loadJSON = (k, fallback={}) => { try { return JSON.parse(localStorage.getItem(k)) || fallback; } catch { return fallback; } };
    const saveJSON = (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };

    /* =========================================================
       Audio & call-outs
    ========================================================== */
    const useBeeps = (enabled) => {
      const ctxRef = useRef(null);
      const ensureCtx = () => {
        if (!enabled) return null;
        if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
        return ctxRef.current;
      };
      const beep = (freq = 880, dur = 0.08, type = 'sine') => {
        const ctx = ensureCtx(); if (!ctx) return;
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = type; o.frequency.value = freq; g.gain.value = 0.08; o.connect(g); g.connect(ctx.destination);
        o.start(); setTimeout(()=>o.stop(), dur*1000);
      };
      return { good: () => beep(1046, 0.09, 'triangle'), bad: () => beep(196, 0.12, 'sawtooth') };
    };
    const useCallouts = (enabled) => {
      const speak = (text) => {
        if (!enabled || !window.speechSynthesis) return;
        try {
          const u = new SpeechSynthesisUtterance(text);
          u.lang='en-US'; u.rate=1.0;
          window.speechSynthesis.cancel();
          setTimeout(()=>window.speechSynthesis.speak(u), 0);
        } catch {}
      };
      return { speak };
    };

    /* =========================================================
       Evidence-based & visuals helpers
    ========================================================== */
    const wilsonLowerBound = (correct, total, z = 1.96) => {
      if (!total) return 0;
      const p = correct / total;
      const denom = 1 + (z*z)/total;
      const centre = p + (z*z)/(2*total);
      const adj = z * Math.sqrt((p*(1-p) + (z*z)/(4*total)) / total);
      return Math.max(0, (centre - adj) / denom);
    };
    const bandFromLB = (lb) => { if (lb < 0.65) return 'red'; if (lb < 0.85) return 'yellow'; return 'green'; };
    const bandFromAcc = (acc) => {
      if (acc < 0.65) return 'red';
      if (acc < 0.85) return 'yellow';
      return 'green';
    };
    const SWATCH = { red:[239,68,68], yellow:[245,158,11], green:[16,185,129], gray:[120,120,120] };
    const rgba = (rgb, a) => `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
    const stabilityAlpha = (n) => { if (!n) return 0.18; const t = Math.min(1, Math.log10(n + 1) / Math.log10(50)); return 0.35 + 0.65 * t; };
    const evidenceStyle = (st) => {
      const correct = st?.correct || 0, total = st?.total || 0;
      if (!total) {
        return {
          // unchanged empty-state styling
          bandColorLB:  rgba(SWATCH.gray, 0.45),
          bandColorAcc: rgba(SWATCH.gray, 0.45),
          bg: 'transparent',
          text: 'var(--ink-600)',
          lb: 0,
          acc: 0,
          total: 0,
          bandLB: 'gray',
          bandAcc: 'gray'
        };
      }
      const acc = correct / total;                 // raw accuracy
      const lb  = wilsonLowerBound(correct, total); // 95% LB
      const bandLB  = bandFromLB(lb);
      const bandAcc = bandFromAcc(acc);
      const alpha   = stabilityAlpha(total);       // opacity grows with attempts
    
      return {
        bandColorLB:  rgba(SWATCH[bandLB],  alpha),
        bandColorAcc: rgba(SWATCH[bandAcc], alpha),
        bg: 'transparent',
        text: 'var(--ink-800)',
        lb, acc, total,
        bandLB, bandAcc
      };
    };

    /* =========================================================
       XP, Streaks, Levels, Badges (Gamification Core)
    ========================================================== */
    const BASE_XP = 10;
    const streakMultiplier = (streak) => Math.min(2.0, 1 + Math.floor(streak/5)*0.2);
    const xpForEvent = ({type='normal', streak=0}) => {
      const base = (type==='review'?5 : type==='retry'?1 : BASE_XP);
      return Math.round(base * streakMultiplier(streak));
    };
    const levelForXP = (xp)=> Math.floor(Math.pow(xp/120, 0.75))+1;  // fast early levels
    const nextLevelXP = (lvl)=> Math.round(120*Math.pow(lvl, 1.33));

    const loadScoreboard = () => loadJSON(SCORE_KEY, { xp:0, level:1, next: nextLevelXP(1) });
    const saveScoreboard = (obj) => saveJSON(SCORE_KEY, obj);
    const loadStreak = () => loadJSON(STREAK_KEY, { current:0, best:0, lastTimestamp:0 });
    const saveStreak = (obj) => saveJSON(STREAK_KEY, obj);

    const BADGES = [
      {slug:'first-100', name:'First 100', test: s => s.totalCorrect >= 100},
      {slug:'perfect-20', name:'Perfect 20', test: s => s.bestStreak >= 20},
      {slug:'d-string-ace', name:'Master of D String', test: s => {
        const keys = Object.keys(s.byCell || {}).filter(k=>k.startsWith('D:'));
        if (!keys.length) return false;
        return keys.every(k=> { const t=s.byCell[k]; return (t.total||0)>=10 && (t.correct||0)/(t.total||1) >= 0.9; });
      }},
      {slug:'streak-50', name:'Combo 50', test: s => s.bestStreak >= 50},
    ];
    const loadBadges = () => loadJSON(BADGES_KEY, { earned:{} });
    const saveBadges = (b) => saveJSON(BADGES_KEY, b);

    const summarizeStats = (stats) => {
      let total=0, correct=0; const byCell={};
      Object.entries(stats||{}).forEach(([k,v])=>{
        const c=v.correct||0, t=v.total||0; total+=t; correct+=c; byCell[k]={correct:c,total:t};
      });
      const bestStreak = Math.max(loadBest().bestStreak||0, (loadStreak().best||0));
      return { totalAttempts: total, totalCorrect: correct, byCell, bestStreak };
    };

    const checkAwardBadges = () => {
      const summary = summarizeStats(loadStats());
      const bag = loadBadges();
      let changed = false;
      BADGES.forEach(b=>{
        if (!bag.earned[b.slug] && b.test(summary)) { bag.earned[b.slug] = nowISO(); changed = true; }
      });
      if (changed) saveBadges(bag);
      return bag;
    };

    /* =========================================================
       SM-2 Spaced Repetition (Speed Ladder)
    ========================================================== */
    function scheduleSM2(item, quality) { // 0..5
      const MIN_EASE = 1.3;
      if (quality < 3) { item.reps = 0; item.interval = 1; item.lapses=(item.lapses||0)+1; }
      else {
        item.reps = (item.reps||0) + 1;
        if (item.reps === 1) item.interval = 1;
        else if (item.reps === 2) item.interval = 6;
        else item.interval = Math.round(item.interval * (item.ease||2.5));
      }
      item.ease = Math.max(MIN_EASE, (item.ease||2.5) + (0.1 - (5 - quality)*(0.08 + (5 - quality)*0.02)));
      item.due = Date.now() + item.interval * 86400000;
      return item;
    }
    const sm2Update = (key, quality) => {
      const sm2 = loadJSON(SM2_KEY, {});
      const item = sm2[key] || { ease:2.5, interval:0, due:Date.now(), reps:0, lapses:0 };
      sm2[key] = scheduleSM2(item, quality);
      saveJSON(SM2_KEY, sm2);
    };
    const sm2DueKeys = () => {
      const sm2 = loadJSON(SM2_KEY, {});
      const now = Date.now();
      return Object.entries(sm2).filter(([k,v]) => (v?.due||0) <= now).map(([k])=>k);
    };

    /* =========================================================
       Tiny UI atoms
    ========================================================== */
    const Modal = ({ open, onClose, title, children }) => !open ? null : (
      <div className="modal-backdrop" onClick={onClose}>
        <div className="modal card rounded-xl p-5" role="dialog" aria-modal="true" onClick={e=>e.stopPropagation()}>
          <div className="flex items-center justify-between mb-2">
            <div className="text-lg font-bold">{title}</div>
            <button className="btn btn-gray" onClick={onClose}>Close</button>
          </div>
          <div className="muted text-sm leading-relaxed">{children}</div>
        </div>
      </div>
    );

    const CardButton = ({ title, description, onClick, onHelp }) => (
      <div className="card rounded-xl p-5">
        <div className="flex items-start justify-between">
          <div>
            <div className="text-xl font-bold ink800">{title}</div>
            <div className="muted text-sm mt-1">{description}</div>
          </div>
          <button className="help-dot" aria-label="How to play" onClick={onHelp}>?</button>
        </div>
        <div className="mt-4">
          <button className="btn btn-purple" onClick={onClick}>Open</button>
        </div>
      </div>
    );

    const Toast = ({ open, text, action, onAction }) => !open ? null : (
      <div className="toast">
        <div className="card rounded-full px-4 py-2 flex items-center gap-3">
          <span className="ink800">{text}</span>
          {action && <button className="btn btn-amber" onClick={onAction}>{action}</button>}
        </div>
      </div>
    );

    /* =========================================================
       Help text (one-paragraph per card)
    ========================================================== */
    const HELP = {
      speed: "Speed Ladder: you‚Äôll see a prompt like ‚ÄúG string ‚Äî 2nd Position, 3rd Finger‚Äù. Choose the note that fits. Use keys 1‚Äì4 to answer fast. The coach re-surfaces weaknesses and (optionally) retries misses. Aim for accuracy first, then speed.",
      speedbase: "Speed Ladder ‚Äî Core: same game, but only the base note in each cell (no low/high). Use this to cement the map before tackling the full ladder.",
      cards: "Flashcards: two decks‚Äî(A) direct fingerboard hits (what note is at a given string/position/finger?) and (B) locations by note. Press Space to reveal, N/P or arrows to navigate.",
      bingo: "Positions Bingo: a 5√ó5 practice board with violin tasks. Mark squares as you complete them. The center is FREE. Press R to reshuffle the board.",
      dice: "Dice of Destiny: press Roll for a focused practice challenge. The dice avoids repeats until the set cycles. Copy your challenge to notes if you like.",
      tempoTrainer: "Tempo Trainer: flashcards for Italian tempo terms with optional speech call-outs. Reveal the meaning, then say the feel out loud.",
      tempoTester: "Tempo Tester: timed multiple choice. Press 1‚Äì4 to answer. At the end, review your misses and retry just those items. A heat map tracks per-term accuracy.",
      bielerLab: "Bieler Method Lab: progressive study of Ida Bieler‚Äôs approach. First build vocabulary, then test conceptual understanding, then apply ideas to musical scenarios and bow/left-hand technique.",
      height: "Finger Height Drill: Low vs High fingers. Prompt: note + standardized string/position/finger wording. Answer Low or High (L/H) to build intonation patterns.",
      locator: "Note Locator: Given a pitch (e.g., Bb), pick a valid location (Nth Position, Nth Finger on a given string). Reinforces multiple locations for the same note.",
      shift: "Shift Coach: Stay on one string. Given start & target notes, choose the most efficient new position/finger (requires a shift).",
      harmonics: "Harmonics Lab: Learn natural harmonic nodes (1/2, 1/3, 1/4) per string with flashcards and quick checks. Great for tone and intonation reference."
    };

    /* =========================================================
       Fingerboard Visual Hint (SVG)
    ========================================================== */
    const LANE_Y = {E:70, A:130, D:190, G:250};
    const X_FOR_POS = (p)=> 60 + (p-1)*120;
    const FINGER_OFFSET = {1:15, 2:40, 3:65, 4:90};
    const nodeXY = (s,p,f)=>({ x: X_FOR_POS(p)+FINGER_OFFSET[f], y: LANE_Y[s] });

    const FingerboardHint = ({active}) => (
      <svg width="100%" height="320" viewBox="0 0 700 320" className="mt-4">
        {['G','D','A','E'].map(s => (
          <g key={s}>
            <text x="10" y={LANE_Y[s]+4} fontSize="12" fill="currentColor">{s}</text>
            <line x1="50" x2="670" y1={LANE_Y[s]} y2={LANE_Y[s]} stroke="var(--gridline)" />
            {[1,2,3,4,5].map(p =>
              [1,2,3,4].map(f => {
                const {x,y}=nodeXY(s,p,f);
                const on = active && active.s===s && active.p===p && active.f===f;
                return <circle key={`${s}:${p}:${f}`} cx={x} cy={y} r={10}
                  fill={on?'var(--accent)':'rgba(255,255,255,.08)'}
                  stroke={on?'white':'rgba(0,0,0,.25)'} strokeWidth={on?2:1}
                  style={on?{filter:'drop-shadow(0 0 8px var(--accent))'}:null}
                />;
              })
            )}
            {[1,2,3,4,5].map(p=>{
              const x = X_FOR_POS(p)+52;
              return <text key={p} x={x} y={LANE_Y[s]-14} fontSize="11" fill="currentColor">{p}</text>;
            })}
          </g>
        ))}
      </svg>
    );

    /* =========================================================
       Heatmaps
    ========================================================== */
    const tileColor = (total, acc) => {
      if (!total) return 'rgba(120,120,120,0.18)';
      const hue = 140 * acc, sat = 85, light = 45 + 10 * acc;
      return `hsla(${hue}, ${sat}%, ${light}%, 1)`;
    };

    const AccuracyHeatmap = ({ stats }) => (
      <div className="card rounded-xl p-4">
        <div className="text-lg font-semibold mb-2">Fingerboard Accuracy</div>
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          {STRINGS.map(s => (
            <div key={s} className="rounded-lg border overflow-hidden">
              <div className="px-3 py-2 font-semibold" style={{ background: 'var(--surface-subtle)', whiteSpace:'nowrap' }}>
                {s} string
              </div>
              <div className="p-2">
                <div className="fb-strip">
                  {POSITIONS.map(p => (
                    <div key={p} className="fb-pos rounded-md border">
                      <div className="pos-chip" aria-hidden="true">Pos {p}</div>
                      <span className="sr-only">Position {p}</span>
                      <div className="fb-grid p-2">
                        {FINGERS.map(f => {
                          const isReal = !!validCell(s, p, f);
                          const k = `${s}:${p}:${f}`;
                          const st = isReal ? (stats[k] || { correct:0, total:0 }) : null;
                          const style = evidenceStyle(st);
                          return (
                            <div
                              key={f}
                              className="fb-tile"
                              title={
                                isReal
                                  ? `${fullLoc(s,p,f)} ‚Äî ${st.correct||0}/${st.total||0} (acc ${Math.round(style.acc*100)}%; LB ${Math.round(style.lb*100)}%)`
                                  : 'Not a valid finger/position'
                              }
                              aria-label={
                                isReal
                                  ? `${fullLoc(s,p,f)}. ${st.total||0} attempts, ${st.correct||0} correct. Accuracy ${Math.round(style.acc*100)} percent. Lower bound ${Math.round(style.lb*100)} percent.`
                                  : 'Invalid cell'
                              }
                            >
                              <div style={{ fontWeight:600 }}>F{f}</div>
                              <div className="text-xs">
                                {isReal && st.total ? `${Math.round((st.correct/st.total)*100)}%` : '‚Äî'}
                              </div>
                              <div className="fb-band fb-band--acc" style={{ background: style.bandColorAcc }} />
                               <div className="fb-band fb-band--lb"  style={{ background: style.bandColorLB  }} />
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ))}
        </div>

        <p className="text-xs muted mt-2">
          Each tile shows <b>two mini bands</b>: top = <b>Accuracy</b> (your current %), bottom = <b>Confidence</b> (95% Wilson <i>LB</i>).
          Colors: <span style={{color:'#ef4444',fontWeight:600}}>Red</span> &lt;65% ¬∑
          <span style={{color:'#f59e0b',fontWeight:600}}> Yellow</span> 65‚Äì85% ¬∑
          <span style={{color:'#10b981',fontWeight:600}}> Green</span> ‚â•85%.
          Opacity increases with attempts.
        </p>
      </div>
    );

    const TempoHeatmap = ({ stats, terms }) => (
      <div className="card rounded-xl p-4">
        <div className="text-lg font-semibold mb-2">Tempo Heatmap</div>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
          {terms.map(t => {
            const st = stats[t.it] || { correct:0, total:0 };
            const acc = st.total ? st.correct/st.total : 0;
            const bg = tileColor(st.total, acc);
            return (
              <div key={t.it} className="rounded border p-3" style={{background:bg}} title={`${t.it} ‚Äî ${st.correct}/${st.total} (${Math.round(acc*100)}%)`}>
                <div className="font-semibold">{t.it}</div>
                <div className="text-xs">{st.total ? `${Math.round(acc*100)}%` : '‚Äî'}</div>
              </div>
            );
          })}
        </div>
      </div>
    );

    /* =========================================================
       Tempo data
    ========================================================== */
    const TEMPOS = [
      { it:'Prestissimo', en:'super fast' },
      { it:'Presto',      en:'very fast' },
      { it:'Allegro',     en:'fast/happy' },
      { it:'Allegretto',  en:'medium moving/motion, brisk' },
      { it:'Andante',     en:'walking tempo/speed' },
      { it:'Andantino',   en:'little walking (near Andante)' },
      { it:'Adagio',      en:'slow (majestic), at ease' },
      { it:'Largo',       en:'slow-largeness, broad' },
      { it:'Lento',       en:'very slow' },
    ];

    /* =========================================================
       Bieler Method data
    ========================================================== */
    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1st‚Äì2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shifting‚Äîmoving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibrato‚Äîfinger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'D√©tach√©', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'Coll√©', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'Martel√©', def:'Accented, stopped stroke‚Äîbite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance point‚Äîvertical energy, horizontal timing.' },
      { term:'Sautill√©', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term:'Nature', def:'Use body‚Äôs natural alignments‚Äîeconomy, ease, resonance.' },
      { term:'Nurture', def:'Stepwise training‚Äîpatterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];

    const BIELER_CONCEPT_QA = [
      { q:'Why does ‚Äúhand frame‚Äù matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautill√©?', a:'Spiccato is placed/rebounded; sautill√© is natural spring at faster tempi.', wrong:['Spiccato is legato','Sautill√© is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];

    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy martel√© at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist coll√©','Firm staccato','Always play sul ponticello'] },
    ];

    /* =========================================================
       Confetti
    ========================================================== */
    const ConfettiBurst = ({ seed }) => {
      const [pieces, setPieces] = useState([]);
      useEffect(() => {
        if (!seed) return;
        const EMOJI = ['‚ú®','üéâ','üéä','‚≠ê','üí•','üåü'];
        const n = 24;
        const arr = Array.from({ length: n }, (_, i) => ({
          id: i, left: Math.random()*100, rot: (Math.random()*40)-20, delay: Math.random()*100, emoji: EMOJI[Math.floor(Math.random()*EMOJI.length)]
        }));
        setPieces(arr);
        const t = setTimeout(()=>setPieces([]), 900);
        return () => clearTimeout(t);
      }, [seed]);
      if (!pieces.length) return null;
      return (
        <div className="pointer-events-none fixed inset-0 overflow-hidden z-50">
          {pieces.map(p => (
            <span key={p.id} style={{position:'absolute', left:`${p.left}vw`, top:'-10px', transform:`rotate(${p.rot}deg)`, animation:'fall 0.9s ease-in forwards', animationDelay:`${p.delay}ms`, fontSize:'20px' }}>
              {p.emoji}
            </span>
          ))}
          <style>{`@keyframes fall{to{transform:translateY(110vh); opacity:.65;}}`}</style>
        </div>
      );
    };

    /* =========================================================
       Shared helpers for fingerboard
    ========================================================== */
    const validCell = (s,p,f) => Array.isArray(NOTES_DATA[s]?.[p]?.[f]) ? NOTES_DATA[s][p][f] : null;
    const allActualCombos = () => {
      const arr = [];
      for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
        const cell = validCell(s,p,f);
        if (cell) arr.push({ s, p, f, valid: cell });
      }
      return arr;
    };
    const allLocationsForNote = (note) => {
      const spots=[];
      for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
        const cell = validCell(s,p,f);
        if (cell && cell.includes(note)) spots.push({s,p,f});
      }
      return spots;
    };
    const groupLocationsByString = (note) => {
      const by = new Map(STRINGS.map(s=>[s,[]]));
      for (const loc of allLocationsForNote(note)) by.get(loc.s).push(loc);
      const lines = [];
      for (const s of STRINGS){
        const arr = by.get(s).sort((a,b)=>Number(a.p)-Number(b.p)||Number(a.f)-Number(b.f));
        if (arr.length) lines.push(`${s}: ${arr.map(({p,f})=>`${posLabel(p)} (${fingerLabel(f)})`).join(', ')}`);
      }
      return lines.join('  |  ');
    };

    /* =========================================================
       Games
    ========================================================== */

    // Tempo Trainer (flashcards)
    const TempoTrainer = ({ onBack, prefs }) => {
      const [i, setI] = useState(0);
      const [show, setShow] = useState(false);
      const { speak } = useCallouts(prefs.callouts);
      useEffect(()=>{ speak(TEMPOS[i].it); }, [i]);
      const next = () => { setShow(false); setI((i+1)%TEMPOS.length); };
      const prev = () => { setShow(false); setI((i-1+TEMPOS.length)%TEMPOS.length); };
      useEffect(()=>{
        const onKey = (e)=>{ const k = e.key.toLowerCase(); if(k===' '){e.preventDefault();setShow(true);} if(k==='arrowright'||k==='n') next(); if(k==='arrowleft'||k==='p') prev(); };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [i, show]);
      const card = TEMPOS[i];
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-4">Tempo Trainer (Flashcards)</h2>
            <div className="rounded-xl border-2 p-6 text-center">
              <div className="text-xl font-bold">{card.it}</div>
              {show ? <div className="mt-2">
                <div className="text-green-700 font-semibold">{card.en}</div>
                <div className="text-xs muted mt-1">Say the feel out loud, then tap Next.</div>
              </div> : <div className="muted italic">Press Space or tap ‚ÄúReveal‚Äù.</div>}
            </div>
            <div className="flex gap-2 mt-6 justify-center">
              <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
              <button className="btn btn-gray" onClick={prev}>Previous</button>
              <button className="btn btn-purple" onClick={next}>Next</button>
            </div>
            <div className="text-xs muted mt-3 text-center">Shortcuts: Space, ‚Üê/‚Üí or P/N</div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Tempo Tester (MCQ + XP + session log)
    const TempoTester = ({ onBack, prefs }) => {
      const [best, setBest] = useState(loadTempoBest());
      const [stats, setStats] = useState(loadTempoStats());
      const [timer, setTimer] = useState(prefs.roundLen || 60);
      const [finished, setFinished] = useState(false);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [streak, setStreak] = useState(0);
      const [confettiSeed, setConfettiSeed] = useState(0);
      const [events, setEvents] = useState([]);
      const [q, setQ] = useState(null);
      const { speak } = useCallouts(prefs.callouts);
      const beeps = useBeeps(prefs.sound);
      const optionsRef = useRef([]);
      const hitIdxRef = useRef(-1);

      const pickQ = (forced=null) => {
        const correct = forced || getRandomItem(TEMPOS);
        const distractors = shuffle(TEMPOS.filter(t=>t.it!==correct.it)).slice(0,3);
        const options = shuffle([correct.en, ...distractors.map(d=>d.en)]);
        setQ({ it: correct.it, correct: correct.en, options, ts: performance.now() });
        optionsRef.current = options;
        speak(correct.it);
      };

      // In TempoTester
      const pushSession = (correct, total) => {
        const log = loadJSON(SESSIONLOG_KEY, []);
        log.push({ mode: 'tempo', date: nowISO(), correct, total });
        saveJSON(SESSIONLOG_KEY, log);
      };

      useEffect(() => {
        if (finished) return;
        const id = setInterval(() => setTimer(t => {
          if (t <= 1) {
            clearInterval(id);
            setFinished(true);
            const nb = {
              bestScore: Math.max(best.bestScore, score),
              bestStreak: Math.max(best.bestStreak, streak)
            };
            setBest(nb);
            saveTempoBest(nb);
            pushSession(score, answered);   // <-- correct arg order
            return 0;
          }
          return t - 1;
        }), 1000);
        return () => clearInterval(id);
        // include `answered` so the logged total is current
      }, [finished, score, streak, answered, best]);

      const bump = (it, ok) => {
        const st = stats[it] || { correct:0, total:0 };
        const next = { ...stats, [it]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveTempoStats(next);
      };

      const addXP = (ok) => {
        if (!ok) return;
        const sb = loadScoreboard();
        const add = xpForEvent({type:'tempo', streak});
        const xp = sb.xp + add;
        const level = levelForXP(xp), next = nextLevelXP(level);
        saveScoreboard({ xp, level, next });
      };

      const handleAnswer = (choice, idx) => {
        if (finished || !q) return;
        const ok = (choice === q.correct);
        bump(q.it, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setEvents(e => [{ t: Date.now(), it:q.it, chosen:choice, correct:q.correct, ok }, ...e]);
        setAnswered(a=>a+1);
        hitIdxRef.current = idx;
        if (ok){ beeps.good(); setScore(s=>s+1); setStreak(x=>x+1); addXP(true); if (prefs.confetti) setConfettiSeed(x=>x+1); setTimeout(()=>pickQ(), 360); }
        else { beeps.bad(); setStreak(0); setTimeout(()=>pickQ(), 760); }
        setTimeout(()=>{ hitIdxRef.current = -1; }, 280);
      };

      useEffect(()=>{
        const onKey=(e)=>{ if(finished) return; const k=e.key.toLowerCase(); if(['1','2','3','4'].includes(k)){ const idx=Number(k)-1; const ch=optionsRef.current?.[idx]; if(ch) handleAnswer(ch, idx); } };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [finished, q]);

      const endReviewList = useMemo(()=>{
        const misses = [...events].filter(e=>!e.ok).reverse();
        const unique = []; const seen = new Set();
        for (const m of misses){ if(!seen.has(m.it)){ unique.push(m); seen.add(m.it); } }
        return unique;
      }, [events]);

      const startReview = () => {
        if (!endReviewList.length) return;
        setFinished(false); setScore(0); setAnswered(0); setStreak(0); setEvents([]);
        pickQ(endReviewList[0] && { it:endReviewList[0].it, en:endReviewList[0].correct });
      };

      const reset = () => {
        setFinished(false); setScore(0); setAnswered(0); setStreak(0); setEvents([]); setConfettiSeed(0);
        setTimer(prefs.roundLen || 60); pickQ();
      };

      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-2">Tempo Tester (Multiple Choice)</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered} ¬∑ Best: <b>{best.bestScore}</b> ¬∑ Best streak: <b>{best.bestStreak}</b></div>
            {!finished && q && (
              <>
                <div className="text-center mb-5">
                  <div className="text-xl font-bold">What does <b>{q.it}</b> mean?</div>
                  <div className="text-xs muted mt-1">Press 1‚Äì4 to answer fast.</div>
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {q.options.map((opt,i)=>(
                    <button key={i} className={`btn btn-blue ${i===hitIdxRef.current ? 'btn-hit ' + (opt===q.correct?'ok':'miss') : ''}`} title={`Press ${i+1}`} onClick={()=>handleAnswer(opt,i)}>
                      <span className="pill" style={{ background: 'rgba(0,0,0,.15)' }}>{i+1}</span>&nbsp; {opt}
                    </button>
                  ))}
                </div>
              </>
            )}
            {finished && (
              <div className="text-center">
                <div className="text-xl font-semibold">Round over! Final score: {score} / {answered}</div>
                <div className="mt-3">
                  <button className="btn btn-purple mr-2" onClick={reset}>Play Again</button>
                  <button className="btn btn-green" disabled={!endReviewList.length} onClick={startReview}>
                    Review Misses {endReviewList.length ? `(${endReviewList.length})` : ''}
                  </button>
                </div>
              </div>
            )}
          </div>

          <div className="w-full mt-6" style={{maxWidth:900}}>
            <TempoHeatmap stats={stats} terms={TEMPOS} />
          </div>

          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Finger Height Drill ===================== */
    const HeightDrill = ({ onBack, prefs }) => {
      const [q, setQ] = useState(null);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [timer, setTimer] = useState(prefs.roundLen || 60);
      const [stats, setStats] = useState(loadJSON(HEIGHT_STATS_KEY, {}));
      const [confettiSeed, setConfettiSeed] = useState(0);
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);

      const combos = useMemo(()=> allActualCombos().filter(c => c.valid.length >= 2),[]);
      const pick = () => {
        const c = getRandomItem(combos);
        const note = getRandomItem(c.valid);
        const label = fingerHeight(note, c.valid);
        speak(fullLoc(c.s, c.p, c.f));
        setQ({ ...c, note, label });
      };
      useEffect(()=>{ pick(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => (t <= 1 ? 0 : t-1)), 1000);
        return ()=>clearInterval(id);
      },[]);

      const bump = (key, ok) => {
        const st = stats[key] || { low:{correct:0,total:0}, high:{correct:0,total:0}, natural:{correct:0,total:0} };
        const next = { ...stats, [key]: {
          low: { correct: st.low.correct + (ok && q.label==='low'?1:0), total: st.low.total + (q.label==='low'?1:0) },
          high:{ correct: st.high.correct+ (ok && q.label==='high'?1:0), total: st.high.total + (q.label==='high'?1:0) },
          natural:{ correct: st.natural.correct+ (ok && q.label==='natural'?1:0), total: st.natural.total + (q.label==='natural'?1:0) },
        } };
        setStats(next); saveJSON(HEIGHT_STATS_KEY, next);
      };

      const answer = (choice) => {
        if (!q || timer===0) return;
        const ok = (choice.toLowerCase() === q.label);
        const key = `${q.s}:${q.p}:${q.f}`;
        bump(key, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setAnswered(a=>a+1);
        if (ok) { beeps.good(); setScore(s=>s+1); if (prefs.confetti) setConfettiSeed(x=>x+1); setTimeout(pick, 350); }
        else { beeps.bad(); setTimeout(pick, 700); }
      };

      useEffect(()=>{
        const onKey=(e)=>{ const k=e.key.toLowerCase(); if(k==='l') answer('low'); if(k==='h') answer('high'); if(k==='escape') onBack(); };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [q, timer]);

      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:760}}>
            <h2 className="text-2xl font-bold mb-2">Finger Height Drill (Low / High)</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered} ¬∑ Shortcuts: L / H</div>
            {q && (
              <>
                <div className="text-center mb-3">
                  <div className="text-xl font-bold">To play <b>{norm(q.note)}</b> at <b>{fullLoc(q.s, q.p, q.f)}</b> ‚Äî is the finger <b>Low</b> or <b>High</b>?</div>
                </div>
                <FingerboardHint active={{s:q.s, p:q.p, f:q.f}} />
                <div className="flex gap-3 justify-center mt-3">
                  <button className="btn btn-blue" onClick={()=>answer('low')}>Low</button>
                  <button className="btn btn-purple" onClick={()=>answer('high')}>High</button>
                </div>
                <div className="text-xs muted mt-4 text-center">Tip: ‚ÄúLow‚Äù is the first (flat) value in a cell like [F, F#]; ‚ÄúHigh‚Äù is the sharp.</div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Note Locator ===================== */
    const NoteLocator = ({ onBack, prefs }) => {
      const [q,setQ] = useState(null);
      const [timer,setTimer] = useState(prefs.roundLen || 90);
      const [score,setScore] = useState(0);
      const [answered,setAnswered] = useState(0);
      const [stats, setStats] = useState(loadJSON(LOCATOR_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);

      const labelLoc = o => `${fullLoc(o.s, o.p, o.f)}`;

      const makeQ = () => {
        const note = getRandomItem(ALL_NOTES_UNIQUE);
        const correctLocs = allLocationsForNote(note);
        if (!correctLocs.length) return makeQ();
        const correct = getRandomItem(correctLocs);
        const wrongPool = allActualCombos().filter(c => {
          const cell = validCell(c.s, c.p, c.f) || [];
          return !cell.includes(note);
        });
        const nearby = wrongPool.filter(c => c.s===correct.s || c.p===correct.p || c.f===correct.f);
        const fillers = nearby.length >= 3 ? nearby : wrongPool;
        const opts = shuffle([{...correct, ok:true}, ...shuffle(fillers)
          .filter(c => !(c.s===correct.s && c.p===correct.p && c.f===correct.f))
          .slice(0,3).map(c => ({...c, ok:false}))]);
        speak(note);
        setQ({ note, opts });
      };

      useEffect(()=>{ makeQ(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => t<=1 ? 0 : t-1), 1000);
        return ()=>clearInterval(id);
      },[]);

      const bump = (note, ok) => {
        const st = stats[note] || { correct:0, total:0 };
        const next = { ...stats, [note]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(LOCATOR_STATS_KEY, next);
      };

      const answer = (o) => {
        const ok = !!o.ok;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        bump(q.note, ok);
        setAnswered(a=>a+1);
        if (ok) setScore(s=>s+1);
        setTimeout(makeQ, ok?350:700);
      };

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:800}}>
            <h2 className="text-2xl font-bold mb-2">Note Locator</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered}</div>
            {q && (
              <>
                <div className="text-xl font-bold text-center">Where can you play <b>{norm(q.note)}</b>?</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-4">
                  {q.opts.map((o,i)=>(
                    <button key={i} className="btn btn-blue" onClick={()=>answer(o)}>
                      <span className="pill" style={{background:'rgba(0,0,0,.15)'}}>{i+1}</span>&nbsp; {labelLoc(o)}
                    </button>
                  ))}
                </div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Shift Coach ===================== */
    const ShiftCoach = ({ onBack, prefs }) => {
      const [q,setQ] = useState(null);
      const [score,setScore] = useState(0);
      const [answered,setAnswered] = useState(0);
      const [timer,setTimer] = useState(prefs.roundLen || 90);
      const [stats, setStats] = useState(loadJSON(SHIFT_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);

      const locationsForNoteOnString = (note, s) => allLocationsForNote(note).filter(l => l.s === s);
      const samePosExists = (A, B) => A.some(a => B.some(b => a.p===b.p));
      const pathCost = (a, b) => Math.abs(Number(a.p) - Number(b.p));
      const bestPair = (A, B) => {
        let best = null;
        for (const a of A) for (const b of B) {
          const cost = pathCost(a,b);
          if (!best || cost < best.cost) best = {a,b,cost};
        }
        return best;
      };

      const makePrompt = () => {
        const s = getRandomItem(STRINGS);
        const n1 = getRandomItem(ALL_NOTES_UNIQUE);
        const n2 = getRandomItem(ALL_NOTES_UNIQUE);
        const A = locationsForNoteOnString(n1, s);
        const B = locationsForNoteOnString(n2, s);
        if (!A.length || !B.length) return makePrompt();
        if (samePosExists(A,B)) return makePrompt();
        const best = bestPair(A,B);
        const start = best.a;
        const correctEnd = best.b;
        const pool = allActualCombos().filter(c => c.s === s).filter(c => !(validCell(c.s, c.p, c.f) || []).includes(n2));
        const opts = [{...correctEnd, ok:true}];
        for (const cand of shuffle(pool)) {
          if (opts.length >= 4) break;
          if (!opts.some(o => o.p===cand.p && o.f===cand.f)) opts.push({...cand, ok:false});
        }
        setQ({ string:s, startNote:n1, targetNote:n2, start, opts: shuffle(opts) });
      };

      useEffect(()=>{ makePrompt(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => t<=1 ? 0 : t-1), 1000);
        return ()=>clearInterval(id);
      },[]);

      const bump = (key, ok) => {
        const st = stats[key] || { correct:0, total:0 };
        const next = { ...stats, [key]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(SHIFT_STATS_KEY, next);
      };

      const answer = (o) => {
        const ok = !!o.ok;
        const key = `${q.string}:${q.startNote}->${q.targetNote}`;
        bump(key, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        setAnswered(a=>a+1);
        if (ok) setScore(s=>s+1);
        setTimeout(makePrompt, ok?350:700);
      };

      const labelLoc = o => `${fullLoc(q.string, o.p, o.f, false)}`;

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:860}}>
            <h2 className="text-2xl font-bold mb-2">Shift Coach</h2>
            <div className="muted text-sm mb-4">Stay on one string. Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered}</div>
            {q && (
              <>
                <div className="rounded-md p-4" style={{background:'rgba(0,0,0,.05)'}} aria-live="polite">
                  <div className="font-semibold mb-1">String: <b>{q.string}</b></div>
                  <div className="text-sm">Start at <b>{norm(q.startNote)}</b> ‚Üí <span className="muted">{fullLoc(q.string, q.start.p, q.start.f, false)}</span></div>
                  <div className="text-sm">Target note: <b>{norm(q.targetNote)}</b></div>
                </div>
                <div className="text-center text-sm muted mt-2 mb-4">Which <b>position + finger</b> is the best landing spot for the target?</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {q.opts.map((o,i)=>(
                    <button key={i} className="btn btn-blue" onClick={()=>answer(o)}>
                      <span className="pill" style={{background:'rgba(0,0,0,.15)'}}>{i+1}</span>&nbsp; {labelLoc(o)}
                    </button>
                  ))}
                </div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Harmonics Lab ===================== */
    const HarmonicsLab = ({ onBack, prefs }) => {
      const [mode, setMode] = useState('flash'); // flash | quiz
      const [i, setI] = useState(0);
      const [show, setShow] = useState(false);
      const [stats, setStats] = useState(loadJSON(HARM_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);

      const deck = useMemo(()=>{
        const cards = [];
        for (const s of STRINGS) {
          for (const ratio of Object.keys(HARMONICS[s])) {
            const [pitch, label] = HARMONICS[s][ratio];
            cards.push({ s, ratio, label, pitch });
          }
        }
        return cards;
      },[]);

      const next = () => { setShow(false); setI((i+1)%deck.length); };
      const prev = () => { setShow(false); setI((i-1+deck.length)%deck.length); };

      const [q, setQ] = useState(null);
      const makeQ = () => {
        const s = getRandomItem(STRINGS);
        const target = getRandomItem(Object.entries(HARMONICS[s]));
        const correctRatio = target[0];
        const noteName = target[1][0];
        const display = `${s} string ‚Äî play the ${noteName} harmonic`;
        const ratios = Object.keys(HARMONICS[s]);
        const distracts = shuffle(ratios.filter(r=>r!==correctRatio)).slice(0,3);
        const options = shuffle([correctRatio, ...distracts]).map(r => ({r, ok: r===correctRatio}));
        setQ({ s, note: noteName, display, options });
      };

      useEffect(()=>{ if(mode==='quiz') makeQ(); }, [mode]);

      const bump = (key, ok) => {
        const st = stats[key] || { correct:0, total:0 };
        const next = { ...stats, [key]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(HARM_STATS_KEY, next);
      };

      const answer = (opt) => {
        const ok = !!opt.ok;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        const key = `${q.s}:${q.note}`;
        bump(key, ok);
        setTimeout(makeQ, ok?350:700);
      };

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:820}}>
            <div className="flex items-center justify-between">
              <h2 className="text-2xl font-bold">Harmonics Lab</h2>
              <div className="flex gap-2">
                <button className={`btn ${mode==='flash'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('flash')}>Flashcards</button>
                <button className={`btn ${mode==='quiz'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('quiz')}>Quick Quiz</button>
              </div>
            </div>

            {mode==='flash' && (
              <div className="mt-4">
                <div className="rounded-xl border-2 p-6 text-center">
                  <div className="text-xl font-bold">{deck[i].s} string ‚Äî Node {deck[i].ratio}</div>
                  {show ? (
                    <div className="mt-2 ink700">
                      <div><b>Pitch:</b> {deck[i].pitch}</div>
                      <div><b>Type:</b> {deck[i].label}</div>
                      <div className="text-xs muted mt-1">Light touch above the node; release pressure for a clear chime.</div>
                    </div>
                  ) : <div className="muted italic">Press Reveal to show details.</div>}
                </div>
                <div className="flex gap-2 mt-4 justify-center">
                  <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
                  <button className="btn btn-gray" onClick={prev}>Previous</button>
                  <button className="btn btn-purple" onClick={next}>Next</button>
                </div>
                <div className="text-xs muted mt-2 text-center">Card {i+1} / {deck.length}</div>
              </div>
            )}

            {mode==='quiz' && (
              <div className="mt-4">
                {!q ? <div className="muted">Loading‚Ä¶</div> : (
                  <>
                    <div className="text-lg font-semibold mb-2">Which node ratio produces this harmonic?</div>
                    <div className="rounded-md p-4 mb-3" style={{background:'var(--surface-subtle)'}}>
                      {q.display}
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                      {q.options.map((o,idx)=>(
                        <button key={idx} className="btn btn-blue" onClick={()=>answer(o)}>{o.r}</button>
                      ))}
                    </div>
                  </>
                )}
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Speed Ladder (fingerboard) + SM-2 + XP + hint + fingerboard SVG
    const SpeedLadderGame = ({ onBack, prefs, stats, setStats, mode = 'full' }) => {
      const baseOnly = mode === 'base';
      const allCombos = useMemo(()=>allActualCombos(), []);
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);
      const [question, setQuestion] = useState(null);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [timer, setTimer] = useState(prefs.roundLen || 120);
      const [finished, setFinished] = useState(false);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(loadBest().bestStreak);
      const [bestScore, setBestScore] = useState(loadBest().bestScore);
      const [confettiSeed, setConfettiSeed] = useState(0);
      const optionsRef = useRef([]);
      const lastMissRef = useRef(null);
      const hitIdxRef = useRef(-1);
      const [microHint, setMicroHint] = useState('');

      // SM-2: include some due items
      const dueKeys = sm2DueKeys(); // ['G:2:3:C#', ...]
      const dueCombos = useMemo(()=>{
        const map = new Map(allCombos.map(c=>[`${c.s}:${c.p}:${c.f}`, c]));
        const arr = [];
        for (const k of dueKeys) {
          const [s,p,f,maybeNote] = k.split(':');
          const base = map.get(`${s}:${p}:${f}`);
          if (base) arr.push({ ...base, sm2Key:k, preferredNote: maybeNote });
        }
        return arr;
      }, [allCombos, dueKeys.join('|')]);

      const candidates = useMemo(()=>{
        const f = prefs.filters||{};
        const okS = f.strings||{}; const okP = f.positions||{}; const okF = f.fingers||{};
        const sel = allCombos.filter(c => (okS[c.s]!==false) && (okP[c.p]!==false) && (okF[c.f]!==false));
        return sel.length ? sel : allCombos;
      }, [allCombos, prefs.filters]);

      const weightedPick = () => {
        if (!prefs.adaptive) return getRandomItem(candidates);
        const entries = candidates.map(c => {
          const k = `${c.s}:${c.p}:${c.f}`;
          const st = stats[k] || {correct:0,total:0};
          const lb = wilsonLowerBound(st.correct, st.total || 0);
          const unseen = st.total ? 0 : 0.6;
          return { combo: c, weight: Math.max(0.05, (1 - lb) + unseen) };
        });
        if (prefs.coach && prefs.coachRetry && lastMissRef.current){
          const miss = lastMissRef.current;
          const idx = entries.findIndex(e=> e.combo.s===miss.s && e.combo.p===miss.p && e.combo.f===miss.f);
          if (idx>=0) entries[idx].weight*=2.2;
        }
        // Interleave SM-2 due ~40% when available
        if (dueCombos.length && Math.random()<0.4) return getRandomItem(dueCombos);
        const sum = entries.reduce((a,e)=>a+e.weight,0)||1; let r = Math.random()*sum;
        for (const e of entries){ if((r-=e.weight)<=0) return e.combo; }
        return entries[entries.length-1].combo;
      };

      const newQuestion = (preset=null) => {
      const c = preset || weightedPick();
      // pick the correct note based on mode
      const baseOpts = baseNamesFor(c.s, c.p, c.f);
      const correct = baseOnly
        ? getRandomItem(baseOpts)
        : (c.preferredNote ? c.preferredNote : getRandomItem(c.valid));
    
      // build options from the appropriate pool
      const pool = baseOnly ? ALL_BASE_UNIQUE : ALL_NOTES_UNIQUE;
      const opts = shuffle([
        correct,
        ...getDistractorsFromPool(correct, pool, [], 3)
      ]);
    
      optionsRef.current = opts;
      setMicroHint('');
      setQuestion({
        ...c,
        valid: baseOnly ? baseNamesFor(c.s, c.p, c.f) : c.valid,
        correct,
        options: opts,
        ts: performance.now(),
        sm2Key: (c.sm2Key || `${c.s}:${c.p}:${c.f}:${norm(correct)}`)
      });
    };
      useEffect(()=>{ newQuestion(); }, []);
      useEffect(() => {
        if (!finished) setTimer(prefs.roundLen || 120);
      }, [prefs.roundLen, finished]);
      useEffect(()=>{
        if (finished) return;
        const id = setInterval(()=>setTimer(t=>{
          if(t<=1){
            clearInterval(id); setFinished(true);
            const bs = Math.max(bestScore, score); const bk = Math.max(bestStreak, streak);
            setBestScore(bs); setBestStreak(bk); saveBest({ bestScore:bs, bestStreak:bk });
            // log session
            const log = loadJSON(SESSIONLOG_KEY, []);
            log.push({
              mode: baseOnly ? 'speedbase' : 'speed',
              date: nowISO(),
              correct: score,
              total: answered
            });
            saveJSON(SESSIONLOG_KEY, log);
            checkAwardBadges();
            return 0;
          }
          return t-1;
        }), 1000);
        return ()=>clearInterval(id);
      }, [finished, score, streak, bestScore, bestStreak, answered]);

      const addXP = (type, ok) => {
        if (!ok) return;
        const sb = loadScoreboard();
        const add = xpForEvent({type, streak});
        const xp = sb.xp + add;
        const level = levelForXP(xp), next = nextLevelXP(level);
        saveScoreboard({ xp, level, next });
      };

      const handleAnswer = (note, idx) => {
        if (finished || !question) return;
        const key = `${question.s}:${question.p}:${question.f}`;
        const prev = stats[key] || { correct:0, total:0 };
        const ok = (note===question.correct);
        const updated = { ...stats, [key]: { correct: prev.correct + (ok?1:0), total: prev.total + 1 } };
        setStats(updated); saveStats(updated);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setAnswered(a=>a+1);
        hitIdxRef.current = idx;

        // micro hint when wrong
        if (!ok) {
          const label = fingerHeight(question.correct, question.valid);
          setMicroHint(`${norm(question.correct)} = ${label==='natural'?'natural':label} ${fingerLabel(question.f)} in ${posLabel(question.p)} (${question.s})`);
        } else setMicroHint('');
        if (!ok && baseOnly) {
          setMicroHint(`${norm(question.correct)} = base ${fingerLabel(question.f)} in ${posLabel(question.p)} (${question.s})`);
        }

        // SM-2
        const speedMs = performance.now() - (question.ts||performance.now());
        const quality = ok ? (speedMs<2000?5:4) : 2;
        sm2Update(question.sm2Key, quality);

        if (ok){
          lastMissRef.current=null; beeps.good(); setScore(s=>s+1); setStreak(x=>x+1); addXP('speed', true); if (prefs.confetti) setConfettiSeed(x=>x+1);
          setTimeout(()=>newQuestion(), prefs.coach ? 380 : 550);
        } else {
          lastMissRef.current={ s:question.s, p:question.p, f:question.f, valid:question.valid };
          beeps.bad(); setStreak(0);
          setTimeout(()=>{
            if (prefs.coach && prefs.coachRetry){
              const miss = lastMissRef.current;
              if (miss){
                // pick the correct note in the same mode we‚Äôre in
                const correct = baseOnly
                  ? getRandomItem(baseNamesFor(miss.s, miss.p, miss.f))
                  : getRandomItem(miss.valid);
          
                // distractors from the right pool
                const pool = baseOnly ? ALL_BASE_UNIQUE : ALL_NOTES_UNIQUE;
                const opts = shuffle([correct, ...getDistractorsFromPool(correct, pool, [], 3)]);
          
                optionsRef.current = opts;
                setQuestion({
                  ...miss,
                  correct,
                  options: opts,
                  ts: performance.now(),
                  sm2Key: `${miss.s}:${miss.p}:${miss.f}:${norm(correct)}`
                });
                return;
              }
            }
            newQuestion();
          }, 900);
        }
        setTimeout(()=>{ hitIdxRef.current = -1; }, 280);
      };

      useEffect(()=>{
        const onKey=(e)=>{ if(finished) return; const k=e.key.toLowerCase(); if(['1','2','3','4'].includes(k)){ const idx=Number(k)-1; const raw=optionsRef.current?.[idx]; if(raw) handleAnswer(raw, idx); } if(k==='escape') onBack(); };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [finished, question]);

      const reset = () => { setScore(0); setAnswered(0); setTimer(prefs.roundLen||120); setFinished(false); setStreak(0); setConfettiSeed(0); newQuestion(); };

      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8" style={{maxWidth:740, width:'100%'}}>
            <h2 className="text-2xl font-bold mb-2">Speed Ladder</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered} ¬∑ Best: <b>{bestScore}</b> ¬∑ Best streak: <b>{bestStreak}</b></div>
            {!finished && question && (
              <>
                <div className="text-center mb-4">
                  <div className="text-xl font-bold">
                    What note can you play at <b>{fullLoc(question.s, question.p, question.f)}</b>?
                  </div>
                  <div className="text-xs muted mt-1">Press 1‚Äì4 to answer fast.</div>
                </div>
                <FingerboardHint active={{s:question.s, p:question.p, f:question.f}} />
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-4">
                  {question.options.map((note, i)=>(
                    <button key={i} className={`btn btn-blue ${i===hitIdxRef.current ? 'btn-hit ' + (note===question.correct?'ok':'miss') : ''}`} title={`Press ${i+1}`} onClick={()=>handleAnswer(note,i)}>
                      <span className="pill" style={{ background: 'rgba(0,0,0,.15)' }}>{i+1}</span>&nbsp; {norm(note)}
                    </button>
                  ))}
                </div>
                {!!microHint && <div className="text-xs mt-3 text-center" style={{color:'#ef4444'}}>{microHint}</div>}
              </>
            )}
            {finished && (
              <div className="text-center">
                <div className="text-xl font-semibold">Round over! Final score: {score} / {answered}</div>
                <button className="btn btn-purple mt-3" onClick={reset}>Play Again</button>
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Flashcards (fingerboard)
    const Flashcards = ({ onBack }) => {
      const [mode, setMode] = useState('A');
      const [i, setI] = useState(0);
      const [show,setShow] = useState(false);
      const deckA = useMemo(()=>{
        const cards=[]; for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
          const cell = validCell(s,p,f);
          if (cell) cards.push({q:`What note(s) at ${fullLoc(s, p, f)}?`, a: cell.map(norm).join(' or ')});
        }
        return cards;
      },[]);
      const uniq = useMemo(()=>[...new Set(ALL_NOTES_UNIQUE)].sort(),[]);
      const deckB = useMemo(()=>uniq.map(n=>({q:`Where can you play ${norm(n)} (Pos 1‚Äì5)?`, a:groupLocationsByString(n)})),[uniq]);
      const deck = mode==='A'?deckA:deckB;
      const next=()=>{ setShow(false); setI((i+1)%deck.length); };
      const prev=()=>{ setShow(false); setI((i-1+deck.length)%deck.length); };
      useEffect(()=>{ const onKey=(e)=>{ const k=e.key.toLowerCase(); if(k===' '){e.preventDefault();setShow(true);} if(k==='n'||k==='arrowright') next(); if(k==='p'||k==='arrowleft') prev(); if(k==='escape') onBack(); }; window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); }, [i,show]);
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:760}}>
            <h2 className="text-2xl font-bold mb-4">Flashcards</h2>
            <div className="flex gap-2 mb-3">
              <button className={`btn ${mode==='A'?'btn-purple':'btn-gray'}`} onClick={()=>{setMode('A'); setI(0); setShow(false);}}>Deck A</button>
              <button className={`btn ${mode==='B'?'btn-purple':'btn-gray'}`} onClick={()=>{setMode('B'); setI(0); setShow(false);}}>Deck B</button>
            </div>
            <div className="rounded-xl border-2 p-6 text-center">
              <div className="text-lg font-bold">{deck[i].q}</div>
              {show ? <div className="mt-2 ink700 whitespace-pre-wrap">{deck[i].a}</div> : <div className="muted italic">Press Space or tap ‚ÄúReveal‚Äù.</div>}
            </div>
            <div className="flex gap-2 mt-6 justify-center">
              <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
              <button className="btn btn-gray" onClick={prev}>Previous</button>
              <button className="btn btn-purple" onClick={next}>Next</button>
            </div>
            <div className="text-xs muted mt-3 text-center">Card {i+1} / {deck.length} ¬∑ Shortcuts: Space, ‚Üê/‚Üí or P/N</div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Bingo
    const BingoBoard = ({ onBack }) => {
      const base = [
        "Say & play A-string Pos 2 F1‚ÄìF4 aloud","Upbeat start √ó8 bars","Bridge-lane forte √ó4 bars","Name all B notes Pos 1‚Äì5","Sight-read in Pos 2",
        "G-string Pos 1 quiz","C major in Pos 3 aloud","Find 3 ways to play D","E-string Pos 4 quiz","Slur ‚Üí up-bow staccato",
        "Name all Cs Pos 1‚Äì5","D major in Pos 5 aloud","Echo dynamics on repeat","Perfect fifth resonance check (stopped notes)","A-string Pos 3 quiz",
        "List all F#s Pos 1‚Äì5","Gigue pickup (up-bow)","Martel√© √ó8 bars","Map staff lines ‚Üí fingers","D-string Pos 4 quiz",
        "Contact-point ladders","Slow spiccato √ó8 bars","Tempo flashcards √ó20","Record 30s and review"
      ];
      const makeBoard=()=>{ const grid = shuffle(base).slice(0,24); grid.splice(12,0,'FREE'); return grid; };
      const [tiles,setTiles]=useState(makeBoard);
      const [on,setOn]=useState(()=>{ const o={}; tiles.forEach(t=>o[t]= (t==='FREE')); return o; });
      const toggle=(t)=>{ if(t==='FREE') return; setOn(s=>({...s,[t]:!s[t]})); };
      const reset=()=>{ const nx=makeBoard(); setTiles(nx); const o={}; nx.forEach(t=>o[t]=(t==='FREE')); setOn(o); };
      const checked = Object.values(on).filter(Boolean).length;
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-6 w-full" style={{maxWidth:960}}>
            <div className="flex items-center justify-between mb-2">
              <div className="text-2xl font-bold">Positions Bingo</div>
              <button className="btn btn-purple" onClick={reset}>New Board</button>
            </div>
            <div className="muted text-sm mb-2">Checked: {checked}/25 ¬∑ Center is FREE</div>
            <div className="grid grid-cols-5 gap-2">
              {tiles.map((t,i)=>(
                <button key={i} onClick={()=>toggle(t)}
                  className={`rounded-lg border-2 p-2 h-24 text-xs ${on[t]?'bg-green-500 text-white border-green-700':'bg-gray-200 text-gray-800 border-gray-300'}`}>
                  {t}
                </button>
              ))}
            </div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Dice
    const DiceOfDestinyGame = ({ onBack }) => {
      const poolFull = [
        'Say & play A-string Pos 2 F1‚ÄìF4 aloud','Upbeat start √ó8 bars','Bridge-lane forte √ó4 bars','Name all B notes Pos 1‚Äì5',
        'Sight-read in Pos 2','G-string Pos 1 quiz','C major in Pos 3 aloud','Find 3 ways to play D','E-string Pos 4 quiz',
        'Slur ‚Üí up-bow staccato','Name all Cs Pos 1‚Äì5','D major in Pos 5 aloud','Echo dynamics on repeat','Perfect fifth resonance check (stopped notes)',
        'A-string Pos 3 quiz','List all F#s Pos 1‚Äì5','Gigue pickup (up-bow)','Martel√© √ó8 bars','Map staff lines ‚Üí fingers','D-string Pos 4 quiz',
      ];
      const [pool,setPool]=useState(poolFull);
      const [cur,setCur]=useState('');
      const [busy,setBusy]=useState(false);
      const [history,setHistory]=useState([]);
      const roll=()=>{ setBusy(true); setCur('‚Ä¶'); setTimeout(()=>{ const p = pool.length ? pool : poolFull; const pick = getRandomItem(p); setCur(pick); setHistory(h=>[pick,...h].slice(0,6)); setPool(p.filter(x=>x!==pick)); setBusy(false); }, 560); };
      useEffect(()=>{ const onKey=(e)=>{ if(e.key==='Escape') onBack(); if(e.key.toLowerCase()==='r') roll(); }; window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); },[]);
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-4">Dice of Destiny</h2>
            <button disabled={busy} className="btn btn-green text-xl" onClick={roll}>{busy?'‚Ä¶':'Roll Dice'}</button>
            <div className="rounded-lg p-4 mt-6" style={{ background: 'var(--surface-subtle)' }}>
              <div className="text-sm muted">Your Destiny:</div>
              <div className="text-xl font-bold mt-2">{cur || 'Press Roll to begin!'}</div>
            </div>
            {!!history.length && <div className="mt-4">
              <div className="font-semibold text-sm mb-1">Recent rolls</div>
              <ul className="text-sm">{history.map((h,i)=><li key={i}>‚Ä¢ {h}</li>)}</ul>
            </div>}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* =========================================================
       Bieler Method Lab
    ========================================================== */
    const BielerLab = ({ onBack }) => {
      const [mode,setMode]=useState('vocab');
      const [i,setI]=useState(0); const [show,setShow]=useState(false);
      const next=()=>{ setShow(false); setI((i+1)%BIELER_VOCAB.length); };
      const prev=()=>{ setShow(false); setI((i-1+BIELER_VOCAB.length)%BIELER_VOCAB.length); };

      const makeConceptQ = () => {
        const item = getRandomItem(BIELER_CONCEPT_QA);
        const options = shuffle([item.a, ...shuffle(item.wrong).slice(0,3)]);
        return { prompt:item.q, correct:item.a, options };
      };
      const makeApplyQ = () => {
        const item = getRandomItem(BIELER_APPLY);
        const options = shuffle([item.answer, ...shuffle(item.wrong).slice(0,3)]);
        return { prompt:item.scenario, correct:item.answer, options };
      };
      const [cq,setCq]=useState(makeConceptQ());
      const [aq,setAq]=useState(makeApplyQ());
      const [scoreC,setScoreC]=useState(0), [answeredC,setAnsweredC]=useState(0);
      const [scoreA,setScoreA]=useState(0), [answeredA,setAnsweredA]=useState(0);

      const answerConcept = (opt)=>{ const ok = opt===cq.correct; document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again'; setScoreC(s=>s+(ok?1:0)); setAnsweredC(a=>a+1); setTimeout(()=>setCq(makeConceptQ()), ok?350:700); };
      const answerApply   = (opt)=>{ const ok = opt===aq.correct; document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again'; setScoreA(s=>s+(ok?1:0)); setAnsweredA(a=>a+1); setTimeout(()=>setAq(makeApplyQ()), ok?350:700); };

      useEffect(()=>{ const onKey=(e)=>{ if(e.key==='Escape') onBack(); if(e.key==='ArrowRight'||e.key.toLowerCase()==='n') next(); if(e.key==='ArrowLeft'||e.key.toLowerCase()==='p') prev(); }; window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); },[]);

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-6 w-full" style={{maxWidth:980}}>
            <div className="flex items-center justify-between">
              <h2 className="text-2xl font-bold">Bieler Method Lab</h2>
              <div className="flex gap-2">
                <button className={`btn ${mode==='vocab'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('vocab')}>Vocabulary</button>
                <button className={`btn ${mode==='concept'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('concept')}>Concept Check</button>
                <button className={`btn ${mode==='apply'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('apply')}>Applications</button>
              </div>
            </div>

            {mode==='vocab' && (
              <div className="mt-4">
                <div className="rounded-xl border-2 p-6 text-center">
                  <div className="text-xl font-bold">{BIELER_VOCAB[i].term}</div>
                  {show ? <div className="mt-2 ink700">{BIELER_VOCAB[i].def}</div> : <div className="muted italic">Press Reveal to show definition.</div>}
                </div>
                <div className="flex gap-2 mt-4 justify-center">
                  <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
                  <button className="btn btn-gray" onClick={prev}>Previous</button>
                  <button className="btn btn-purple" onClick={next}>Next</button>
                </div>
                <div className="text-xs muted mt-2 text-center">Card {i+1} / {BIELER_VOCAB.length}</div>
              </div>
            )}

            {mode==='concept' && (
              <div className="mt-4">
                <div className="muted text-sm mb-2">Score: {scoreC} / {answeredC}</div>
                <div className="text-lg font-semibold mb-2">{cq.prompt}</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  {cq.options.map((o,idx)=><button key={idx} className="btn btn-blue" onClick={()=>answerConcept(o)}>{o}</button>)}
                </div>
              </div>
            )}

            {mode==='apply' && (
              <div className="mt-4">
                <div className="muted text-sm mb-2">Score: {scoreA} / {answeredA}</div>
                <div className="text-lg font-semibold mb-2">Choose the best practice approach:</div>
                <div className="ink700 mb-3"><i>Scenario: </i>{aq.prompt}</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  {aq.options.map((o,idx)=><button key={idx} className="btn btn-blue" onClick={()=>answerApply(o)}>{o}</button>)}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* =========================================================
       Filters & Panels
    ========================================================== */
    const FiltersPanel = ({ prefs, setPrefs, stats, onResetStats, onExportCSV }) => {
      const f = prefs.filters;
      const toggle=(group,key)=>{
        setPrefs(p=>{ const next={...p, filters:{...p.filters, [group]:{...p.filters[group],[key]:!p.filters[group][key]}}}; savePrefs(next); return next; });
      };
      const setAll=(group,val)=>{
        setPrefs(p=>{ const obj=Object.fromEntries(Object.keys(p.filters[group]).map(k=>[k,val])); const next={...p, filters:{...p.filters, [group]:obj}}; savePrefs(next); return next; });
      };
      return (
        <div className="card rounded-xl p-4">
          <div className="flex flex-wrap items-center gap-3 justify-between">
            <div className="text-sm">Round:
              <select className="ml-2 border rounded p-1 text-sm" value={prefs.roundLen} onChange={e => { const n={...prefs, roundLen:Number(e.target.value)}; setPrefs(n); savePrefs(n); }}>
                {[120,180,240,300,360,420,480,540].map(x =>
                  <option key={x} value={x}>{x}s</option>
                )}
              </select>
            </div>
            <div className="flex flex-wrap gap-3 items-center">
              <label className="text-sm"><input type="checkbox" checked={prefs.adaptive} onChange={e=>{ const n={...prefs, adaptive:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Adaptive</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.coach} onChange={e=>{ const n={...prefs, coach:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Coach</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.coachRetry} onChange={e=>{ const n={...prefs, coachRetry:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Retry after miss</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.sound} onChange={e=>{ const n={...prefs, sound:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Sound</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.confetti} onChange={e=>{ const n={...prefs, confetti:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Confetti</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.callouts} onChange={e=>{ const n={...prefs, callouts:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Call-outs</label>
            </div>
            <div className="flex gap-2">
              <button className="btn btn-rose" onClick={onResetStats}>Reset All Stats</button>
              <button className="btn btn-green" onClick={onExportCSV}>Export CSV</button>
            </div>
          </div>

          <div className="grid md:grid-cols-3 gap-4 mt-4">
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Strings</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('strings',true)}>All</span> ¬∑ <span className="linkish" onClick={()=>setAll('strings',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {STRINGS.map(s=>(
                  <button key={s} className={`pill ${f.strings[s]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('strings',s)}>{s}</button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Positions</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('positions',true)}>All</span> ¬∑ <span className="linkish" onClick={()=>setAll('positions',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {POSITIONS.map(p=>(
                  <button key={p} className={`pill ${f.positions[p]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('positions',p)}>Pos {p}</button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Fingers</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('fingers',true)}>All</span> ¬∑ <span className="linkish" onClick={()=>setAll('fingers',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {FINGERS.map(fn=>(
                  <button key={fn} className={`pill ${f.fingers[fn]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('fingers',fn)}>F{fn}</button>
                ))}
              </div>
            </div>
          </div>

          <p className="text-xs muted mt-3">
            Focus Mode pulls only from your selected subset (falls back to all if deselected).
          </p>
        </div>
      );
    };

    /* =========================================================
       Dashboard extras: XP header, Avatar, Weakest 3, Sparkline, Badges
    ========================================================== */
    const AvatarIcon = ({ outfit='classic', trail='none' }) => {
      const outfitFill = outfit==='rock' ? '#ef4444' : outfit==='fantasy' ? '#22d3ee' : '#6d28d9';
      return (
        <svg className="avatar" viewBox="0 0 64 64">
          <rect x="0" y="0" width="64" height="64" rx="12" fill="rgba(0,0,0,0.04)" />
          <circle cx="32" cy="22" r="10" fill="#fed7aa"/>
          <rect x="16" y="34" width="32" height="18" rx="9" fill={outfitFill} />
          {trail==='aurora' && <circle cx="32" cy="54" r="4" fill="var(--accent)"><animate attributeName="r" values="4;6;4" dur="1.6s" repeatCount="indefinite"/></circle>}
        </svg>
      );
    };

    const AvatarCustomizer = () => {
      const [cos, setCos] = useState(loadJSON(COSMETICS_KEY, { selected:{ outfit:'classic', trail:'none' }, unlocked:{ outfits:['classic'], trails:['none'] } }));
      const save = (nx)=>{ setCos(nx); saveJSON(COSMETICS_KEY, nx); };
      const unlockBag = loadBadges();
      // unlockables from badges
      const unlocked = { ...cos.unlocked };
      if (unlockBag.earned['first-100'] && !unlocked.outfits.includes('rock')) unlocked.outfits.push('rock');
      if (unlockBag.earned['d-string-ace'] && !unlocked.outfits.includes('fantasy')) unlocked.outfits.push('fantasy');
      if (unlockBag.earned['perfect-20'] && !unlocked.trails.includes('aurora')) unlocked.trails.push('aurora');

      useEffect(()=>{ if (JSON.stringify(unlocked)!==JSON.stringify(cos.unlocked)) save({ ...cos, unlocked }); },[]);

      return (
        <div className="card rounded-xl p-4">
          <div className="flex items-center justify-between mb-2">
            <div className="font-semibold">Player Avatar</div>
            <div className="avatar-wrap"><AvatarIcon outfit={cos.selected.outfit} trail={cos.selected.trail}/></div>
          </div>
          <div className="text-xs avatar-label mb-2">Customize your look with unlocks from badges.</div>
          <div className="flex flex-wrap gap-2 items-center">
            {['classic','rock','fantasy'].map(o=>(
              <button key={o} disabled={!unlocked.outfits.includes(o)} className={`pill ${cos.selected.outfit===o?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>save({ ...cos, selected:{...cos.selected, outfit:o} })}>{o}</button>
            ))}
            <span className="text-xs mx-2 muted">Trail:</span>
            {['none','aurora'].map(t=>(
              <button key={t} disabled={!unlocked.trails.includes(t)} className={`pill ${cos.selected.trail===t?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>save({ ...cos, selected:{...cos.selected, trail:t} })}>{t}</button>
            ))}
          </div>
        </div>
      );
    };

    const Spark = ({ points }) => {
      if (!points || !points.length) return <div className="muted text-xs">No sessions yet.</div>;
      const w = 240, h = 40;
      const max = Math.max(...points, 1);
      const denom = Math.max(1, points.length - 1); // <-- fixes divide-by-zero
      const path = points.map((v, i) => {
        const x = i * (w / denom);
        const y = h - (v / max) * h;
        return `${i ? 'L' : 'M'}${x},${y}`;
      }).join(' ');
      return <svg width={w} height={h}><path d={path} fill="none" stroke="currentColor" strokeWidth="2" /></svg>;
    };

    const WeakestThreePanel = ({ stats, onDrill }) => {
      const toLB = (c,t)=> t? wilsonLowerBound(c,t) : 0;
      const list = Object.entries(stats).map(([k,v])=>({k, c:v.correct||0, t:v.total||0, lb:toLB(v.correct||0, v.total||0)}))
        .filter(x=>x.t>=5).sort((a,b)=>a.lb-b.lb).slice(0,3);
      if (!list.length) return null;
      return (
        <div className="card rounded-xl p-4">
          <div className="text-lg font-semibold mb-2">Top 3 Weakest Spots</div>
          <div className="grid gap-2">
            {list.map((it,i)=>{
              const [s,p,f] = it.k.split(':');
              return (
                <div key={i} className="flex items-center justify-between rounded border p-2">
                  <div>{fullLoc(s, Number(p), Number(f))} ¬∑ <span className="muted text-sm">LB {Math.round(it.lb*100)}% ¬∑ {it.c}/{it.t}</span></div>
                  <button className="btn btn-purple" onClick={()=>onDrill(s,Number(p),Number(f))}>Drill This</button>
                </div>
              );
            })}
          </div>
          <div className="text-xs muted mt-2">LB = 95% confidence lower bound. Each drill opens Speed Ladder focused on that cell.</div>
        </div>
      );
    };

    const BadgesPanel = () => {
      const bag = loadBadges();
      const earned = bag.earned || {};
      return (
        <div className="card rounded-xl p-4">
          <div className="text-lg font-semibold mb-2">Badges</div>
          <div className="flex flex-wrap gap-2">
            {BADGES.map(b=>{
              const on = !!earned[b.slug];
              return <span key={b.slug} className="badge" style={{opacity: on?1:0.35}} title={on?`Earned ${new Date(earned[b.slug]).toLocaleDateString()}`:'Not yet'}>{b.name}</span>;
            })}
          </div>
        </div>
      );
    };

    const ScoreHeader = () => {
      const sb = loadScoreboard();
      const lvl = sb.level||1; const next = sb.next||nextLevelXP(lvl);
      const curIn = sb.xp - nextLevelXP(lvl-1);
      const need = next - nextLevelXP(lvl-1);
      const pct = Math.max(0, Math.min(100, Math.round(100 * (curIn/need))));
      const st = loadStreak();
      const accentName = getAccent();
      return (
        <div className="card rounded-xl p-4 mb-4">
          <div className="flex items-center justify-between">
            <div>
              <div className="font-semibold">Level {lvl}</div>
              <div className="xpbar mt-1"><div className="xpbar-fill" style={{width:`${pct}%`}}/></div>
              <div className="text-xs muted mt-1">{sb.xp} XP ¬∑ {pct}% to next</div>
            </div>
            <div className="text-right">
              <div className="avatar-wrap justify-end">
                <AvatarIcon outfit={loadJSON(COSMETICS_KEY, {selected:{outfit:'classic',trail:'none'}}).selected.outfit}
                            trail={loadJSON(COSMETICS_KEY, {selected:{outfit:'classic',trail:'none'}}).selected.trail}/>
              </div>
              <div className="text-xs muted">Best streak: {st.best||0}</div>
              <div className="text-xs muted">Theme: {accentName}</div>
            </div>
          </div>
        </div>
      );
    };

    /* =========================================================
       Dashboard (complete)
    ========================================================== */
    const Dashboard = ({ go, prefs, setPrefs, stats, setStats }) => {
      const [helpKey, setHelpKey] = useState(null);
      const [theme, setThemeState] = useState(getTheme());
      const [updateReady, setUpdateReady] = useState(false);
      const [accent, setAccent] = useState(getAccent());
    
      // Registry
      const CARD_REGISTRY = {
        speed:           { title: "Speed Ladder",            desc: "Full ladder.",            open: () => go('speed'),         help: 'speed' },
        'speedbase':     { title: "Speed Ladder ‚Äî Core",     desc: "Base notes only.",        open: () => go('speedbase'),     help: 'speedbase' },
        flash:           { title: "Flashcards",              desc: "Study & recall.",         open: () => go('flash'),         help: 'cards' },
        bingo:           { title: "Positions Bingo",         desc: "5√ó5 practice board.",     open: () => go('bingo') },
        dice:            { title: "Dice of Destiny",         desc: "Random focused task.",    open: () => go('dice') },
        'tempo-trainer': { title: "Tempo Trainer",           desc: "Flashcards for tempi.",   open: () => go('tempo-trainer'), help: 'tempoTrainer' },
        'tempo-tester':  { title: "Tempo Tester",            desc: "Timed MCQ.",              open: () => go('tempo-tester'),  help: 'tempoTester' },
        height:          { title: "Finger Height Drill",     desc: "Low vs High.",            open: () => go('height'),        help: 'height' },
        locator:         { title: "Note Locator", desc: "Pick a valid location for a given pitch.", open: () => go('locator'), help: 'locator' },
        shift:            { title: "Shift Coach", desc: "Best landing spot on one string.",        open: () => go('shift'),   help: 'shift' },
        harmonics:        { title: "Harmonics Lab", desc: "Natural harmonic nodes per string.",  open: () => go('harmonics'), help: 'harmonics' },
        bieler:           { title: "Bieler Method Lab",       desc: "Concepts & apps.",        open: () => go('bieler'),        help: 'bielerLab' },
      };
    
      const DEFAULT_CARD_ORDER = [
        'speedbase','speed','flash','bingo','dice',
        'tempo-trainer','tempo-tester','height','locator','shift','harmonics','bieler'
      ];
      const CARD_ORDER_KEY = 'positionsQuest.dashboard.order.v1';
    
      const [order, setOrder] = useState(() => {
        const saved = loadJSON(CARD_ORDER_KEY, null);
        return Array.isArray(saved) && saved.length ? saved : DEFAULT_CARD_ORDER;
      });
      const saveOrder = (arr) => saveJSON(CARD_ORDER_KEY, arr);
    
      const move = (id, dir) => {
        setOrder(prev => {
          const ix = prev.indexOf(id); if (ix < 0) return prev;
          const j = Math.max(0, Math.min(prev.length - 1, ix + dir));
          const next = [...prev];
          const [it] = next.splice(ix, 1);
          next.splice(j, 0, it);
          saveOrder(next);
          return next;
        });
        const sr = document.getElementById('sr'); if (sr) sr.textContent = 'Card moved';
      };
    
      // keep order synced with registry
      useEffect(() => {
        const all = Object.keys(CARD_REGISTRY);
        setOrder(prev => {
          const merged = [
            ...prev.filter(id => all.includes(id)),
            ...all.filter(id => !prev.includes(id))
          ];
          if (merged.join('|') !== prev.join('|')) {
            saveOrder(merged);
            return merged;
          }
          return prev;
        });
      }, []);
    
      // Backup & Restore
      const backup = () => {
        const payload = {
          [THEME_KEY]: localStorage.getItem(THEME_KEY) || null,
          [THEME_ACCENT_KEY]: localStorage.getItem(THEME_ACCENT_KEY) || null,
          [PREFS_KEY]: loadJSON(PREFS_KEY, null),
          [STATS_KEY]: loadJSON(STATS_KEY, null),
          [BEST_KEY]: loadJSON(BEST_KEY, null),
          [TEMPO_STATS_KEY]: loadJSON(TEMPO_STATS_KEY, null),
          [TEMPO_BEST_KEY]: loadJSON(TEMPO_BEST_KEY, null),
          [SEYBOLD_KEY]: loadJSON(SEYBOLD_KEY, null),
          [SCORE_KEY]: loadJSON(SCORE_KEY, null),
          [BADGES_KEY]: loadJSON(BADGES_KEY, null),
          [PRESETS_KEY]: loadJSON(PRESETS_KEY, null),
          [SESSIONLOG_KEY]: loadJSON(SESSIONLOG_KEY, null),
          [HEIGHT_STATS_KEY]: loadJSON(HEIGHT_STATS_KEY, null),
          [LOCATOR_STATS_KEY]: loadJSON(LOCATOR_STATS_KEY, null),
          [SHIFT_STATS_KEY]: loadJSON(SHIFT_STATS_KEY, null),
          [HARM_STATS_KEY]: loadJSON(HARM_STATS_KEY, null),
          [COSMETICS_KEY]: loadJSON(COSMETICS_KEY, null),
          [SM2_KEY]: loadJSON(SM2_KEY, null),
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'vpq_backup.json';
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };
    
      const restore = async (file) => {
        try {
          const txt = await file.text();
          const obj = JSON.parse(txt);
          Object.entries(obj).forEach(([k, v]) => {
            if (v !== undefined && v !== null) {
              localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v));
            }
          });
          alert('Backup restored. The page will now reload to apply it.');
          location.reload();
        } catch (e) {
          alert('Import failed: ' + e.message);
        }
      };
      const inputRef = useRef(null);
    
      const exportCSV = () => {
        const rows = [['mode','key','correct','total','accuracy']];
        const packs = [
          ['speed', stats],
          ['height', loadJSON(HEIGHT_STATS_KEY, {})],
          ['locator', loadJSON(LOCATOR_STATS_KEY, {})],
          ['shift', loadJSON(SHIFT_STATS_KEY, {})],
          ['harmonics', loadJSON(HARM_STATS_KEY, {})],
        ];
        for (const [mode, obj] of packs) {
          Object.entries(obj || {}).forEach(([k, v]) => {
            if (v && typeof v === 'object') {
              if ('low' in v && 'high' in v) {
                ['low','high','natural'].forEach(h=>{
                  const c=v[h]?.correct||0, t=v[h]?.total||0, a=t? (c/t).toFixed(4):'0.0000';
                  rows.push([`${mode}:${h}`, k, c, t, a]);
                });
              } else {
                const c=v.correct||0, t=v.total||0, a=t? (c/t).toFixed(4):'0.0000';
                rows.push([mode, k, c, t, a]);
              }
            }
          });
        }
        const csv = rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
        const url = URL.createObjectURL(new Blob([csv], {type:'text/csv'}));
        const a = Object.assign(document.createElement('a'), {href:url, download:'positions_training_stats.csv'});
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };
    
      const resetAll = () => {
        if (!confirm('Reset all fingerboard stats & bests?')) return;
        localStorage.removeItem(BEST_KEY);
        localStorage.removeItem(STATS_KEY);
        localStorage.removeItem(HEIGHT_STATS_KEY);
        localStorage.removeItem(LOCATOR_STATS_KEY);
        localStorage.removeItem(SHIFT_STATS_KEY);
        localStorage.removeItem(HARM_STATS_KEY);
        setStats({});
        alert('Stats cleared.');
      };
    
      // SW update toast (safe if no SW)
      useEffect(() => {
        checkAwardBadges();
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.getRegistration().then(reg => {
            if (!reg) return;
            reg.addEventListener('updatefound', () => {
              const nw = reg.installing;
              nw?.addEventListener('statechange', () => {
                if (nw.state === 'installed' && navigator.serviceWorker.controller) {
                  setUpdateReady(true);
                }
              });
            });
          });
        }
      }, []);
    
      const toggleTheme = () => { const next = theme === 'light' ? 'dark' : 'light'; setTheme(next); setThemeState(next); };
      const changeAccent = (name) => { applyAccent(name); setAccent(name); };
    
      const goDrill = (s,p,f) => {
        const next = { ...prefs };
        next.filters = {
          strings:   Object.fromEntries(STRINGS.map(x => [x, x === s])),
          positions: Object.fromEntries(POSITIONS.map(x => [x, x === p])),
          fingers:   Object.fromEntries(FINGERS.map(x => [x, x === f])),
        };
        setPrefs(next); savePrefs(next);
        go('speed');
      };
    
      const sessions = loadJSON(SESSIONLOG_KEY, []);
      const speedPoints = sessions.filter(s=>s.mode==='speed' || s.mode==='speedbase').slice(-20).map(s=> (s.total? s.correct/s.total : 0.0));
      const tempoPoints = sessions.filter(s=>s.mode==='tempo').slice(-20).map(s=> (s.total? s.correct/s.total : 0.0));
    
      return (
        <div className="p-4">
          <header className="mb-4 flex items-center justify-between">
            <div>
              <div className="text-3xl font-bold">Violin Positions Quest</div>
              <div className="muted text-sm">Your daily mission to master the fingerboard‚Äîand beyond.</div>
            </div>
            <div className="flex items-center gap-2">
              <select className="border rounded p-2 text-sm" value={accent} onChange={e=>changeAccent(e.target.value)} title="Theme accent">
                <option value="symphony">Symphony Hall</option>
                <option value="rockstar">Rockstar</option>
                <option value="fantasy">Fantasy Quest</option>
                <option value="lofi">Lo-fi Studio</option>
              </select>
              <button className="btn btn-gray" onClick={toggleTheme}>{theme === 'dark' ? 'Light' : 'Dark'} Mode</button>
              <button className="btn btn-green" onClick={backup}>Backup</button>
              <button className="btn btn-blue" onClick={() => inputRef.current?.click()}>Restore</button>
              <input ref={inputRef} type="file" accept="application/json" hidden onChange={e=>e.target.files[0] && restore(e.target.files[0])}/>
            </div>
          </header>
    
          <ScoreHeader />
    
          {/* Toolbar above the grid */}
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm muted">Cards</div>
            <button
              className="btn btn-gray"
              onClick={() => { setOrder(DEFAULT_CARD_ORDER); saveOrder(DEFAULT_CARD_ORDER); }}
            >
              Reset Card Order
            </button>
          </div>
    
          {/* Cards grid */}
          <div className="grid-cards">
            {order.map(id => {
              const c = CARD_REGISTRY[id];
              if (!c) return null;
              return (
                <div key={id} className="relative">
                  <CardButton
                    title={c.title}
                    description={c.desc}
                    onClick={c.open}
                    onHelp={c.help ? () => setHelpKey(c.help) : undefined}
                  />
                  <div className="absolute right-3 top-3 flex gap-1">
                    <button className="pill" onClick={() => move(id, -1)} title="Move up">‚Üë</button>
                    <button className="pill" onClick={() => move(id, 1)}  title="Move down">‚Üì</button>
                  </div>
                </div>
              );
            })}
          </div>
    
          {/* Help modal */}
          <Modal open={!!helpKey} onClose={() => setHelpKey(null)} title="How to play">
            {HELP[helpKey] || 'Select a mode to begin.'}
          </Modal>
    
          <div className="grid lg:grid-cols-3 gap-4 mt-6">
            <div className="lg:col-span-2">
              <FiltersPanel
                prefs={prefs}
                setPrefs={setPrefs}
                stats={stats}
                onResetStats={resetAll}
                onExportCSV={exportCSV}
              />
              <div className="mt-4"><AccuracyHeatmap stats={stats} /></div>
            </div>
            <div className="space-y-4">
              <div className="card rounded-xl p-4">
                <div className="text-lg font-semibold mb-2">Recent Accuracy</div>
                <div className="text-xs muted mb-1">Speed Ladder (last 20)</div>
                <Spark points={speedPoints}/>
                <div className="text-xs muted mt-2">Tempo Tester (last 20)</div>
                <Spark points={tempoPoints}/>
              </div>
              <WeakestThreePanel stats={stats} onDrill={goDrill}/>
              <BadgesPanel/>
              <AvatarCustomizer/>
            </div>
          </div>
    
          <Toast open={updateReady} text="An update is ready." action="Reload" onAction={() => location.reload()} />
        </div>
      );
    };
    
    /* =========================================================
       App router + mount
    ========================================================== */
    // Router helpers
    const App = () => {
      const [view, setView] = React.useState('home');
    
      // global stats & prefs live here so games share them
      const [prefs, setPrefs] = React.useState(loadPrefs());
      const [stats, setStats] = React.useState(loadStats());
    
      const go = (name) => setView(name);
    
      const resetAllStats = () => {
        saveStats({});
        saveTempoStats({});
        saveJSON(HEIGHT_STATS_KEY, {});
        saveJSON(LOCATOR_STATS_KEY, {});
        saveJSON(SHIFT_STATS_KEY, {});
        saveJSON(HARM_STATS_KEY, {});
        setStats({});
      };
    
      const exportCSV = () => {
        const rows = [['key','correct','total']];
        const s = loadStats();
        Object.entries(s).forEach(([k,v]) => rows.push([k, v.correct||0, v.total||0]));
        const csv = rows.map(r => r.join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `vpq-stats-${new Date().toISOString().slice(0,10)}.csv`;
        a.click();
        URL.revokeObjectURL(url);
      };
    
      const CARD_REGISTRY = {
        speed:           { title: "Speed Ladder",         desc: "Full ladder.",            open: () => go('speed'),         help: 'speed' },
        'speedbase':     { title: "Speed Ladder ‚Äî Core",  desc: "Base notes only.",        open: () => go('speedbase'),     help: 'speedbase' },
        flash:           { title: "Flashcards",           desc: "Study & recall.",         open: () => go('flash'),         help: 'cards' },
        bingo:           { title: "Positions Bingo",      desc: "5√ó5 practice board.",     open: () => go('bingo') },
        dice:            { title: "Dice of Destiny",      desc: "Random focused task.",    open: () => go('dice') },
        'tempo-trainer': { title: "Tempo Trainer",        desc: "Flashcards for tempi.",   open: () => go('tempo-trainer'), help: 'tempoTrainer' },
        'tempo-tester':  { title: "Tempo Tester",         desc: "Timed MCQ.",              open: () => go('tempo-tester'),  help: 'tempoTester' },
        height:          { title: "Finger Height Drill",  desc: "Low vs High.",            open: () => go('height'),        help: 'height' },
        locator:         { title: "Note Locator",         desc: "Find valid locations.",    open: () => go('locator'),       help: 'locator' },
        shift:           { title: "Shift Coach",          desc: "Choose the landing.",      open: () => go('shift'),         help: 'shift' },
        harmonics:       { title: "Harmonics Lab",        desc: "Nodes & quick quiz.",      open: () => go('harmonics'),     help: 'harmonics' },
        bielerLab:       { title: "Bieler Method Lab",    desc: "Concepts & applications.", open: () => go('bielerLab'),     help: 'bielerLab' },
      };
    
      const DashboardShell = () => (
        <div className="p-4 max-w-6xl mx-auto">
          <ScoreHeader />
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <div className="lg:col-span-2 grid-cards">
              {Object.entries(CARD_REGISTRY).map(([key, cfg]) => (
                <CardButton
                  key={key}
                  title={cfg.title}
                  description={cfg.desc}
                  onClick={cfg.open}
                  onHelp={() => alert(HELP[cfg.help] || 'No help for this card yet.')}
                />
              ))}
            </div>
            <div className="grid gap-4">
              <FiltersPanel
                prefs={prefs}
                setPrefs={setPrefs}
                stats={stats}
                onResetStats={resetAllStats}
                onExportCSV={exportCSV}
              />
              <WeakestThreePanel stats={stats} onDrill={(s,p,f)=>{ setPrefs(pv => {
                const nf = { ...pv.filters };
                nf.strings = Object.fromEntries(STRINGS.map(x => [x, x===s]));
                nf.positions = Object.fromEntries(POSITIONS.map(x => [x, x===p]));
                nf.fingers = Object.fromEntries(FINGERS.map(x => [x, x===f]));
                const nx = { ...pv, filters: nf };
                savePrefs(nx);
                return nx;
              }); go('speed'); }} />
              <AvatarCustomizer />
              <BadgesPanel />
            </div>
          </div>
    
          <div className="mt-6">
            <AccuracyHeatmap stats={loadStats()} />
          </div>
        </div>
      );
    
      if (view === 'speed')       return <SpeedLadderGame onBack={()=>go('home')} prefs={prefs} stats={stats} setStats={setStats} mode="full" />;
      if (view === 'speedbase')   return <SpeedLadderGame onBack={()=>go('home')} prefs={prefs} stats={stats} setStats={setStats} mode="base" />;
      if (view === 'flash')       return <Flashcards onBack={()=>go('home')} />;
      if (view === 'bingo')       return <BingoBoard onBack={()=>go('home')} />;
      if (view === 'dice')        return <DiceOfDestinyGame onBack={()=>go('home')} />;
      if (view === 'tempo-trainer') return <TempoTrainer onBack={()=>go('home')} prefs={prefs} />;
      if (view === 'tempo-tester')  return <TempoTester onBack={()=>go('home')} prefs={prefs} />;
      if (view === 'height')      return <HeightDrill onBack={()=>go('home')} prefs={prefs} />;
      if (view === 'locator')     return <NoteLocator onBack={()=>go('home')} prefs={prefs} />;
      if (view === 'shift')       return <ShiftCoach onBack={()=>go('home')} prefs={prefs} />;
      if (view === 'harmonics')   return <HarmonicsLab onBack={()=>go('home')} prefs={prefs} />;
      if (view === 'bielerLab')   return <BielerLab onBack={()=>go('home')} />;
    
      return <DashboardShell />;
    };
    
    // Mount
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
  <script>
  (function () {
    if (!('serviceWorker' in navigator)) return;

    // If your site is at /violin-positions-quest/, leave this as-is.
    // If your site is at the domain root (custom domain or user site), use '' instead.
    const base = '/violin-positions-quest';

    navigator.serviceWorker.register(base + '/sw.js').then(reg => {
      // Auto-activate a newly installed worker
      if (reg.waiting) reg.waiting.postMessage('SKIP_WAITING');

      reg.addEventListener('updatefound', () => {
        const sw = reg.installing;
        if (!sw) return;
        sw.addEventListener('statechange', () => {
          if (sw.state === 'installed' && reg.waiting) {
            reg.waiting.postMessage('SKIP_WAITING');
          }
        });
      });

      // Reload the page when the new SW takes control
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        window.location.reload();
      });
    });
  })();
</script>
</body>
</html>