<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Mastery Quest ‚Äì Enhanced Trainer (v6)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#f8fafc;
      --card:#fff;
      --ink:#0f172a;
      --ink-light:#475569;
      --primary:#3a5ba0;
      --primary-dark:#2f4b7e;
      /* Accessible colours for feedback */
      --success:#009e73; /* green ‚Äì colour‚Äêblind friendly */
      --warning:#e69f00; /* orange ‚Äì high contrast */
      --danger:#d55e00; /* red/orange ‚Äì avoids pure red */
      --neutral:#6c757d; /* mid grey */
      --border:rgba(0,0,0,0.1);
    }
    :root.dark {
      --bg:#0b1426;
      --card:#0f1f3d;
      --ink:#e2e8f0;
      --ink-light:#94a3b8;
		  --primary:#4a78b6;
		  --primary-dark:#355a8a;
      --success:#00b58a;
      --warning:#f3ae3d;
      --danger:#d5672f;
      --neutral:#6b7280;
      --border:rgba(255,255,255,0.15);
    }
    body { margin:0; font-family: 'Inter', sans-serif; background:var(--bg); color:var(--ink); padding-bottom:60px; }
    .container { max-width: 960px; margin:auto; padding:1rem; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:1rem 1.5rem; margin-bottom:1.5rem; box-shadow:0 4px 20px rgba(0,0,0,0.05); }
    .btn { display:inline-flex; align-items:center; justify-content:center; padding:0.6rem 1rem; border-radius:9999px; margin:0.25rem; border:none; font-weight:600; cursor:pointer; color:#fff; }
    .btn-primary { background:var(--primary); }
    .btn-primary:hover { background:var(--primary-dark); }
    .btn-secondary { background:var(--ink-light); }
    .btn-secondary:hover { background:var(--ink); }
    .btn-success { background:var(--success); }
    .btn-warning { background:var(--warning); }
    .btn-danger { background:var(--danger); }
    .grid { display:grid; gap:1rem; }
    @media(min-width:640px){ .grid-cols-2 { grid-template-columns: repeat(2,1fr); } }
    .heat-cell { height:2rem; display:flex; align-items:center; justify-content:center; font-size:0.7rem; color:#fff; border-radius:4px; }
    .option-btn { width:100%; padding:0.6rem; border-radius:9999px; margin:0.25rem 0; color:#fff; border:none; cursor:pointer; font-weight:600; }
    .btn:focus-visible, .option-btn:focus-visible { outline:3px solid var(--primary); outline-offset:2px; }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    @media (prefers-reduced-motion: reduce) {
		  * { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; }
		}
  </style>
  <script>
    (function(){
      const KEY='vmq.theme';
      const saved=localStorage.getItem(KEY);
      window.speakSR = (txt) => {
			  const el = document.getElementById('sr');
			  if (el) el.textContent = txt;
			};
      const prefers=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const dark=saved? saved==='dark':prefers;
      document.documentElement.classList.toggle('dark', dark);
      window.__setTheme=(d)=>{ localStorage.setItem(KEY,d?'dark':'light'); document.documentElement.classList.toggle('dark', d); };
    })();
  </script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <div id="sr" class="sr-only" aria-live="polite"></div>
  <script type="text/babel" data-presets="react">
    // This is the enhanced VMQ v6 implementation. See explanation in commit description.
    // Helpers
    function speak(text, { rate = 0.9, pitch = 1, lang, voiceName } = {}) {
      try {
        if (!text) return;
        const synth = window.speechSynthesis;
        const Utterance = window.SpeechSynthesisUtterance;
        if (!synth || !Utterance) return;
        let voices = [];
        try {
          voices = synth.getVoices?.() || [];
          if (typeof synth.onvoiceschanged === 'undefined') {
            void voices.length;
          }
        } catch {}
        const u = new Utterance(String(text));
        u.rate = rate;
        u.pitch = pitch;
        if (lang) u.lang = lang;
        if (voiceName && Array.isArray(voices)) {
          const v = voices.find(v => v.name === voiceName);
          if (v) u.voice = v;
        }
        try { synth.cancel(); } catch {}
        synth.speak(u);
      } catch {}
    }
    const loadJSON=(k,fb)=>{ try{ const v=JSON.parse(localStorage.getItem(k)); return v ?? fb; }catch{return fb;} };
    const saveJSON=(k,v)=>{ try{ localStorage.setItem(k,JSON.stringify(v)); }catch{} };
    // Violin constants
    const STRINGS=['G','D','A','E'];
    const POSITIONS=[1,2,3,4,5];
    const FINGERS=[1,2,3,4];
    const OPEN_PC={G:7,D:2,A:9,E:4};
    const BASE_OFF={1:2,2:4,3:5,4:7};
    const POS_SHIFT={1:0,2:2,3:3,4:5,5:7};
    const NOTE_NAME={0:'C',1:'Db',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};
    const NOTE_TO_PC=Object.fromEntries(Object.entries(NOTE_NAME).map(([k,v]) => [v, Number(k)]));
    const MIDI_BASE={ G:55, D:62, A:69, E:76 };
    // Basic audio engine
    class AudioEngine{
      constructor(){ this.ctx=null; this.mute=loadJSON('vmq.v4.mute',false); }
      ensure(){ if(!this.ctx) this.ctx=new (window.AudioContext||window.webkitAudioContext)(); if(this.ctx.state==='suspended') this.ctx.resume(); return this.ctx; }
      playNote({midi,durationMs=800}){ if(this.mute) return; const ctx=this.ensure(); const now=ctx.currentTime; const freq=440*Math.pow(2,(midi-69)/12); const osc=ctx.createOscillator(); const gain=ctx.createGain(); osc.frequency.value=freq; osc.type='sine'; gain.gain.setValueAtTime(0,now); gain.gain.linearRampToValueAtTime(0.8,now+0.01); gain.gain.exponentialRampToValueAtTime(0.1,now+durationMs/1000*0.8); gain.gain.linearRampToValueAtTime(0,now+durationMs/1000); osc.connect(gain); gain.connect(ctx.destination); osc.start(now); osc.stop(now+durationMs/1000); osc.onended=()=>{ try{osc.disconnect(); gain.disconnect();}catch{} }; }
      playInterval({rootMidi,semitones,gapMs=150,durationMs=600}){ if(this.mute) return; const ctx=this.ensure(); const t0=ctx.currentTime+0.01; const note=(midi,t)=>{ const osc=ctx.createOscillator(); const g=ctx.createGain(); osc.type='sine'; osc.frequency.value=440*Math.pow(2,(midi-69)/12); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.8,t+0.01); g.gain.exponentialRampToValueAtTime(0.1,t+durationMs/1000*0.8); g.gain.linearRampToValueAtTime(0,t+durationMs/1000); osc.connect(g); g.connect(ctx.destination); osc.start(t); osc.stop(t+durationMs/1000); osc.onended=()=>{ try{osc.disconnect(); g.disconnect();}catch{} }; }; note(rootMidi,t0); note(rootMidi+semitones,t0+gapMs/1000); }
      setMute(m){ this.mute=m; saveJSON('vmq.v4.mute',m); }
      playFeedback(ok){ if(this.mute) return; const ctx=this.ensure(); const now=ctx.currentTime; const freq=ok ? 880 : 220; const osc=ctx.createOscillator(); const gain=ctx.createGain(); osc.frequency.value=freq; osc.type='square'; gain.gain.setValueAtTime(0,now); gain.gain.linearRampToValueAtTime(0.3,now+0.01); gain.gain.linearRampToValueAtTime(0,now+0.2); osc.connect(gain); gain.connect(ctx.destination); osc.start(now); osc.stop(now+0.2); osc.onended=()=>{ try{osc.disconnect(); gain.disconnect();}catch{} }; }
    }
    const audioEngine=new AudioEngine();
    window.addEventListener('pointerdown', () => { try{audioEngine.ensure();}catch{} }, { once:true });
    const canonicalBase=(s,p,f)=>{ const semi=OPEN_PC[s]+POS_SHIFT[p]+BASE_OFF[f]; return NOTE_NAME[((semi%12)+12)%12]; };
    const CELLS=[]; for(const s of STRINGS) for(const p of POSITIONS) for(const f of FINGERS){ CELLS.push({s,p,f,canon:canonicalBase(s,p,f)}); }
    const XP_KEY='vmq.v4.xp';
    const STATS_KEY='vmq.v4.stats';
    const PREFS_KEY='vmq.v4.prefs';
    const FLASH_SIG_KEY='vmq.v4.flashcards.sig';
    const FLASH_KEY='vmq.v4.flashcards';
    const levelForXP=(xp)=>Math.floor(Math.pow(xp/300,0.75))+1;
    const nextLevelXP=(lvl)=>Math.round(300*Math.pow(lvl,1.4));
    const addXP=(amt)=>{ const xp=loadJSON(XP_KEY,0)+amt; saveJSON(XP_KEY,xp); return xp; };
    const updateStat=(key,ok)=>{ const stats=loadJSON(STATS_KEY,{}); const st=stats[key]||{correct:0,total:0}; st.total+=1; if(ok) st.correct+=1; stats[key]=st; saveJSON(STATS_KEY,stats); };
    const shuffle=a=>{ const arr=[...a]; for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; };
    const getRandom=a=>a[Math.floor(Math.random()*a.length)];
    const ordinal=n=>{ const s=['th','st','nd','rd'],v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]); };
    // Event log helpers
    const EVENT_LOG_KEY='vmq.v5.events';
    function logEvent(evt){ const arr=loadJSON(EVENT_LOG_KEY,[]); arr.unshift(evt); saveJSON(EVENT_LOG_KEY,arr.slice(0,300)); }
    function makeItemId(parts){ return parts.join('|'); }
    function useLatencyTracker(deps=[]){ const ref=React.useRef(null); const markShown=React.useCallback(()=>{ ref.current=performance.now(); },[]); const getLatency=React.useCallback(()=>{ if(!ref.current) return null; return performance.now()-ref.current; },[]); React.useEffect(()=>{ markShown(); },deps); return { markShown, getLatency }; }
    const defaultPrefs={ strings:Object.fromEntries(STRINGS.map(s=>[s,true])), positions:Object.fromEntries(POSITIONS.map(p=>[p,true])), flashLevel:'Professional', difficultyMode:'Auto', practiceMode:'Focus', feedbackMode:'Audio+Visual' };
    const FLASH_DURATIONS={ Beginner:3000, Intermediate:2000, Advanced:1200, Professional:800, Master:500 };
    const filteredCells=prefs=>CELLS.filter(c=>prefs.strings[c.s]&&prefs.positions[c.p]);
    function isTroubleItem(itemId, threshold=3){ const evts=loadJSON(EVENT_LOG_KEY,[]); const recent=evts.filter(e=>e.itemId===itemId).slice(0,threshold); if(recent.length<threshold) return false; return recent.filter(e=>!e.correct).length>=threshold-1; }
    function ReflectionPrompt({reason,onClose}){ const [note,setNote]=React.useState(''); return <div className="card" style={{marginTop:'0.75rem', borderStyle:'dashed'}}><p style={{fontWeight:600}}>Quick reflection</p><p style={{fontSize:'0.9rem', color:'var(--ink-light)'}}>{reason}</p><textarea rows={3} style={{width:'100%', marginTop:'0.5rem'}} placeholder="What makes this challenging?" value={note} onChange={e=>setNote(e.target.value)} /><button className="btn btn-primary" onClick={()=>{ const list=loadJSON('vmq.v5.reflections',[]); list.unshift({ts:Date.now(), reason, note:note||'(no comment)'}); saveJSON('vmq.v5.reflections',list.slice(0,200)); onClose(); }}>Save reflection</button></div>; }
    // PillToggle and OptionButton
    function OptionButton({label,selected,onClick,shortcut,...rest}){ const bg=selected?'var(--primary-dark)':'var(--primary)'; return <button type="button" className="option-btn" role="button" aria-keyshortcuts={shortcut??''} style={{background:bg}} onClick={onClick} {...rest}>{label}{shortcut?<span className="sr-only"> (Shortcut {shortcut})</span>:null}</button>; }
    function PillToggle({label,pressed,onClick,...rest}){ const bg=pressed?'var(--primary-dark)':'var(--primary)'; return <button type="button" className="option-btn" aria-pressed={!!pressed} style={{background:bg}} onClick={onClick} {...rest}>{label}</button>; }
    // Hotkeys simplified for brevity
    function useAnswerHotkeys(enabled,onIndex,onBack,count=4){ const cursorRef=React.useRef(-1); React.useEffect(()=>{ if(!enabled) return; const handler=(e)=>{ const t=e.target; const tag=(t&&t.tagName||'').toLowerCase(); if(tag==='input'||tag==='select'||tag==='textarea'||(t&&t.isContentEditable)) return; const k=e.key; const max=(count??4)-1; let handled=false; if(k>='1' && k<='9'){ const idx=Number(k)-1; if(idx<=max){ cursorRef.current=idx; onIndex(idx); handled=true; } }else if(k==='Enter'){ cursorRef.current=0; onIndex(0); handled=true; }else if(k==='Escape'){ onBack(); handled=true; } if(handled){ e.preventDefault(); e.stopPropagation(); } }; window.addEventListener('keydown',handler); return ()=>window.removeEventListener('keydown',handler); },[enabled,onIndex,onBack,count]); React.useEffect(()=>{ cursorRef.current=-1; },[enabled,count]); }
    // Study modules
    function SpeedDrill({prefs,onBack}){
      const cells=React.useMemo(()=>filteredCells(prefs),[prefs]); const [stats,setStats]=React.useState(()=>loadJSON(STATS_KEY,{})); const [score,setScore]=React.useState(0); const [answered,setAnswered]=React.useState(0); const [paused,setPaused]=React.useState(false); const [time,setTime]=React.useState(90); const [q,setQ]=React.useState(null); const [selected,setSelected]=React.useState(null);
      const effectiveTime=React.useMemo(()=>{ if(prefs.difficultyMode==='Easy') return 120; if(prefs.difficultyMode==='Hard') return 60; if(answered>=10){ const acc=score/Math.max(1,answered); if(acc>0.85) return 60; if(acc<0.55) return 120; } return 90; },[prefs.difficultyMode,answered,score]); React.useEffect(()=>setTime(effectiveTime),[effectiveTime]);
      const pick=React.useCallback((statsArg)=>{ if(!cells.length){ setQ(null); return; } const sstats=statsArg ?? stats; const weight=c=>{ const k=`${c.s}:${c.p}:${c.f}`; const st=sstats[k]||{correct:0,total:0}; const acc=st.total? st.correct/st.total:0; return 1-acc+0.05; }; const total=cells.reduce((sum,c)=>sum+weight(c),0); let r=Math.random()*total; let chosen=cells[cells.length-1]; for(const c of cells){ r-=weight(c); if(r<=0){ chosen=c; break; } } const correct=chosen.canon; const pool=[...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct); const optionCount = prefs.practiceMode==='Focus'?3:4; const opts=shuffle([correct,...shuffle(pool).slice(0,optionCount-1)]); setQ({cell:chosen,options:opts}); setSelected(null); try{ const midi=MIDI_BASE[chosen.s]+POS_SHIFT[chosen.p]+BASE_OFF[chosen.f]; if(prefs.feedbackMode!=='Visual Only') audioEngine.playNote({midi}); }catch{} },[cells,stats,prefs]); React.useEffect(()=>{ pick(); },[cells]); React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]); const answer=(opt,idx)=>{ if(selected!==null) return; setSelected(idx); setTimeout(()=>{ const ok=opt===q.cell.canon; speakSR(ok?'Correct, great job!':'Oops, almost!'); audioEngine.playFeedback(ok); setAnswered(a=>a+1); if(ok) setScore(s=>s+1); setStats(prev=>{ const k=`${q.cell.s}:${q.cell.p}:${q.cell.f}`; const st=prev[k]||{correct:0,total:0}; const next={...prev,[k]:{correct:st.correct+(ok?1:0),total:st.total+1}}; saveJSON(STATS_KEY,next); setTimeout(()=>pick(next),0); return next; }); addXP(ok?8:2); },200); }; useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);
      if(time===0) return <div className="card"><h2>Speed Drill Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      if(!cells.length) return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return <div><div className="card"><h2>Speed Drill</h2><p>{prefs.practiceMode==='Focus'? 'Practice' : 'Time'} {prefs.practiceMode==='Focus'? '' : `${time}s |`} Score {score}/{answered}</p><button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>{q&&(<div><p>What is the base note at <strong>{ordinal(q.cell.p)} pos, {ordinal(q.cell.f)} finger on {q.cell.s}</strong>?</p><div role="radiogroup" aria-label="Answer choices">{q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)} />))}</div></div>)}</div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
    }
    function Flashcards({prefs,onBack}){ const buildCards=React.useCallback(()=>{ const cells=filteredCells(prefs); const cards=[]; cells.forEach(c=>{ cards.push({type:'cell', q:`Note at ${ordinal(c.p)} pos, ${ordinal(c.f)} finger on ${c.s}`, a:c.canon, interval:1, due:Date.now(), ease:2.5, reps:0, lastLatency:null}); }); const unique=[...new Set(cells.map(c=>c.canon))]; unique.forEach(n=>{ cards.push({type:'note', q:`Locations for note ${n}?`, a:n, interval:1, due:Date.now(), ease:2.5, reps:0, lastLatency:null}); }); return cards; },[prefs]); const [deck,setDeck]=React.useState(()=>{ const saved=loadJSON(FLASH_KEY,null); const savedSig=localStorage.getItem(FLASH_SIG_KEY); const curSig=JSON.stringify({strings:prefs.strings,positions:prefs.positions}); if(saved && savedSig===curSig) return saved; const cards=buildCards(); saveJSON(FLASH_KEY,cards); localStorage.setItem(FLASH_SIG_KEY,curSig); return cards; }); React.useEffect(()=>{ const curSig=JSON.stringify({strings:prefs.strings,positions:prefs.positions}); const savedSig=localStorage.getItem(FLASH_SIG_KEY); if(curSig!==savedSig){ const cards=buildCards(); saveJSON(FLASH_KEY,cards); localStorage.setItem(FLASH_SIG_KEY,curSig); setDeck(cards); } },[prefs,buildCards]); const [card,setCard]=React.useState(null); const [show,setShow]=React.useState(false); const latencyRef=React.useRef(null); const pick=()=>{ if(!deck.length){ setCard(null); return; } const now=Date.now(); const due=deck.filter(c=>c.due<=now).sort((a,b)=>a.due-b.due); const next= due.length? due[0] : getRandom(deck); setCard(next); setShow(false); latencyRef.current=performance.now(); }; React.useEffect(()=>{ pick(); },[deck]); const mark=(known)=>{ const latency=performance.now()-(latencyRef.current||performance.now()); setDeck(prev=>{ const upd=prev.map(c=>{ if(c===card){ let ease=c.ease??2.5; let interval=c.interval??1; const reps=(c.reps??0)+1; if(!known){ ease=Math.max(1.3,ease-0.3); interval=1; } else { if(latency<1200) ease+=0.1; else if(latency>3500) ease-=0.1; ease=Math.min(3.5,Math.max(1.3,ease)); if(reps===1) interval=1; else if(reps===2) interval=3; else interval=Math.round(interval*ease); interval=Math.min(60,Math.max(1,interval)); } const nextDue=Date.now()+interval*86400000; logEvent({ts:Date.now(),module:'Flashcards',itemId:makeItemId([c.type,c.a]),correct:known,latencyMs:latency}); return {...c, interval, ease, reps, due:nextDue, lastLatency:latency}; } return c; }); saveJSON(FLASH_KEY,upd); return upd; }); addXP(known?5:1); speakSR(known?'Correct, great job!':'Oops, almost!'); audioEngine.playFeedback(known); pick(); }; if(!deck.length) return <div className="card"><h2>No cards</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; return <div><div className="card"><h2>Flashcards</h2>{card && (<div><p>{card.q}</p>{show ? <p style={{fontWeight:'bold',fontSize:'1.4rem'}}>{card.a}</p> : <button className="btn btn-primary" onClick={()=>setShow(true)}>Reveal</button>}{show && (<div style={{marginTop:'0.5rem'}}><button className="btn btn-success" onClick={()=>mark(true)}>I knew it</button><button className="btn btn-secondary" onClick={()=>mark(false)}>I forgot</button></div>)}</div>)}</div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; }
    function Snapshot({prefs,onBack}){ const cells=filteredCells(prefs); const [time,setTime]=React.useState(60); const [paused,setPaused]=React.useState(false); const [score,setScore]=React.useState(0); const [answered,setAnswered]=React.useState(0); const [state,setState]=React.useState('flash'); const [flash,setFlash]=React.useState(null); const [q,setQ]=React.useState(null); const [selected,setSelected]=React.useState(null); const flashRef=React.useRef(null); const pick=()=>{ if(!cells.length){ setState('none'); return; } const s=getRandom(STRINGS.filter(s=>prefs.strings[s])); const p=getRandom(POSITIONS.filter(p=>prefs.positions[p])); const labels={}; FINGERS.forEach(f=>{ labels[f]=canonicalBase(s,p,f); }); setFlash({s,p,labels}); setState('flash'); setSelected(null); if(flashRef.current) clearTimeout(flashRef.current); const prefersReduced=window.matchMedia&&window.matchMedia('(prefers-reduced-motion: reduce)').matches; const delay=(FLASH_DURATIONS[prefs.flashLevel]||1000)*(prefersReduced?1.5:1); flashRef.current=setTimeout(()=>{ const f=getRandom(FINGERS); const correct=labels[f]; const opts=shuffle([correct,...shuffle([...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct)).slice(0,(prefs.practiceMode==='Focus'?2:3))]); setQ({s,p,f,correct,options:opts}); setState('question'); setSelected(null); try{ const midi=MIDI_BASE[s]+POS_SHIFT[p]+BASE_OFF[f]; if(prefs.feedbackMode!=='Visual Only') audioEngine.playNote({midi}); }catch{} },delay); }; React.useEffect(()=>{ pick(); return ()=>{ if(flashRef.current){ clearTimeout(flashRef.current); flashRef.current=null; } }; },[]); React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]); const answer=(opt,idx)=>{ if(selected!==null) return; setSelected(idx); setTimeout(()=>{ const ok=opt===q.correct; speakSR(ok?'Correct, great job!':'Oops, almost!'); audioEngine.playFeedback(ok); setAnswered(a=>a+1); if(ok) setScore(s=>s+1); updateStat(`${q.s}:${q.p}:${q.f}`,ok); addXP(ok?6:2); pick(); },200); }; useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4); if(time===0) return <div className="card"><h2>Snapshot Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; if(state==='none') return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; return <div><div className="card"><h2>Snapshot</h2><p>{prefs.practiceMode==='Focus'? 'Practice' : 'Time'} {prefs.practiceMode==='Focus'? '' : `${time}s |`} Score {score}/{answered}</p><button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>{state==='flash'&&flash&&(<div><p>Memorize {flash.s} string {ordinal(flash.p)} pos:</p><div className="grid grid-cols-2">{FINGERS.map(f=>(<div key={f} className="card" style={{padding:'0.5rem',textAlign:'center',borderRadius:'8px'}}><small>F{f}</small><br/><strong>{flash.labels[f]}</strong></div>))}</div><button className="btn btn-primary" onClick={()=>{ if(flashRef.current){ clearTimeout(flashRef.current); flashRef.current=null; } const s=flash.s; const p=flash.p; const f=getRandom(FINGERS); const correct=flash.labels[f]; const opts=shuffle([correct,...shuffle([...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct)).slice(0,(prefs.practiceMode==='Focus'?2:3))]); setQ({s,p,f,correct,options:opts}); setState('question'); setSelected(null); try{ const midi=MIDI_BASE[s]+POS_SHIFT[p]+BASE_OFF[f]; if(prefs.feedbackMode!=='Visual Only') audioEngine.playNote({midi}); }catch{} }}>Ready</button></div>)}}{state==='question'&&q&&(<div><p>Which base note is F{q.f} at {ordinal(q.p)} pos on {q.s}?</p><div role="radiogroup" aria-label="Answer choices">{q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)} />))}</div></div>)}
            </div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
    }
    function NoteLocator({prefs,onBack}){ const [time,setTime]=React.useState(60); const [paused,setPaused]=React.useState(false); const [score,setScore]=React.useState(0); const [answered,setAnswered]=React.useState(0); const [q,setQ]=React.useState(null); const [selected,setSelected]=React.useState(null); const [showReflect,setShowReflect]=React.useState(false); const [reflectReason,setReflectReason]=React.useState(''); const pick=()=>{ const strings=STRINGS.filter(s=>prefs.strings[s]); const pos=POSITIONS.filter(p=>prefs.positions[p]); if(!strings.length||!pos.length){ setQ(null); return; } const cells=CELLS.filter(c=>prefs.strings[c.s]&&prefs.positions[c.p]); const chosen=getRandom(cells); const note=chosen.canon; const correct={s:chosen.s,p:chosen.p,f:chosen.f}; const samePitch=cells.filter(c=>c.canon===note && !(c.s===correct.s && c.p===correct.p && c.f===correct.f)); const distract=samePitch.length>=3? shuffle(samePitch).slice(0,3) : shuffle(cells.filter(c=>c.canon!==note)).slice(0,3); const opts=shuffle([{...correct},...distract.map(c=>({s:c.s,p:c.p,f:c.f}))]).slice(0,prefs.practiceMode==='Focus'?3:4); setQ({note,correct,options:opts}); setSelected(null); }; React.useEffect(()=>{ pick(); },[]); React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]); const answer=(opt,idx)=>{ if(selected!==null) return; setSelected(idx); const ok=opt.s===q.correct.s && opt.p===q.correct.p && opt.f===q.correct.f; setQ(prev=>prev && { ...prev, feedback: prev.options.map(o=>{ const isCorrect=(o.s===prev.correct.s && o.p===prev.correct.p && o.f===prev.correct.f); const isChosen=(o.s===opt.s && o.p===opt.p && o.f===opt.f); return {...o, kind:isCorrect?'correct':isChosen?'chosen':'distractor'}; }) }); setTimeout(()=>{ speakSR(ok?'Correct, great job!':'Oops, almost!'); audioEngine.playFeedback(ok); setAnswered(a=>a+1); if(ok) setScore(s=>s+1); updateStat(`${q.correct.s}:${q.correct.p}:${q.correct.f}`,ok); addXP(ok?4:1); const itemId=makeItemId(['cell',q.correct.s,q.correct.p,q.correct.f]); logEvent({ts:Date.now(),module:'NoteLocator',itemId,correct:ok,latencyMs:null}); if(!ok && isTroubleItem(itemId)){ setReflectReason(`Think about where ${q.note} lives`); setShowReflect(true); } pick(); },450); }; useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4); if(time===0) return <div className="card"><h2>Note Locator Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; if(!q) return <div className="card"><h2>No valid notes</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; return <div><div className="card"><h2>Note Locator</h2><p>{prefs.practiceMode==='Focus'? 'Practice' : 'Time'} {prefs.practiceMode==='Focus'? '' : `${time}s |`} Score {score}/{answered}</p><button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button><p>Where can you play {q.note}? Click the fingerboard:</p><VisualFingerboard highlight={(q.feedback||q.options).map(o=>({ s:o.s,p:o.p,f:o.f,kind:o.kind||'distractor' }))} disabled={!!q.feedback} onSelect={(cell)=>answer(cell,0)} /><div style={{display:'flex',gap:'0.75rem',alignItems:'center',marginTop:'0.5rem',flexWrap:'wrap',fontSize:'0.75rem',color:'var(--ink-light)'}}><span style={{display:'flex',alignItems:'center',gap:'0.25rem'}}><span style={{display:'inline-block',background:'var(--success)',color:'var(--card)',borderRadius:'3px',padding:'0 4px',fontWeight:'bold'}}>‚úì</span>Correct</span><span style={{display:'flex',alignItems:'center',gap:'0.25rem'}}><span style={{display:'inline-block',background:'var(--primary)',color:'var(--card)',borderRadius:'3px',padding:'0 4px',fontWeight:'bold'}}>‚úï</span>Your choice</span><span style={{display:'flex',alignItems:'center',gap:'0.25rem'}}><span style={{display:'inline-block',background:'var(--warning)',borderRadius:'3px',padding:'0 4px',backgroundImage:'linear-gradient(45deg, var(--warning) 25%, var(--card) 25%, var(--card) 50%, var(--warning) 50%, var(--warning) 75%, var(--card) 75%, var(--card) 100%)',backgroundSize:'8px 8px',height:'1em',width:'1em'}}></span>Available option</span></div>{showReflect && <ReflectionPrompt reason={reflectReason} onClose={()=>setShowReflect(false)} />}</div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; }
    function Settings({prefs,setPrefs,onBack}){ const [muted,setMuted]=React.useState(audioEngine.mute); const toggle=(type,key)=>{ setPrefs(prev=>{ const copy={...prev,[type]:{...prev[type],[key]:!prev[type][key]}}; saveJSON(PREFS_KEY,copy); return copy; }); }; const setModePref=(key,value)=>{ setPrefs(prev=>{ const next={...prev,[key]:value}; saveJSON(PREFS_KEY,next); return next; }); }; return <div><div className="card"><h2>Settings</h2><h3>Theme</h3><button className="btn btn-primary" onClick={()=>{ const dark=!document.documentElement.classList.contains('dark'); window.__setTheme(dark); }}>Toggle Dark Mode</button><h3>Strings</h3><div>{STRINGS.map(s=>(<PillToggle key={s} label={s} pressed={prefs.strings[s]} onClick={()=>toggle('strings',s)} />))}</div><h3>Positions</h3><div>{POSITIONS.map(p=>(<PillToggle key={p} label={p} pressed={prefs.positions[p]} onClick={()=>toggle('positions',p)} />))}</div><h3>Snapshot Flash Duration</h3><div>{Object.keys(FLASH_DURATIONS).map(level=>(<PillToggle key={level} label={level} pressed={prefs.flashLevel===level} onClick={()=>setModePref('flashLevel',level)} />))}</div><h3>Difficulty</h3><div>{['Easy','Auto','Hard'].map(m=>(<PillToggle key={m} label={m} pressed={prefs.difficultyMode===m} onClick={()=>setModePref('difficultyMode',m)} />))}</div><h3>Practice Mode</h3><div>{['Focus','Challenge'].map(m=>(<PillToggle key={m} label={m} pressed={prefs.practiceMode===m} onClick={()=>setModePref('practiceMode',m)} />))}</div><h3>Feedback Mode</h3><div>{['Audio+Visual','Audio Only','Visual Only'].map(m=>(<PillToggle key={m} label={m} pressed={prefs.feedbackMode===m} onClick={()=>setModePref('feedbackMode',m)} />))}</div><p style={{marginTop:'1rem',color:'var(--ink-light)'}}>Select strings and positions for drills. Adjust challenge and feedback to match your goals.</p><h3>Audio</h3><button className="btn btn-primary" onClick={()=>audioEngine.ensure()}>Enable Sound</button><button className="btn" style={{background: muted ? 'var(--danger)' : 'var(--primary)'}} onClick={()=>{ audioEngine.setMute(!muted); setMuted(!muted); }}>{muted?'Unmute':'Mute'}</button></div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; }
    function StatsPage({onBack}){ const stats=loadJSON(STATS_KEY,{}); const xp=loadJSON(XP_KEY,0); const lvl=levelForXP(xp); const prev=lvl>1? nextLevelXP(lvl-1):0; const nxt=nextLevelXP(lvl); const pct=Math.max(0,Math.min(1, isFinite((xp-prev)/(nxt-prev)) ? (xp-prev)/(nxt-prev) : 0)); const isCellKey=k=>{ const parts=k.split(':'); return parts.length===3 && STRINGS.includes(parts[0]) && POSITIONS.includes(Number(parts[1])) && FINGERS.includes(Number(parts[2])); }; const filteredStats=Object.fromEntries(Object.entries(stats).filter(([k,_])=>isCellKey(k))); return <div><div className="card"><h2>Your Progress</h2><p>Level {lvl} (XP {xp-prev}/{nxt-prev})</p><div className="progress-bar" style={{height:'8px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden'}}><div style={{height:'100%',width:`${pct*100}%`,background:'var(--primary)'}}></div></div><p style={{marginTop:'0.5rem'}}>Badges: <span aria-label={`Level ${lvl} badges`} title={`Level ${lvl}`}>{'‚≠ê'.repeat(Math.min(10,lvl))}{lvl>10? ` √ó${lvl}`:''}</span></p></div>{STRINGS.map(s=>(<div className="card" key={s}><h3>{s} string</h3><div className="grid" style={{gridTemplateColumns:'repeat(5,1fr)',gap:'0.3rem'}}>{POSITIONS.map(p=>(<div key={p} style={{display:'grid',gridTemplateColumns:'repeat(4,1fr)',gap:'2px'}}>{FINGERS.map(f=>{ const k=`${s}:${p}:${f}`; const st=filteredStats[k]||{correct:0,total:0}; const acc=st.total? st.correct/st.total:0; let col, ink='#fff'; if(st.total===0) col='var(--neutral)'; else if(acc<0.5) col='var(--danger)'; else if(acc<0.75){ col='var(--warning)'; ink='#111'; } else col='var(--success)'; const label=st.total? `${Math.round(acc*100)}%`:''; return <div key={f} className="heat-cell" style={{background:col,color:ink,fontSize:'0.65rem'}} title={`Pos ${p}, F${f}: ${st.correct}/${st.total}`}>{label}</div>; })}</div>))}</div></div>))}<button className="btn btn-secondary" onClick={onBack}>Back</button></div>; }
    function PositionReference({onBack}){ const [pos,setPos]=React.useState(POSITIONS[0]); const [layoutCols,setLayoutCols]=React.useState('strings'); const [colorMode,setColorMode]=React.useState('strings'); const next=()=>setPos(p=>p===POSITIONS[POSITIONS.length-1]?POSITIONS[0]:p+1); const prev=()=>setPos(p=>p===POSITIONS[0]?POSITIONS[POSITIONS.length-1]:p-1); const pcAt=(s,p,f)=>((OPEN_PC[s]+POS_SHIFT[p]+BASE_OFF[f])%12+12)%12; const ENH={0:'C',1:'C‚ôØ/D‚ô≠',2:'D',3:'D‚ôØ/E‚ô≠',4:'E',5:'F',6:'F‚ôØ/G‚ô≠',7:'G',8:'G‚ôØ/A‚ô≠',9:'A',10:'A‚ôØ/B‚ô≠',11:'B'}; const labelFor=pc=>ENH[pc]||NOTE_NAME[pc]; const stringTint={E:'rgba(58,91,160,0.15)',A:'rgba(230,159,0,0.15)',D:'rgba(0,158,115,0.15)',G:'rgba(213,94,0,0.15)'}; const noteHue=pc=>`hsla(${(pc*30)%360}, 65%, 70%, 0.28)`; const bgForCell=(s,pc)=>colorMode==='strings'?stringTint[s]:noteHue(pc); const cols=layoutCols==='strings'? STRINGS: FINGERS; const rows=layoutCols==='strings'? FINGERS: STRINGS; const ordinalShort=n=>({1:'1st',2:'2nd',3:'3rd',4:'4th'}[n]||`${n}th`); const colHead=c=>layoutCols==='strings'?c:`${ordinal(c)} finger`; const rowHeadVisible=r=>layoutCols==='strings'? ordinalShort(r):r; const rowHeadAria=r=>layoutCols==='strings'? `${ordinal(r)} finger`:`${r} string`; const cellSF=(row,col)=>layoutCols==='strings'?{s:col,f:row}:{s:row,f:col}; const CELL_STYLE={ height:56,minHeight:56,border:'1px solid var(--border)',borderRadius:10,padding:'10px 12px',display:'flex',alignItems:'center',justifyContent:'center',textAlign:'center',fontWeight:600,lineHeight:1.1,whiteSpace:'nowrap' }; const HEAD_COL_W='clamp(4ch, 9.5vw, 7ch)'; return <div><div className="card"><h2>Positions Charts</h2><div className="grid" style={{gridTemplateColumns:'1fr 1fr', gap:'1rem', marginBottom:'0.25rem'}}><div role="radiogroup" aria-label="Layout (columns)"><div style={{fontWeight:600,marginBottom:6}}>Layout</div><OptionButton label="Strings" selected={layoutCols==='strings'} onClick={()=>setLayoutCols('strings')} /><OptionButton label="Fingers" selected={layoutCols==='fingers'} onClick={()=>setLayoutCols('fingers')} /></div><div role="radiogroup" aria-label="Color mode"><div style={{fontWeight:600,marginBottom:6}}>Colors</div><OptionButton label="Strings" selected={colorMode==='strings'} onClick={()=>setColorMode('strings')} /><OptionButton label="Notes" selected={colorMode==='notes'} onClick={()=>setColorMode('notes')} /></div></div><div style={{display:'flex',justifyContent:'center',margin:'10px 0 6px'}}><span aria-label={`Notes of ${ordinal(pos)} Position`} style={{display:'inline-flex',alignItems:'center',padding:'0.35rem 0.75rem',borderRadius:9999,border:'1px solid var(--border)',fontWeight:700,letterSpacing:'.01em',color:'var(--ink)',background:'var(--card)',boxShadow:'0 1px 0 rgba(0,0,0,0.02)'}}>{ordinal(pos)} Position</span></div><table style={{width:'100%',borderCollapse:'separate',borderSpacing:'8px',tableLayout:'fixed'}}><thead><tr><th scope="col" style={{width:HEAD_COL_W}}></th>{cols.map(c=>(<th scope="col" key={String(c)} style={{textAlign:'center',fontWeight:700}}>{colHead(c)}</th>))}</tr></thead><tbody>{rows.map(r=>(<tr key={String(r)}><th scope="row" aria-label={rowHeadAria(r)} style={{width:HEAD_COL_W,textAlign:'right',paddingRight:8,whiteSpace:'nowrap',fontWeight:600}}>{rowHeadVisible(r)}</th>{cols.map(c=>{ const {s,f}=cellSF(r,c); const pc=pcAt(s,pos,f); return <td key={`${s}-${f}`} style={{padding:0}}><div style={{...CELL_STYLE,background:bgForCell(s,pc)}} title={`${s} string ‚Ä¢ ${ordinal(f)} finger`}>{labelFor(pc)}</div></td>; })}</tr>))}</tbody></table><div role="radiogroup" aria-label="Select position" style={{display:'flex',gap:'.5rem',justifyContent:'center',marginTop:'.75rem'}}>{POSITIONS.map(n=>(<OptionButton key={n} label={String(n)} selected={pos===n} onClick={()=>setPos(n)} />))}</div><div style={{display:'flex',gap:'.5rem',justifyContent:'center',marginTop:'.5rem'}}><button className="btn btn-secondary" onClick={prev} aria-label="Previous position">Prev</button><button className="btn btn-primary" onClick={next} aria-label="Next position">Next</button></div></div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>; }
    function App(){ const [page,setPage]=React.useState('home'); const [prefs,setPrefs]=React.useState(()=>loadJSON(PREFS_KEY,defaultPrefs)); return <div className="container">{page==='home' && (<div><h1>Violin Mastery Quest</h1><p style={{color:'var(--ink-light)'}}>Tailor your practice by choosing strings & positions. Enjoy drills, study tools and track progress.</p><div className="grid" style={{gridTemplateColumns:'repeat(auto-fit,minmax(260px,1fr))',gap:'1rem'}}><div className="card"><h2>üìò Study</h2><button className="btn btn-primary" onClick={()=>setPage('positionRef')}>Positions Charts</button><button className="btn btn-primary" onClick={()=>setPage('flash')}>Flashcards</button><button className="btn btn-primary" onClick={()=>setPage('snapshot')}>Snapshot</button><button className="btn btn-primary" onClick={()=>setPage('bieler')}>Technique Lab</button></div><div className="card"><h2>üéª Play</h2><button className="btn btn-primary" onClick={()=>setPage('speed')}>Speed Drill</button><button className="btn btn-primary" onClick={()=>setPage('locator')}>Note Locator</button></div><div className="card"><h2>üìä Progress & Settings</h2><button className="btn btn-primary" onClick={()=>setPage('stats')}>View Stats</button><button className="btn btn-primary" onClick={()=>setPage('settings')}>Settings</button></div></div></div>)}{page==='speed' && <SpeedDrill prefs={prefs} onBack={()=>setPage('home')} />}{page==='flash' && <Flashcards prefs={prefs} onBack={()=>setPage('home')} />}{page==='snapshot' && <Snapshot prefs={prefs} onBack={()=>setPage('home')} />}{page==='locator' && <NoteLocator prefs={prefs} onBack={()=>setPage('home')} />}{page==='settings' && <Settings prefs={prefs} setPrefs={setPrefs} onBack={()=>setPage('home')} />}{page==='stats' && <StatsPage onBack={()=>setPage('home')} />}{page==='positionRef' && <PositionReference onBack={()=>setPage('home')} />}{page==='bieler' && <BielerLab onBack={()=>setPage('home')} />}</div>; }
    const root=ReactDOM.createRoot(document.getElementById('root')); root.render(<React.StrictMode><App/></React.StrictMode>);
  </script>
</body>
</html>