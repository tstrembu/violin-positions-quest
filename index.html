<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Positions Quest</title>

  <!-- Viewport & Theme -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#6d28d9" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="VPQ" />

  <!-- PWA manifest & icons (GitHub Pages path) -->
  <link rel="manifest" href="/violin-positions-quest/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/violin-positions-quest/icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/violin-positions-quest/icons/icon-192.png" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- Base styles -->
  <style>
    :root {
      --bg: #f3f4f6;
      --card: #ffffff;
      --ink-900: #111827;
      --ink-800: #1f2937;
      --ink-700: #374151;
      --ink-600: #4b5563;
      --ink-500: #6b7280;
      --shadow: 0 10px 20px rgba(0,0,0,0.08);
    }
    body.dark {
      --bg: #0b1020;
      --card: #0f172a;
      --ink-900: #e5e7eb;
      --ink-800: #e2e8f0;
      --ink-700: #cbd5e1;
      --ink-600: #94a3b8;
      --ink-500: #64748b;
      --shadow: 0 12px 24px rgba(0,0,0,0.35);
    }
    html, body { height:100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink-900);
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji';
    }
    .card { background: var(--card); box-shadow: var(--shadow); }
    .muted { color: var(--ink-600); }
    .ink700 { color: var(--ink-700); }
    .ink800 { color: var(--ink-800); }
    .linkish { text-decoration: underline; cursor: pointer; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { width:min(680px, 92vw); }
    .pill { border-radius: 9999px; padding: 4px 10px; display:inline-block; font-size:12px; }
    .badge { background:#6d28d9; color:white; border-radius:9999px; padding:.25rem .6rem; font-weight:700; font-size:12px; }
    .help-dot { width: 22px; height: 22px; border-radius: 9999px; display:inline-flex; align-items:center; justify-content:center; background:#11182717; color:#6d28d9; font-weight:700; }
    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; z-index: 9998; }
    .btn {
      display:inline-flex; align-items:center; justify-content:center;
      padding: .75rem 1.25rem; border-radius: 9999px; color:white; font-weight:700;
      transition: transform .08s ease;
    }
    .btn:active { transform: scale(.98); }
    .btn-purple { background:#6d28d9; }
    .btn-blue { background:#2563eb; }
    .btn-green { background:#059669; }
    .btn-gray { background:#4b5563; }
    .btn-rose { background:#e11d48; }
    .btn-amber { background:#d97706; }
    .grid-cards { display:grid; gap: 24px; grid-template-columns: repeat(1, minmax(0,1fr)); }
    @media(min-width:640px){ .grid-cards{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media(min-width:1024px){ .grid-cards{ grid-template-columns: repeat(3, minmax(0,1fr)); } }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }

    /* A11y live region */
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}
    *, *::before, *::after { box-sizing: border-box; }
   
    /* ---- Fingerboard heatmap layout ---- */
    :root{
      --posw: clamp(280px, 92vw, 360px);   /* width of each position card on small screens */
      --cell: clamp(48px, 9vw, 62px);      /* width/height basis for tiles */
    }
    
    .fb-strip {
      display: flex;
      gap: 12px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 6px;
      scroll-snap-type: x mandatory;
    }
    
    /* 1) Let grid items actually shrink inside the grid columns */
    .fb-pos { min-width: 0; overflow: hidden; }
    
    /* 2) Make the 5-note matrix responsive instead of fixed-width */
    .fb-grid{
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr)); /* was: repeat(5, var(--cell)) */
      gap:6px;
    }
    
    /* 3) Keep tiles square-ish without relying on --cell */
    .fb-tile{
      height:auto;                 /* was: calc(var(--cell) + 14px) */
      aspect-ratio: 1 / 1.1;       /* room for label + band */
      padding:6px 4px;
    }
    
    /* 4) Optional: avoid any bleed when the strip becomes a grid */
    @media (min-width:768px){
      .fb-strip { overflow:hidden; }  /* was: overflow: visible; */
    }
    
    /* 5) Fallback if a browser lacks aspect-ratio (rare now) */
    @supports not (aspect-ratio: 1){
      .fb-tile { height: 72px; }
    }
  </style>

  <!-- Tailwind (utility helpers only) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode:'class', theme:{ extend:{ fontFamily:{ inter:['Inter','ui-sans-serif','system-ui'] } } } };
  </script>

  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <!-- A11y live region -->
  <div id="sr" aria-live="polite" class="sr-only"></div>

  <!-- App -->
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    /* =========================================================
       Storage keys
    ========================================================== */
    const THEME_KEY = 'vpq.theme.v1';
    const BEST_KEY = 'positionsQuest.speed.best';
    const STATS_KEY = 'positionsQuest.speed.stats';
    const PREFS_KEY = 'positionsQuest.prefs';
    const PRESETS_KEY = 'positionsQuest.filterPresets.v1';
    const SESSIONLOG_KEY = 'positionsQuest.sessions.v1';
    const SCORE_KEY = 'positions.scoreboard.v1';
    const BADGES_KEY = 'positions.badges.v1';
    const SEYBOLD_KEY = 'seybold.hub.v1';
    const TEMPO_STATS_KEY = 'positionsQuest.tempo.stats.v1';
    const TEMPO_BEST_KEY  = 'positionsQuest.tempo.best.v1';

    // NEW stats keys for added modes
    const HEIGHT_STATS_KEY  = 'positionsQuest.height.stats.v1';
    const LOCATOR_STATS_KEY = 'positionsQuest.locator.stats.v1';
    const SHIFT_STATS_KEY   = 'positionsQuest.shift.stats.v1';
    const HARM_STATS_KEY    = 'positionsQuest.harmonics.stats.v1';

    /* =========================================================
       Theme
    ========================================================== */
    const getTheme = () => (localStorage.getItem(THEME_KEY) || 'light');
    const setTheme = (t) => { localStorage.setItem(THEME_KEY, t); document.body.classList.toggle('dark', t === 'dark'); };
    (function bootTheme(){ setTheme(getTheme()); })();

    /* =========================================================
       Utilities
    ========================================================== */
    const shuffle = (arr) => {
      const a = [...arr];
      for (let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
      return a;
    };
    const getRandomItem = (arr) => arr[Math.floor(Math.random()*arr.length)];

    // Immediate win #4: ASCII accidental normalizer for display
    const NORM = {'A‚ô≠':'Ab','B‚ô≠':'Bb','E‚ô≠':'Eb','D‚ô≠':'Db','G‚ô≠':'Gb','C‚ô≠':'Cb',
                  'C‚ôØ':'C#','D‚ôØ':'D#','F‚ôØ':'F#','G‚ôØ':'G#','A‚ôØ':'A#'};
    const norm = n => NORM[n] || n;

    /* =========================================================
       Fingerboard Data (Positions 1‚Äì5) + Open strings
    ========================================================== */
    const STRINGS = ['G','D','A','E'];
    const POSITIONS = ['1','2','3','4','5'];
    // include F0 (open)
    const FINGERS = ['0','1','2','3','4'];

    const NOTES_DATA = {
      G: {
        1: { 0: ['G'], 1: ['A‚ô≠','A'], 2: ['B‚ô≠','B'], 3: ['C','C#'], 4: ['D'] },
        2: { 1: ['B‚ô≠','B'], 2: ['B','C'], 3: ['C','C#'], 4: ['D','D#'] },
        3: { 1: ['C','C#'], 2: ['C#','D'], 3: ['D','D#'], 4: ['E','F'] },
        4: { 1: ['D','D#'], 2: ['D#','E'], 3: ['E','F'],   4: ['F#','G'] },
        5: { 1: ['E','F'],   2: ['F','F#'], 3: ['F#','G'], 4: ['G#','A'] },
      },
      D: {
        1: { 0: ['D'], 1: ['E‚ô≠','E'], 2: ['F','F#'], 3: ['G','G#'], 4: ['A'] },
        2: { 1: ['F','F#'], 2: ['F#','G'], 3: ['G','G#'], 4: ['A','A#'] },
        3: { 1: ['G','G#'], 2: ['G#','A'], 3: ['A','A#'], 4: ['B','C'] },
        4: { 1: ['A','A#'], 2: ['A#','B'], 3: ['B','C'],  4: ['C#','D'] },
        5: { 1: ['B','C'],  2: ['C','C#'], 3: ['C#','D'], 4: ['D#','E'] },
      },
      A: {
        1: { 0: ['A'], 1: ['B‚ô≠','B'], 2: ['C','C#'], 3: ['D','D#'], 4: ['E'] },
        2: { 1: ['C','C#'], 2: ['C#','D'], 3: ['D','D#'], 4: ['E','F'] },
        3: { 1: ['D','D#'], 2: ['D#','E'], 3: ['E','F'],  4: ['F#','G'] },
        4: { 1: ['E','F'],  2: ['F','F#'], 3: ['F#','G'], 4: ['G#','A'] },
        5: { 1: ['F#','G'], 2: ['G','G#'], 3: ['G#','A'], 4: ['A#','B'] },
      },
      E: {
        1: { 0: ['E'], 1: ['F','F#'], 2: ['G','G#'], 3: ['A','A#'], 4: ['B'] },
        2: { 1: ['G','G#'], 2: ['G#','A'], 3: ['A','A#'], 4: ['B','C'] },
        3: { 1: ['A','A#'], 2: ['A#','B'], 3: ['B','C'],  4: ['C#','D'] },
        4: { 1: ['B','C'],  2: ['C','C#'], 3: ['C#','D'], 4: ['D#','E'] },
        5: { 1: ['C#','D'], 2: ['D','D#'], 3: ['D#','E'], 4: ['F','F#'] },
      },
    };

    // Low/High helper
    const fingerHeight = (note, options) => {
      if (!Array.isArray(options)) return 'natural';
      if (options.length <= 1) return 'natural';
      const [low, high] = [options[0], options[options.length-1]];
      if (note === low) return 'low';
      if (note === high) return 'high';
      return 'natural';
    };

    // Simple harmonics set per string
    const HARMONICS = {
      G: { '1/2':['G','octave'], '1/3':['D','oct+5th'], '1/4':['G','2 oct'] },
      D: { '1/2':['D','octave'], '1/3':['A','oct+5th'], '1/4':['D','2 oct'] },
      A: { '1/2':['A','octave'], '1/3':['E','oct+5th'], '1/4':['A','2 oct'] },
      E: { '1/2':['E','octave'], '1/3':['B','oct+5th'], '1/4':['E','2 oct'] },
    };

    // Unique note list
    const ALL_NOTES_UNIQUE = (() => {
      const set = new Set();
      STRINGS.forEach(s => POSITIONS.forEach(p => FINGERS.forEach(f => {
        const cell = NOTES_DATA[s]?.[p]?.[f];
        if (Array.isArray(cell)) cell.forEach(n => set.add(n));
      })));
      return [...set];
    })();

    const getRandomDistractors = (excludeSet, count=3) => {
      const pool = ALL_NOTES_UNIQUE.filter(n => !excludeSet.has(n));
      const picks = new Set();
      while (picks.size < Math.min(count, pool.length)) picks.add(pool[Math.floor(Math.random()*pool.length)]);
      return [...picks];
    };

    /* =========================================================
       Prefs & persistence
    ========================================================== */
    const defaultFilters = {
      strings: Object.fromEntries(STRINGS.map(s => [s, true])),
      positions: Object.fromEntries(POSITIONS.map(p => [p, true])),
      fingers: Object.fromEntries(FINGERS.map(f => [f, true])),
    };
    const loadPrefs = () => {
      try {
        const p = JSON.parse(localStorage.getItem(PREFS_KEY));
        return {
          sound: true, confetti: true, adaptive: true, coach: true, coachRetry: true,
          callouts: true, roundLen: 120, goalEnabled: false, goalTarget: 10,
          filters: { ...defaultFilters, ...(p?.filters || {}) }, ...(p || {})
        };
      } catch { return { sound:true, confetti:true, adaptive:true, coach:true, coachRetry:true, callouts:true, roundLen:120, goalEnabled:false, goalTarget:10, filters: defaultFilters }; }
    };
    const savePrefs = (obj) => { try { localStorage.setItem(PREFS_KEY, JSON.stringify(obj)); } catch {} };
    const loadBest = () => { try { return JSON.parse(localStorage.getItem(BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveBest = (obj) => { try { localStorage.setItem(BEST_KEY, JSON.stringify(obj)); } catch {} };
    const loadStats = () => { try { return JSON.parse(localStorage.getItem(STATS_KEY)) || {}; } catch { return {}; } };
    const saveStats = (obj) => { try { localStorage.setItem(STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoStats = () => { try { return JSON.parse(localStorage.getItem(TEMPO_STATS_KEY)) || {}; } catch { return {}; } };
    const saveTempoStats = (obj) => { try { localStorage.setItem(TEMPO_STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoBest = () => { try { return JSON.parse(localStorage.getItem(TEMPO_BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveTempoBest = (obj) => { try { localStorage.setItem(TEMPO_BEST_KEY, JSON.stringify(obj)); } catch {} };

    // New per-mode stats helpers
    const loadJSON = (k, fallback={}) => { try { return JSON.parse(localStorage.getItem(k)) || fallback; } catch { return fallback; } };
    const saveJSON = (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };

    /* =========================================================
       Audio & call-outs
    ========================================================== */
    const useBeeps = (enabled) => {
      const ctxRef = useRef(null);
      const ensureCtx = () => {
        if (!enabled) return null;
        if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
        return ctxRef.current;
      };
      const beep = (freq = 880, dur = 0.08, type = 'sine') => {
        const ctx = ensureCtx(); if (!ctx) return;
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = type; o.frequency.value = freq; g.gain.value = 0.08; o.connect(g); g.connect(ctx.destination);
        o.start(); setTimeout(()=>o.stop(), dur*1000);
      };
      return { good: () => beep(1046, 0.09, 'triangle'), bad: () => beep(196, 0.12, 'sawtooth') };
    };
    const useCallouts = (enabled) => {
      const speak = (text) => {
        if (!enabled || !window.speechSynthesis) return;
        try { 
          const u = new SpeechSynthesisUtterance(text); 
          u.lang='en-US'; u.rate=1.0; 
          // Immediate win #8: prevent overlap
          window.speechSynthesis.cancel();
          setTimeout(()=>window.speechSynthesis.speak(u), 0);
        } catch {}
      };
      return { speak };
    };

    /* =========================================================
       Tiny UI atoms
    ========================================================== */
    const Modal = ({ open, onClose, title, children }) => !open ? null : (
      <div className="modal-backdrop" onClick={onClose}>
        <div className="modal card rounded-xl p-5" role="dialog" aria-modal="true" onClick={e=>e.stopPropagation()}>
          <div className="flex items-center justify-between mb-2">
            <div className="text-lg font-bold">{title}</div>
            <button className="btn btn-gray" onClick={onClose}>Close</button>
          </div>
          <div className="muted text-sm leading-relaxed">{children}</div>
        </div>
      </div>
    );

    const CardButton = ({ title, description, onClick, onHelp }) => (
      <div className="card rounded-xl p-5">
        <div className="flex items-start justify-between">
          <div>
            <div className="text-xl font-bold ink800">{title}</div>
            <div className="muted text-sm mt-1">{description}</div>
          </div>
          <button className="help-dot" title="How to play" onClick={onHelp}>?</button>
        </div>
        <div className="mt-4">
          <button className="btn btn-purple" onClick={onClick}>Open</button>
        </div>
      </div>
    );

    const Toast = ({ open, text, action, onAction }) => !open ? null : (
      <div className="toast">
        <div className="card rounded-full px-4 py-2 flex items-center gap-3">
          <span className="ink800">{text}</span>
          {action && <button className="btn btn-amber" onClick={onAction}>{action}</button>}
        </div>
      </div>
    );

    /* =========================================================
       Help text (one-paragraph per card)
    ========================================================== */
    const HELP = {
      speed: "Speed Ladder: you‚Äôll see a prompt like G, Position 2, Finger 3. Choose the note that fits. Use keys 1‚Äì4 to answer fast. The coach re-surfaces weaknesses and (optionally) retries misses. Aim for accuracy first, then speed.",
      cards: "Flashcards: two decks‚Äî(A) direct fingerboard hits (what note is under finger X?) and (B) locations by note. Press Space to reveal, N/P or arrows to navigate.",
      bingo: "Positions Bingo: a 5√ó5 practice board with violin tasks. Mark squares as you complete them. The center is FREE. Press R to reshuffle the board.",
      dice: "Dice of Destiny: press Roll for a focused practice challenge. The dice avoids repeats until the set cycles. Copy your challenge to notes if you like.",
      tempoTrainer: "Tempo Trainer: flashcards for Italian tempo terms with optional speech call-outs. Reveal the meaning, then say the feel out loud.",
      tempoTester: "Tempo Tester: timed multiple choice. Press 1‚Äì4 to answer. At the end, review your misses and retry just those items. A heat map tracks per-term accuracy.",
      bielerLab: "Bieler Method Lab: progressive study of Ida Bieler‚Äôs approach. First build vocabulary, then test conceptual understanding, then apply ideas to musical scenarios and bow/left-hand technique.",
      height: "Finger Height Drill: Low vs High fingers. Prompt: note + string/position/finger. Answer Low or High (L/H). Builds intonation patterns across positions.",
      locator: "Note Locator: Given a pitch (e.g., Bb), pick a valid location (string, position, finger). Reinforces multiple locations for the same note.",
      shift: "Shift Coach: Stay on one string. Given start note/location and target note, choose the most efficient new position/finger (requires a shift).",
      harmonics: "Harmonics Lab: Learn natural harmonic nodes (1/2, 1/3, 1/4) per string with flashcards and quick checks. Great for tone and intonation reference."
    };
    
    /* =========================================================
       Heatmaps
    ========================================================== */
    const tileColor = (total, acc) => {
      if (!total) return 'rgba(120,120,120,0.18)';
      const hue = 140 * acc, sat = 85, light = 45 + 10 * acc;
      return `hsla(${hue}, ${sat}%, ${light}%, 1)`;
    };

const AccuracyHeatmap = ({ stats }) => (
  <div className="card rounded-xl p-4">
    <div className="text-lg font-semibold mb-2">Fingerboard Accuracy</div>

    <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
      {STRINGS.map(s => (
        <div key={s} className="rounded-lg border overflow-hidden">
          <div className="px-3 py-2 font-semibold" style={{ background: 'rgba(0,0,0,.04)', whiteSpace:'nowrap' }}>
            {s} string
          </div>

          <div className="p-2">
            {/* Small screens: horizontal strip; md+: CSS elevates this to a grid */}
            <div className="fb-strip">
              {POSITIONS.map(p => (
                <div key={p} className="fb-pos rounded-md border">
                  <div className="fb-grid p-2">
                    {FINGERS.map(f => {
                      const isReal = !!validCell(s, p, f);
                      const k = `${s}:${p}:${f}`;
                      const st = isReal ? (stats[k] || { correct:0, total:0 }) : null;
                      const style = evidenceStyle(st);

                      return (
                        <div
                          key={f}
                          className="fb-tile"
                          title={
                            isReal
                              ? `${s} ‚Ä¢ Pos ${p} ‚Ä¢ F${f} ‚Äî ${st.correct||0}/${st.total||0} (acc ${st.total?Math.round((st.correct/st.total)*100):0}% ; LB ${st.total?Math.round(style.lb*100):0}%)`
                              : 'Not a valid finger/position'
                          }
                          aria-label={
                            isReal
                              ? `On ${s} string, position ${p}, finger ${f}. ${st.total||0} attempts, ${st.correct||0} correct. Lower bound ${Math.round(style.lb*100)} percent`
                              : 'Invalid cell'
                          }
                          style={{
                            border: isReal ? '1px solid rgba(0,0,0,0.08)' : '1px dashed rgba(0,0,0,0.20)',
                            background: 'transparent',
                            color: isReal ? style.text : '#9ca3af'
                          }}
                        >
                          <div style={{ fontWeight:600 }}>F{f}</div>
                          <div className="text-xs">
                            {isReal && st.total ? `${Math.round((st.correct/st.total)*100)}%` : '‚Äî'}
                          </div>
                          <div
                            className="fb-band"
                            style={{ background: isReal ? style.bandColor : 'rgba(0,0,0,0.08)' }}
                          />
                        </div>
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      ))}
    </div>

    <p className="text-xs muted mt-2">
      Legend ‚Äî <b>Gray:</b> unseen ¬∑ <span style={{color:'#ef4444',fontWeight:600}}>Red:</span> needs work (<i>LB</i>&lt;65%)
      ¬∑ <span style={{color:'#f59e0b',fontWeight:600}}>Yellow:</span> developing (65‚Äì85%)
      ¬∑ <span style={{color:'#10b981',fontWeight:600}}>Green:</span> strong (‚â•85%). Bands use the 95% Wilson lower confidence bound; opacity increases with attempts (stability).
    </p>
  </div>
);
    const TempoHeatmap = ({ stats, terms }) => (
      <div className="card rounded-xl p-4">
        <div className="text-lg font-semibold mb-2">Tempo Heatmap</div>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
          {terms.map(t => {
            const st = stats[t.it] || { correct:0, total:0 };
            const acc = st.total ? st.correct/st.total : 0;
            const bg = tileColor(st.total, acc);
            return (
              <div key={t.it} className="rounded border p-3" style={{background:bg}} title={`${t.it} ‚Äî ${st.correct}/${st.total} (${Math.round(acc*100)}%)`}>
                <div className="font-semibold">{t.it}</div>
                <div className="text-xs">{st.total ? `${Math.round(acc*100)}%` : '‚Äî'}</div>
              </div>
            );
          })}
        </div>
      </div>
    );

    
    /* =========================================================
       Evidence-based approach and color stability for the fingerboard heatmap
       - Wilson 95% lower bound classifies red/yellow/green
       - Opacity scales with attempts (stability)
    ========================================================= */
    const wilsonLowerBound = (correct, total, z = 1.96) => {
      if (!total) return 0;
      const p = correct / total;
      const denom = 1 + (z*z)/total;
      const centre = p + (z*z)/(2*total);
      const adj = z * Math.sqrt((p*(1-p) + (z*z)/(4*total)) / total);
      return Math.max(0, (centre - adj) / denom);
    };

    // Color bands from LB; thresholds chosen for pedagogical clarity
    const bandFromLB = (lb) => {
      if (lb < 0.65) return 'red';
      if (lb < 0.85) return 'yellow';
      return 'green';
    };

    // Safari-safe RGBA swatches
    const SWATCH = {
      red:    [239, 68, 68],   // tailwind red-500
      yellow: [245, 158, 11],  // amber-500
      green:  [16, 185, 129],  // emerald-500
      gray:   [120,120,120],
    };
    
    const rgba = (rgb, a) => `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
    
    // Attempts -> opacity curve (n: 0‚Üí‚àû maps to 0.35‚Üí1.0, capped by ~50)
    const stabilityAlpha = (n) => {
      if (!n) return 0.18; // faint for unseen placeholder
      const t = Math.min(1, Math.log10(n + 1) / Math.log10(50)); // 0..1
      return 0.35 + 0.65 * t; // 0.35..1.0
    };
    
    // Style calculator for a speed-ladder stat tile
    const evidenceStyle = (st) => {
      const correct = st?.correct || 0, total = st?.total || 0;
      if (!total) {
        return {
          bandColor: rgba(SWATCH.gray, 0.45),
          bg: 'rgba(0,0,0,0)', // transparent; we lean on the band + dashed border
          text: '#4b5563',     // gray-600
          lb: 0, acc: 0, total
        };
      }
      const lb = wilsonLowerBound(correct, total);
      const band = bandFromLB(lb);
      const alpha = stabilityAlpha(total);
      return {
        bandColor: rgba(SWATCH[band], alpha),
        bg: 'transparent',
        text: '#111827', // ink-900
        lb, acc: correct/total, total, band
      };
    };
    
    /* =========================================================
       Tempo data
    ========================================================== */
    const TEMPOS = [
      { it:'Prestissimo', en:'super fast' },
      { it:'Presto',      en:'very fast' },
      { it:'Allegro',     en:'fast/happy' },
      { it:'Allegretto',  en:'medium moving/motion, brisk' },
      { it:'Andante',     en:'walking tempo/speed' },
      { it:'Andantino',   en:'little walking (near Andante)' },
      { it:'Adagio',      en:'slow (majestic), at ease' },
      { it:'Largo',       en:'slow-largeness, broad' },
      { it:'Lento',       en:'very slow' },
    ];

    /* =========================================================
       Bieler Method data
    ========================================================== */
    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1st‚Äì2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shifting‚Äîmoving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibrato‚Äîfinger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'D√©tach√©', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'Coll√©', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'Martel√©', def:'Accented, stopped stroke‚Äîbite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance point‚Äîvertical energy, horizontal timing.' },
      { term:'Sautill√©', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term:'Nature', def:'Use body‚Äôs natural alignments‚Äîeconomy, ease, resonance.' },
      { term:'Nurture', def:'Stepwise training‚Äîpatterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];

    const BIELER_CONCEPT_QA = [
      { q:'Why does ‚Äúhand frame‚Äù matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautill√©?', a:'Spiccato is placed/rebounded; sautill√© is natural spring at faster tempi.', wrong:['Spiccato is legato','Sautill√© is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];

    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy martel√© at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist coll√©','Firm staccato','Always play sul ponticello'] },
    ];

    /* =========================================================
       Confetti
    ========================================================== */
    const ConfettiBurst = ({ seed }) => {
      const [pieces, setPieces] = useState([]);
      useEffect(() => {
        if (!seed) return;
        const EMOJI = ['‚ú®','üéâ','üéä','‚≠ê','üí•','üåü'];
        const n = 24;
        const arr = Array.from({ length: n }, (_, i) => ({
          id: i, left: Math.random()*100, rot: (Math.random()*40)-20, delay: Math.random()*100, emoji: EMOJI[Math.floor(Math.random()*EMOJI.length)]
        }));
        setPieces(arr);
        const t = setTimeout(()=>setPieces([]), 900);
        return () => clearTimeout(t);
      }, [seed]);
      if (!pieces.length) return null;
      return (
        <div className="pointer-events-none fixed inset-0 overflow-hidden z-50">
          {pieces.map(p => (
            <span key={p.id} style={{position:'absolute', left:`${p.left}vw`, top:'-10px', transform:`rotate(${p.rot}deg)`, animation:'fall 0.9s ease-in forwards', animationDelay:`${p.delay}ms`, fontSize:'20px' }}>
              {p.emoji}
            </span>
          ))}
          <style>{`@keyframes fall{to{transform:translateY(110vh); opacity:.65;}}`}</style>
        </div>
      );
    };

    /* =========================================================
       Shared helpers for fingerboard
    ========================================================== */
    const validCell = (s,p,f) => Array.isArray(NOTES_DATA[s]?.[p]?.[f]) ? NOTES_DATA[s][p][f] : null;

    // All combos that actually exist in NOTES_DATA
    const allActualCombos = () => {
      const arr = [];
      for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
        const cell = validCell(s,p,f);
        if (cell) arr.push({ s, p, f, valid: cell });
      }
      return arr;
    };

    // locations for a note across all strings/positions/fingers
    const allLocationsForNote = (note) => {
      const spots=[];
      for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
        const cell = validCell(s,p,f);
        if (cell && cell.includes(note)) spots.push({s,p,f});
      }
      return spots;
    };
    const groupLocationsByString = (note) => {
      const by = new Map(STRINGS.map(s=>[s,[]]));
      for (const loc of allLocationsForNote(note)) by.get(loc.s).push(loc);
      const lines = [];
      for (const s of STRINGS){
        const arr = by.get(s).sort((a,b)=>Number(a.p)-Number(b.p)||Number(a.f)-Number(b.f));
        if (arr.length) lines.push(`${s}: ${arr.map(({p,f})=>`Pos ${p} (F${f})`).join(', ')}`);
      }
      return lines.join('  |  ');
    };

    /* =========================================================
       Games
    ========================================================== */

    // Tempo Trainer (flashcards)
    const TempoTrainer = ({ onBack, prefs }) => {
      const [i, setI] = useState(0);
      const [show, setShow] = useState(false);
      const { speak } = useCallouts(prefs.callouts);
      useEffect(()=>{ speak(TEMPOS[i].it); }, [i]);
      const next = () => { setShow(false); setI((i+1)%TEMPOS.length); };
      const prev = () => { setShow(false); setI((i-1+TEMPOS.length)%TEMPOS.length); };
      useEffect(()=>{
        const onKey = (e)=>{ const k = e.key.toLowerCase(); if(k===' '){e.preventDefault();setShow(true);} if(k==='arrowright'||k==='n') next(); if(k==='arrowleft'||k==='p') prev(); };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [i, show]);
      const card = TEMPOS[i];
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-4">Tempo Trainer (Flashcards)</h2>
            <div className="rounded-xl border-2 p-6 text-center">
              <div className="text-xl font-bold">{card.it}</div>
              {show ? <div className="mt-2">
                <div className="text-green-700 font-semibold">{card.en}</div>
                <div className="text-xs muted mt-1">Say the feel out loud, then tap Next.</div>
              </div> : <div className="muted italic">Press Space or tap ‚ÄúReveal‚Äù.</div>}
            </div>
            <div className="flex gap-2 mt-6 justify-center">
              <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
              <button className="btn btn-gray" onClick={prev}>Previous</button>
              <button className="btn btn-purple" onClick={next}>Next</button>
            </div>
            <div className="text-xs muted mt-3 text-center">Shortcuts: Space, ‚Üê/‚Üí or P/N</div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Tempo Tester (MCQ with review misses + heatmap)
    const TempoTester = ({ onBack, prefs }) => {
      const [best, setBest] = useState(loadTempoBest());
      const [stats, setStats] = useState(loadTempoStats());
      const [timer, setTimer] = useState(prefs.roundLen || 60);
      const [finished, setFinished] = useState(false);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [streak, setStreak] = useState(0);
      const [confettiSeed, setConfettiSeed] = useState(0);
      const [events, setEvents] = useState([]);
      const [q, setQ] = useState(null);
      const { speak } = useCallouts(prefs.callouts);
      const beeps = useBeeps(prefs.sound);
      const optionsRef = useRef([]);

      const pickQ = (forced=null) => {
        const correct = forced || getRandomItem(TEMPOS);
        const distractors = shuffle(TEMPOS.filter(t=>t.it!==correct.it)).slice(0,3);
        const options = shuffle([correct.en, ...distractors.map(d=>d.en)]);
        setQ({ it: correct.it, correct: correct.en, options });
        optionsRef.current = options;
        speak(correct.it);
      };

      useEffect(()=>{ setTimer(prefs.roundLen || 60); }, [prefs.roundLen]);
      useEffect(()=>{ pickQ(); },[]);
      useEffect(()=>{
        if (finished) return;
        const id = setInterval(()=>setTimer(t=>{
          if (t<=1){
            clearInterval(id); setFinished(true);
            const nb = { bestScore:Math.max(best.bestScore, score), bestStreak:Math.max(best.bestStreak, streak) };
            setBest(nb); saveTempoBest(nb); return 0;
          }
          return t-1;
        }), 1000);
        return ()=>clearInterval(id);
      }, [finished, score, streak, best]);

      const bump = (it, ok) => {
        const st = stats[it] || { correct:0, total:0 };
        const next = { ...stats, [it]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveTempoStats(next);
      };

      const handleAnswer = (choice) => {
        if (finished || !q) return;
        const ok = (choice === q.correct);
        bump(q.it, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setEvents(e => [{ t: Date.now(), it:q.it, chosen:choice, correct:q.correct, ok }, ...e]);
        setAnswered(a=>a+1);
        if (ok){ beeps.good(); setScore(s=>s+1); setStreak(x=>x+1); if (prefs.confetti) setConfettiSeed(x=>x+1); setTimeout(()=>pickQ(), 360); }
        else { beeps.bad(); setStreak(0); setTimeout(()=>pickQ(), 760); }
      };

      useEffect(()=>{
        const onKey=(e)=>{ if(finished) return; const k=e.key.toLowerCase(); if(['1','2','3','4'].includes(k)){ const idx=Number(k)-1; const ch=optionsRef.current?.[idx]; if(ch) handleAnswer(ch); } };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [finished, q]);

      const endReviewList = useMemo(()=>{
        const misses = [...events].filter(e=>!e.ok).reverse();
        const unique = []; const seen = new Set();
        for (const m of misses){ if(!seen.has(m.it)){ unique.push(m); seen.add(m.it); } }
        return unique;
      }, [events]);

      const startReview = () => {
        if (!endReviewList.length) return;
        setFinished(false); setScore(0); setAnswered(0); setStreak(0); setEvents([]);
        pickQ(endReviewList[0] && { it:endReviewList[0].it, en:endReviewList[0].correct });
      };

      const reset = () => {
        setFinished(false); setScore(0); setAnswered(0); setStreak(0); setEvents([]); setConfettiSeed(0);
        setTimer(prefs.roundLen || 60); pickQ();
      };

      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-2">Tempo Tester (Multiple Choice)</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered} ¬∑ Best: <b>{best.bestScore}</b> ¬∑ Best streak: <b>{best.bestStreak}</b></div>
            {!finished && q && (
              <>
                <div className="text-center mb-5">
                  <div className="text-xl font-bold">What does <b>{q.it}</b> mean?</div>
                  <div className="text-xs muted mt-1">Press 1‚Äì4 to answer fast.</div>
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {q.options.map((opt,i)=>(
                    <button key={i} className="btn btn-blue" title={`Press ${i+1}`} onClick={()=>handleAnswer(opt)}>
                      <span className="pill" style={{ background: 'rgba(0,0,0,.15)' }}>{i+1}</span>&nbsp; {opt}
                    </button>
                  ))}
                </div>
              </>
            )}
            {finished && (
              <div className="text-center">
                <div className="text-xl font-semibold">Round over! Final score: {score} / {answered}</div>
                <div className="mt-3">
                  <button className="btn btn-purple mr-2" onClick={reset}>Play Again</button>
                  <button className="btn btn-green" disabled={!endReviewList.length} onClick={startReview}>
                    Review Misses {endReviewList.length ? `(${endReviewList.length})` : ''}
                  </button>
                </div>
              </div>
            )}
          </div>

          <div className="w-full mt-6" style={{maxWidth:900}}>
            <TempoHeatmap stats={stats} terms={TEMPOS} />
          </div>

          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Finger Height Drill ===================== */
    const HeightDrill = ({ onBack, prefs }) => {
      const [q, setQ] = useState(null);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [timer, setTimer] = useState(prefs.roundLen || 60);
      const [stats, setStats] = useState(loadJSON(HEIGHT_STATS_KEY, {}));
      const [confettiSeed, setConfettiSeed] = useState(0);
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);

      const combos = useMemo(()=>{
        // only cells with true low/high choice (length >= 2)
        return allActualCombos().filter(c => c.valid.length >= 2);
      },[]);

      const pick = () => {
        const c = getRandomItem(combos);
        const note = getRandomItem(c.valid);
        const label = fingerHeight(note, c.valid); // 'low'|'high'|'natural'
        speak(`${c.s}, position ${c.p}, finger ${c.f}`);
        setQ({ ...c, note, label }); // label is the correct answer
      };

      useEffect(()=>{ pick(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => {
          if (t <= 1) { clearInterval(id); return 0; }
          return t-1;
        }), 1000);
        return ()=>clearInterval(id);
      },[]);

      const bump = (key, ok) => {
        const st = stats[key] || { low:{correct:0,total:0}, high:{correct:0,total:0}, natural:{correct:0,total:0} };
        const next = { ...stats, [key]: {
          low: { correct: st.low.correct + (ok && q.label==='low'?1:0), total: st.low.total + (q.label==='low'?1:0) },
          high:{ correct: st.high.correct+ (ok && q.label==='high'?1:0), total: st.high.total + (q.label==='high'?1:0) },
          natural:{ correct: st.natural.correct+ (ok && q.label==='natural'?1:0), total: st.natural.total + (q.label==='natural'?1:0) },
        } };
        setStats(next); saveJSON(HEIGHT_STATS_KEY, next);
      };

      const answer = (choice) => {
        if (!q || timer===0) return;
        const ok = (choice.toLowerCase() === q.label);
        const key = `${q.s}:${q.p}:${q.f}`;
        bump(key, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setAnswered(a=>a+1);
        if (ok) { beeps.good(); setScore(s=>s+1); if (prefs.confetti) setConfettiSeed(x=>x+1); setTimeout(pick, 350); }
        else { beeps.bad(); setTimeout(pick, 700); }
      };

      useEffect(()=>{
        const onKey = e => {
          const k = e.key.toLowerCase();
          if (k==='l') answer('low');
          if (k==='h') answer('high');
        };
        window.addEventListener('keydown', onKey);
        return ()=>window.removeEventListener('keydown', onKey);
      }, [q, timer]);

      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:760}}>
            <h2 className="text-2xl font-bold mb-2">Finger Height Drill (Low / High)</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered} ¬∑ Shortcuts: L / H</div>
            {q && (
              <>
                <div className="text-center mb-5">
                  <div className="text-xl font-bold">To play <b>{norm(q.note)}</b> on <b>{q.s}</b>, Pos <b>{q.p}</b>, F<b>{q.f}</b> ‚Äî is the finger <b>Low</b> or <b>High</b>?</div>
                </div>
                <div className="flex gap-3 justify-center">
                  <button className="btn btn-blue" onClick={()=>answer('low')}>Low</button>
                  <button className="btn btn-purple" onClick={()=>answer('high')}>High</button>
                </div>
                <div className="text-xs muted mt-4 text-center">Tip: ‚ÄúLow‚Äù is the first (flat) value in a cell like [F, F#]; ‚ÄúHigh‚Äù is the sharp.</div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Note Locator (Immediate win #3) ===================== */
    const NoteLocator = ({ onBack, prefs }) => {
      const [q,setQ] = useState(null);
      const [timer,setTimer] = useState(prefs.roundLen || 90);
      const [score,setScore] = useState(0);
      const [answered,setAnswered] = useState(0);
      const [stats, setStats] = useState(loadJSON(LOCATOR_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);

      const labelLoc = o => `${o.s} ¬∑ Pos ${o.p} ¬∑ F${o.f}`;

      const makeQ = () => {
        const note = getRandomItem(ALL_NOTES_UNIQUE);
        const correctLocs = allLocationsForNote(note);
        if (!correctLocs.length) return makeQ();
        const correct = getRandomItem(correctLocs);

        const wrongPool = allActualCombos().filter(c => {
          const cell = validCell(c.s, c.p, c.f) || [];
          return !cell.includes(note);
        });

        // prefer ‚Äúnearby‚Äù but guarantee fill
        const nearby = wrongPool.filter(c => c.s===correct.s || c.p===correct.p || c.f===correct.f);
        const fillers = nearby.length >= 3 ? nearby : wrongPool;

        const opts = shuffle([{...correct, ok:true}, ...shuffle(fillers)
          .filter(c => !(c.s===correct.s && c.p===correct.p && c.f===correct.f))
          .slice(0,3).map(c => ({...c, ok:false}))]);

        speak(note);
        setQ({ note, opts });
      };

      useEffect(()=>{ makeQ(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => t<=1 ? 0 : t-1), 1000);
        return ()=>clearInterval(id);
      },[]);

      const bump = (note, ok) => {
        const st = stats[note] || { correct:0, total:0 };
        const next = { ...stats, [note]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(LOCATOR_STATS_KEY, next);
      };

      const answer = (o) => {
        const ok = !!o.ok;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        bump(q.note, ok);
        setAnswered(a=>a+1);
        if (ok) setScore(s=>s+1);
        setTimeout(makeQ, ok?350:700);
      };

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:800}}>
            <h2 className="text-2xl font-bold mb-2">Note Locator</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered}</div>
            {q && (
              <>
                <div className="text-xl font-bold text-center">Where can you play <b>{norm(q.note)}</b>?</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-4">
                  {q.opts.map((o,i)=>(
                    <button key={i} className="btn btn-blue" onClick={()=>answer(o)}>
                      <span className="pill" style={{background:'rgba(0,0,0,.15)'}}>{i+1}</span>&nbsp; {labelLoc(o)}
                    </button>
                  ))}
                </div>
                <div className="text-xs muted mt-4 text-center">Hint: Many notes have multiple correct places. This drill builds mapping fluency.</div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Shift Coach (Immediate win #2) ===================== */
    const ShiftCoach = ({ onBack, prefs }) => {
      const [q,setQ] = useState(null);
      const [score,setScore] = useState(0);
      const [answered,setAnswered] = useState(0);
      const [timer,setTimer] = useState(prefs.roundLen || 90);
      const [stats, setStats] = useState(loadJSON(SHIFT_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);

      // helpers
      const locationsForNoteOnString = (note, s) => allLocationsForNote(note).filter(l => l.s === s);
      const samePosExists = (A, B) => A.some(a => B.some(b => a.p===b.p));
      const pathCost = (a, b) => Math.abs(Number(a.p) - Number(b.p)); // same string fixed; prefer minimal Œîpos
      const bestPair = (A, B) => {
        let best = null;
        for (const a of A) for (const b of B) {
          const cost = pathCost(a,b);
          if (!best || cost < best.cost) best = {a,b,cost};
        }
        return best;
      };

      const makePrompt = () => {
        const s = getRandomItem(STRINGS);
        const n1 = getRandomItem(ALL_NOTES_UNIQUE);
        const n2 = getRandomItem(ALL_NOTES_UNIQUE);
        const A = locationsForNoteOnString(n1, s);
        const B = locationsForNoteOnString(n2, s);
        if (!A.length || !B.length) return makePrompt();
        if (samePosExists(A,B)) return makePrompt(); // avoid trivial non-shift
        const best = bestPair(A,B);
        const start = best.a;
        const correctEnd = best.b;

        // Immediate win #2: only real, valid (but wrong) landings on same string that don't produce the target
        const pool = allActualCombos()
          .filter(c => c.s === s)
          .filter(c => !(validCell(c.s, c.p, c.f) || []).includes(n2));

        const opts = [{...correctEnd, ok:true}];
        for (const cand of shuffle(pool)) {
          if (opts.length >= 4) break;
          // avoid duplicates and avoid F0 as a shifted landing
          if (cand.f !== '0' && !opts.some(o => o.p===cand.p && o.f===cand.f)) {
            opts.push({...cand, ok:false});
          }
        }
        setQ({ string:s, startNote:n1, targetNote:n2, start, opts: shuffle(opts) });
      };

      useEffect(()=>{ makePrompt(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => t<=1 ? 0 : t-1), 1000);
        return ()=>clearInterval(id);
      },[]);

      const bump = (key, ok) => {
        const st = stats[key] || { correct:0, total:0 };
        const next = { ...stats, [key]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(SHIFT_STATS_KEY, next);
      };

      const answer = (o) => {
        const ok = !!o.ok;
        const key = `${q.string}:${q.startNote}->${q.targetNote}`;
        bump(key, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        setAnswered(a=>a+1);
        if (ok) setScore(s=>s+1);
        setTimeout(makePrompt, ok?350:700);
      };

      const labelLoc = o => `Pos ${o.p} ¬∑ F${o.f}`;

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:860}}>
            <h2 className="text-2xl font-bold mb-2">Shift Coach</h2>
            <div className="muted text-sm mb-4">Stay on one string. Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered}</div>
            {q && (
              <>
                <div className="rounded-md p-4" style={{background:'rgba(0,0,0,.05)'}}>
                  <div className="font-semibold mb-1">String: <b>{q.string}</b></div>
                  <div className="text-sm">Start at <b>{norm(q.startNote)}</b> ‚Üí <span className="muted">({`Pos ${q.start.p}, F${q.start.f}`})</span></div>
                  <div className="text-sm">Target note: <b>{norm(q.targetNote)}</b></div>
                </div>
                <div className="text-center text-sm muted mt-2 mb-4">Which <b>position + finger</b> is the best landing spot for the target?</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {q.opts.map((o,i)=>(
                    <button key={i} className="btn btn-blue" onClick={()=>answer(o)}>
                      <span className="pill" style={{background:'rgba(0,0,0,.15)'}}>{i+1}</span>&nbsp; {labelLoc(o)}
                    </button>
                  ))}
                </div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ===================== NEW: Harmonics Lab ===================== */
    const HarmonicsLab = ({ onBack, prefs }) => {
      const [mode, setMode] = useState('flash'); // flash | quiz
      const [i, setI] = useState(0);
      const [show, setShow] = useState(false);
      const [stats, setStats] = useState(loadJSON(HARM_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);

      const deck = useMemo(()=>{
        const cards = [];
        for (const s of STRINGS) {
          for (const ratio of Object.keys(HARMONICS[s])) {
            const [pitch, label] = HARMONICS[s][ratio];
            cards.push({ s, ratio, label, pitch });
          }
        }
        return cards;
      },[]);

      const next = () => { setShow(false); setI((i+1)%deck.length); };
      const prev = () => { setShow(false); setI((i-1+deck.length)%deck.length); };

      // quiz
      const [q, setQ] = useState(null);
      const makeQ = () => {
        const s = getRandomItem(STRINGS);
        const target = getRandomItem(Object.entries(HARMONICS[s])); // [ratio,[note,label]]
        const correctRatio = target[0];
        const noteName = target[1][0];
        const display = `${s} string ‚Äî play the ${noteName} harmonic`;
        const ratios = Object.keys(HARMONICS[s]);
        const distracts = shuffle(ratios.filter(r=>r!==correctRatio)).slice(0,3);
        const options = shuffle([correctRatio, ...distracts]).map(r => ({r, ok: r===correctRatio}));
        setQ({ s, note: noteName, display, options });
      };

      useEffect(()=>{ if(mode==='quiz') makeQ(); }, [mode]);

      const bump = (key, ok) => {
        const st = stats[key] || { correct:0, total:0 };
        const next = { ...stats, [key]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(HARM_STATS_KEY, next);
      };

      const answer = (opt) => {
        const ok = !!opt.ok;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        const key = `${q.s}:${q.note}`;
        bump(key, ok);
        setTimeout(makeQ, ok?350:700);
      };

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:820}}>
            <div className="flex items-center justify-between">
              <h2 className="text-2xl font-bold">Harmonics Lab</h2>
              <div className="flex gap-2">
                <button className={`btn ${mode==='flash'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('flash')}>Flashcards</button>
                <button className={`btn ${mode==='quiz'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('quiz')}>Quick Quiz</button>
              </div>
            </div>

            {mode==='flash' && (
              <div className="mt-4">
                <div className="rounded-xl border-2 p-6 text-center">
                  <div className="text-xl font-bold">{deck[i].s} string ‚Äî Node {deck[i].ratio}</div>
                  {show ? (
                    <div className="mt-2 ink700">
                      <div><b>Pitch:</b> {deck[i].pitch}</div>
                      <div><b>Type:</b> {deck[i].label}</div>
                      <div className="text-xs muted mt-1">Light touch directly above the node; release pressure for a clear chime.</div>
                    </div>
                  ) : <div className="muted italic">Press Reveal to show details.</div>}
                </div>
                <div className="flex gap-2 mt-4 justify-center">
                  <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
                  <button className="btn btn-gray" onClick={prev}>Previous</button>
                  <button className="btn btn-purple" onClick={next}>Next</button>
                </div>
                <div className="text-xs muted mt-2 text-center">Card {i+1} / {deck.length}</div>
              </div>
            )}

            {mode==='quiz' && (
              <div className="mt-4">
                {!q ? <div className="muted">Loading‚Ä¶</div> : (
                  <>
                    <div className="text-lg font-semibold mb-2">Which node ratio produces this harmonic?</div>
                    <div className="rounded-md p-4 mb-3" style={{background:'rgba(0,0,0,.05)'}}>
                      {q.display}
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                      {q.options.map((o,idx)=>(
                        <button key={idx} className="btn btn-blue" onClick={()=>answer(o)}>{o.r}</button>
                      ))}
                    </div>
                  </>
                )}
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Speed Ladder (fingerboard)
    const SpeedLadderGame = ({ onBack, prefs, stats, setStats }) => {
      const allCombos = useMemo(()=>allActualCombos(), []);
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);
      const [question, setQuestion] = useState(null);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [timer, setTimer] = useState(prefs.roundLen || 120);
      const [finished, setFinished] = useState(false);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(loadBest().bestStreak);
      const [bestScore, setBestScore] = useState(loadBest().bestScore);
      const [confettiSeed, setConfettiSeed] = useState(0);
      const optionsRef = useRef([]);
      const lastMissRef = useRef(null);

      const candidates = useMemo(()=>{
        const f = prefs.filters||{};
        const okS = f.strings||{}; const okP = f.positions||{}; const okF = f.fingers||{};
        const sel = allCombos.filter(c => (okS[c.s]!==false) && (okP[c.p]!==false) && (okF[c.f]!==false));
        return sel.length ? sel : allCombos;
      }, [allCombos, prefs.filters]);

      const weightedPick = () => {
        if (!prefs.adaptive) return getRandomItem(candidates);
        const entries = candidates.map(c=>{
          const k = `${c.s}:${c.p}:${c.f}`; const st = stats[k]; const total = st?.total ?? 0; const correct = st?.correct ?? 0;
          const acc = total > 0 ? correct/total : 0; const unseenBoost = total===0 ? .6 : 0;
          let weight = .1 + (1-acc) + unseenBoost;
          if (prefs.coach) weight *= 1 + (1-acc);
          return { combo:c, weight: Math.max(.05, weight) };
        });
        if (prefs.coach && prefs.coachRetry && lastMissRef.current){
          const miss = lastMissRef.current;
          const idx = entries.findIndex(e=> e.combo.s===miss.s && e.combo.p===miss.p && e.combo.f===miss.f);
          if (idx>=0) entries[idx].weight*=2.2;
        }
        const sum = entries.reduce((a,e)=>a+e.weight,0)||1; let r = Math.random()*sum;
        for (const e of entries){ if((r-=e.weight)<=0) return e.combo; }
        return entries[entries.length-1].combo;
      };

      const newQuestion = (preset=null) => {
        const c = preset || weightedPick();
        const correct = getRandomItem(c.valid);
        const opts = shuffle([correct, ...getRandomDistractors(new Set([correct]),3)]);
        optionsRef.current = opts;
        setQuestion({ ...c, correct, options: opts });
        speak(`${c.s}, position ${c.p}, finger ${c.f}`);
      };

      useEffect(()=>{ newQuestion(); }, []);
      useEffect(()=>{
        if (finished) return;
        const id = setInterval(()=>setTimer(t=>{
          if(t<=1){
            clearInterval(id); setFinished(true);
            const bs = Math.max(bestScore, score); const bk = Math.max(bestStreak, streak);
            setBestScore(bs); setBestStreak(bk); saveBest({ bestScore:bs, bestStreak:bk }); return 0;
          }
          return t-1;
        }), 1000);
        return ()=>clearInterval(id);
      }, [finished, score, streak, bestScore, bestStreak]);

      const handleAnswer = (note) => {
        if (finished || !question) return;
        const key = `${question.s}:${question.p}:${question.f}`;
        const prev = stats[key] || { correct:0, total:0 };
        const ok = (note===question.correct);
        const updated = { ...stats, [key]: { correct: prev.correct + (ok?1:0), total: prev.total + 1 } };
        setStats(updated); saveStats(updated);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setAnswered(a=>a+1);
        if (ok){
          lastMissRef.current=null; beeps.good(); setScore(s=>s+1); setStreak(x=>x+1); if (prefs.confetti) setConfettiSeed(x=>x+1);
          setTimeout(()=>newQuestion(), prefs.coach ? 380 : 550);
        } else {
          lastMissRef.current={ s:question.s, p:question.p, f:question.f, valid:question.valid };
          beeps.bad(); setStreak(0);
          setTimeout(()=>{
            if (prefs.coach && prefs.coachRetry){
              const miss=lastMissRef.current;
              if(miss){
                const c = getRandomItem(miss.valid);
                const opts = shuffle([c, ...getRandomDistractors(new Set([c]),3)]);
                optionsRef.current=opts; setQuestion({ ...miss, correct:c, options:opts }); return;
              }
            }
            newQuestion();
          }, 900);
        }
      };

      useEffect(()=>{
        const onKey=(e)=>{ if(finished) return; const k=e.key.toLowerCase(); if(['1','2','3','4'].includes(k)){ const idx=Number(k)-1; const raw=optionsRef.current?.[idx]; if(raw) handleAnswer(raw); } };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [finished, question]);

      const reset = () => { setScore(0); setAnswered(0); setTimer(prefs.roundLen||120); setFinished(false); setStreak(0); setConfettiSeed(0); newQuestion(); };

      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8" style={{maxWidth:740, width:'100%'}}>
            <h2 className="text-2xl font-bold mb-2">Speed Ladder</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> ¬∑ Score: <b>{score}</b> / {answered} ¬∑ Best: <b>{bestScore}</b> ¬∑ Best streak: <b>{bestStreak}</b></div>
            {!finished && question && (
              <>
                <div className="text-center mb-5">
                  <div className="text-xl font-bold">
                    What note can you play with <b>F{question.f}</b> on <b>{question.s}</b> in <b>Position {question.p}</b>?
                  </div>
                  <div className="text-xs muted mt-1">Press 1‚Äì4 to answer fast.</div>
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {question.options.map((note, i)=>(
                    <button key={i} className="btn btn-blue" title={`Press ${i+1}`} onClick={()=>handleAnswer(note)}>
                      <span className="pill" style={{ background: 'rgba(0,0,0,.15)' }}>{i+1}</span>&nbsp; {norm(note)}
                    </button>
                  ))}
                </div>
              </>
            )}
            {finished && (
              <div className="text-center">
                <div className="text-xl font-semibold">Round over! Final score: {score} / {answered}</div>
                <button className="btn btn-purple mt-3" onClick={reset}>Play Again</button>
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Flashcards (fingerboard)
    const Flashcards = ({ onBack }) => {
      const [mode, setMode] = useState('A');
      const [i, setI] = useState(0);
      const [show,setShow] = useState(false);
      const deckA = useMemo(()=>{
        const cards=[]; for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
          const cell = validCell(s,p,f);
          if (cell) cards.push({q:`What note(s) under F${f} on ${s} in Position ${p}?`, a: cell.map(norm).join(' or ')});
        }
        return cards;
      },[]);
      const uniq = useMemo(()=>[...new Set(ALL_NOTES_UNIQUE)].sort(),[]);
      const deckB = useMemo(()=>uniq.map(n=>({q:`Where can you play ${norm(n)} (Pos 1‚Äì5)?`, a:groupLocationsByString(n)})),[uniq]);
      const deck = mode==='A'?deckA:deckB;
      const next=()=>{ setShow(false); setI((i+1)%deck.length); };
      const prev=()=>{ setShow(false); setI((i-1+deck.length)%deck.length); };
      useEffect(()=>{ const onKey=(e)=>{ const k=e.key.toLowerCase(); if(k===' '){e.preventDefault();setShow(true);} if(k==='n'||k==='arrowright') next(); if(k==='p'||k==='arrowleft') prev(); }; window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); }, [i,show]);
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:760}}>
            <h2 className="text-2xl font-bold mb-4">Flashcards</h2>
            <div className="flex gap-2 mb-3">
              <button className={`btn ${mode==='A'?'btn-purple':'btn-gray'}`} onClick={()=>{setMode('A'); setI(0); setShow(false);}}>Deck A</button>
              <button className={`btn ${mode==='B'?'btn-purple':'btn-gray'}`} onClick={()=>{setMode('B'); setI(0); setShow(false);}}>Deck B</button>
            </div>
            <div className="rounded-xl border-2 p-6 text-center">
              <div className="text-lg font-bold">{deck[i].q}</div>
              {show ? <div className="mt-2 ink700 whitespace-pre-wrap">{deck[i].a}</div> : <div className="muted italic">Press Space or tap ‚ÄúReveal‚Äù.</div>}
            </div>
            <div className="flex gap-2 mt-6 justify-center">
              <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
              <button className="btn btn-gray" onClick={prev}>Previous</button>
              <button className="btn btn-purple" onClick={next}>Next</button>
            </div>
            <div className="text-xs muted mt-3 text-center">Card {i+1} / {deck.length} ¬∑ Shortcuts: Space, ‚Üê/‚Üí or P/N</div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Bingo
    const BingoBoard = ({ onBack }) => {
      const base = [
        "Say & play A-string Pos 2 F1‚ÄìF4 aloud","Upbeat start √ó8 bars","Bridge-lane forte √ó4 bars","Name all B notes Pos 1‚Äì5","Sight-read in Pos 2",
        "G-string Pos 1 quiz","C major in Pos 3 aloud","Find 3 ways to play D","E-string Pos 4 quiz","Slur ‚Üí up-bow staccato",
        "Name all Cs Pos 1‚Äì5","D major in Pos 5 aloud","Echo dynamics on repeat","Open A & D ring check","A-string Pos 3 quiz",
        "List all F#s Pos 1‚Äì5","Gigue pickup (up-bow)","Martel√© √ó8 bars","Map staff lines ‚Üí fingers","D-string Pos 4 quiz",
        "Contact-point ladders","Slow spiccato √ó8 bars","Tempo flashcards √ó20","Record 30s and review"
      ];
      const makeBoard=()=>{ const grid = shuffle(base).slice(0,24); grid.splice(12,0,'FREE'); return grid; };
      const [tiles,setTiles]=useState(makeBoard);
      const [on,setOn]=useState(()=>{ const o={}; tiles.forEach(t=>o[t]= (t==='FREE')); return o; });
      const toggle=(t)=>{ if(t==='FREE') return; setOn(s=>({...s,[t]:!s[t]})); };
      const reset=()=>{ const nx=makeBoard(); setTiles(nx); const o={}; nx.forEach(t=>o[t]=(t==='FREE')); setOn(o); };
      const checked = Object.values(on).filter(Boolean).length;
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-6 w-full" style={{maxWidth:960}}>
            <div className="flex items-center justify-between mb-2">
              <div className="text-2xl font-bold">Positions Bingo</div>
              <button className="btn btn-purple" onClick={reset}>New Board</button>
            </div>
            <div className="muted text-sm mb-2">Checked: {checked}/25 ¬∑ Center is FREE</div>
            <div className="grid grid-cols-5 gap-2">
              {tiles.map((t,i)=>(
                <button key={i} onClick={()=>toggle(t)}
                  className={`rounded-lg border-2 p-2 h-24 text-xs ${on[t]?'bg-green-500 text-white border-green-700':'bg-gray-200 text-gray-800 border-gray-300'}`}>
                  {t}
                </button>
              ))}
            </div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    // Dice
    const DiceOfDestinyGame = ({ onBack }) => {
      const poolFull = [
        'Say & play A-string Pos 2 F1‚ÄìF4 aloud','Upbeat start √ó8 bars','Bridge-lane forte √ó4 bars','Name all B notes Pos 1‚Äì5',
        'Sight-read in Pos 2','G-string Pos 1 quiz','C major in Pos 3 aloud','Find 3 ways to play D','E-string Pos 4 quiz',
        'Slur ‚Üí up-bow staccato','Name all Cs Pos 1‚Äì5','D major in Pos 5 aloud','Echo dynamics on repeat','Open A & D ring check',
        'A-string Pos 3 quiz','List all F#s Pos 1‚Äì5','Gigue pickup (up-bow)','Martel√© √ó8 bars','Map staff lines ‚Üí fingers','D-string Pos 4 quiz',
      ];
      const [pool,setPool]=useState(poolFull);
      const [cur,setCur]=useState('');
      const [busy,setBusy]=useState(false);
      const [history,setHistory]=useState([]);
      const roll=()=>{ setBusy(true); setCur('‚Ä¶'); setTimeout(()=>{ const p = pool.length ? pool : poolFull; const pick = getRandomItem(p); setCur(pick); setHistory(h=>[pick,...h].slice(0,6)); setPool(p.filter(x=>x!==pick)); setBusy(false); }, 560); };
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-4">Dice of Destiny</h2>
            <button disabled={busy} className="btn btn-green text-xl" onClick={roll}>{busy?'‚Ä¶':'Roll Dice'}</button>
            <div className="rounded-lg p-4 mt-6" style={{ background: 'rgba(0,0,0,.07)' }}>
              <div className="text-sm muted">Your Destiny:</div>
              <div className="text-xl font-bold mt-2">{cur || 'Press Roll to begin!'}</div>
            </div>
            {!!history.length && <div className="mt-4">
              <div className="font-semibold text-sm mb-1">Recent rolls</div>
              <ul className="text-sm">{history.map((h,i)=><li key={i}>‚Ä¢ {h}</li>)}</ul>
            </div>}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* =========================================================
       Bieler Method Lab
    ========================================================== */
    const BielerLab = ({ onBack }) => {
      const [mode,setMode]=useState('vocab'); // vocab | concept | apply
      const [i,setI]=useState(0); const [show,setShow]=useState(false);
      const next=()=>{ setShow(false); setI((i+1)%BIELER_VOCAB.length); };
      const prev=()=>{ setShow(false); setI((i-1+BIELER_VOCAB.length)%BIELER_VOCAB.length); };

      const makeConceptQ = () => {
        const item = getRandomItem(BIELER_CONCEPT_QA);
        const options = shuffle([item.a, ...shuffle(item.wrong).slice(0,3)]);
        return { prompt:item.q, correct:item.a, options };
      };
      const makeApplyQ = () => {
        const item = getRandomItem(BIELER_APPLY);
        const options = shuffle([item.answer, ...shuffle(item.wrong).slice(0,3)]);
        return { prompt:item.scenario, correct:item.answer, options };
      };
      const [cq,setCq]=useState(makeConceptQ());
      const [aq,setAq]=useState(makeApplyQ());
      const [scoreC,setScoreC]=useState(0), [answeredC,setAnsweredC]=useState(0);
      const [scoreA,setScoreA]=useState(0), [answeredA,setAnsweredA]=useState(0);

      const answerConcept = (opt)=>{ const ok = opt===cq.correct; document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again'; setScoreC(s=>s+(ok?1:0)); setAnsweredC(a=>a+1); setTimeout(()=>setCq(makeConceptQ()), ok?350:700); };
      const answerApply   = (opt)=>{ const ok = opt===aq.correct; document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again'; setScoreA(s=>s+(ok?1:0)); setAnsweredA(a=>a+1); setTimeout(()=>setAq(makeApplyQ()), ok?350:700); };

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-6 w-full" style={{maxWidth:980}}>
            <div className="flex items-center justify-between">
              <h2 className="text-2xl font-bold">Bieler Method Lab</h2>
              <div className="flex gap-2">
                <button className={`btn ${mode==='vocab'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('vocab')}>Vocabulary</button>
                <button className={`btn ${mode==='concept'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('concept')}>Concept Check</button>
                <button className={`btn ${mode==='apply'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('apply')}>Applications</button>
              </div>
            </div>

            {mode==='vocab' && (
              <div className="mt-4">
                <div className="rounded-xl border-2 p-6 text-center">
                  <div className="text-xl font-bold">{BIELER_VOCAB[i].term}</div>
                  {show ? <div className="mt-2 ink700">{BIELER_VOCAB[i].def}</div> : <div className="muted italic">Press Reveal to show definition.</div>}
                </div>
                <div className="flex gap-2 mt-4 justify-center">
                  <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
                  <button className="btn btn-gray" onClick={prev}>Previous</button>
                  <button className="btn btn-purple" onClick={next}>Next</button>
                </div>
                <div className="text-xs muted mt-2 text-center">Card {i+1} / {BIELER_VOCAB.length}</div>
              </div>
            )}

            {mode==='concept' && (
              <div className="mt-4">
                <div className="muted text-sm mb-2">Score: {scoreC} / {answeredC}</div>
                <div className="text-lg font-semibold mb-2">{cq.prompt}</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  {cq.options.map((o,idx)=><button key={idx} className="btn btn-blue" onClick={()=>answerConcept(o)}>{o}</button>)}
                </div>
              </div>
            )}

            {mode==='apply' && (
              <div className="mt-4">
                <div className="muted text-sm mb-2">Score: {scoreA} / {answeredA}</div>
                <div className="text-lg font-semibold mb-2">Choose the best practice approach:</div>
                <div className="ink700 mb-3"><i>Scenario: </i>{aq.prompt}</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  {aq.options.map((o,idx)=><button key={idx} className="btn btn-blue" onClick={()=>answerApply(o)}>{o}</button>)}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* =========================================================
       Filters & Panels
    ========================================================== */
    const FiltersPanel = ({ prefs, setPrefs, stats, onResetStats, onExportCSV }) => {
      const f = prefs.filters;
      const toggle=(group,key)=>{
        setPrefs(p=>{ const next={...p, filters:{...p.filters, [group]:{...p.filters[group],[key]:!p.filters[group][key]}}}; savePrefs(next); return next; });
      };
      const setAll=(group,val)=>{
        setPrefs(p=>{ const obj=Object.fromEntries(Object.keys(p.filters[group]).map(k=>[k,val])); const next={...p, filters:{...p.filters, [group]:obj}}; savePrefs(next); return next; });
      };
      return (
        <div className="card rounded-xl p-4">
          <div className="flex flex-wrap items-center gap-3 justify-between">
            <div className="text-sm">Round:
              <select className="ml-2 border rounded p-1 text-sm" value={prefs.roundLen} onChange={e=>{ const n={...prefs, roundLen:Number(e.target.value)}; setPrefs(n); savePrefs(n); }}>
                {[30,60,90,120,180].map(x=><option key={x} value={x}>{x}s</option>)}
              </select>
            </div>
            <div className="flex flex-wrap gap-3 items-center">
              <label className="text-sm"><input type="checkbox" checked={prefs.adaptive} onChange={e=>{ const n={...prefs, adaptive:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Adaptive</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.coach} onChange={e=>{ const n={...prefs, coach:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Coach</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.coachRetry} onChange={e=>{ const n={...prefs, coachRetry:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Retry after miss</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.sound} onChange={e=>{ const n={...prefs, sound:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Sound</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.confetti} onChange={e=>{ const n={...prefs, confetti:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Confetti</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.callouts} onChange={e=>{ const n={...prefs, callouts:e.target.checked}; setPrefs(n); savePrefs(n); }} /> Call-outs</label>
            </div>
            <div className="flex gap-2">
              <button className="btn btn-rose" onClick={onResetStats}>Reset All Stats</button>
              <button className="btn btn-green" onClick={onExportCSV}>Export CSV</button>
            </div>
          </div>

          <div className="grid md:grid-cols-3 gap-4 mt-4">
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Strings</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('strings',true)}>All</span> ¬∑ <span className="linkish" onClick={()=>setAll('strings',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {STRINGS.map(s=>(
                  <button key={s} className={`pill ${f.strings[s]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('strings',s)}>{s}</button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Positions</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('positions',true)}>All</span> ¬∑ <span className="linkish" onClick={()=>setAll('positions',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {POSITIONS.map(p=>(
                  <button key={p} className={`pill ${f.positions[p]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('positions',p)}>Pos {p}</button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Fingers</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('fingers',true)}>All</span> ¬∑ <span className="linkish" onClick={()=>setAll('fingers',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {FINGERS.map(fn=>(
                  <button key={fn} className={`pill ${f.fingers[fn]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('fingers',fn)}>F{fn}</button>
                ))}
              </div>
            </div>
          </div>

          <p className="text-xs muted mt-3">Focus Mode pulls only from your selected subset (falls back to all if deselected). F0 = open string (Pos 1 only).</p>
        </div>
      );
    };

    /* =========================================================
       Dashboard
    ========================================================== */
    const Dashboard = ({ go, prefs, setPrefs, stats, setStats }) => {
      const [helpKey,setHelpKey]=useState(null);
      const [theme, setThemeState] = useState(getTheme());
      const [updateReady,setUpdateReady]=useState(false);

      // Backup & Restore
      const backup = () => {
        const payload = {
          [PREFS_KEY]: JSON.parse(localStorage.getItem(PREFS_KEY) || 'null'),
          [STATS_KEY]: JSON.parse(localStorage.getItem(STATS_KEY) || 'null'),
          [BEST_KEY]: JSON.parse(localStorage.getItem(BEST_KEY) || 'null'),
          [TEMPO_STATS_KEY]: JSON.parse(localStorage.getItem(TEMPO_STATS_KEY) || 'null'),
          [TEMPO_BEST_KEY]: JSON.parse(localStorage.getItem(TEMPO_BEST_KEY) || 'null'),
          [SEYBOLD_KEY]: JSON.parse(localStorage.getItem(SEYBOLD_KEY) || 'null'),
          [SCORE_KEY]: JSON.parse(localStorage.getItem(SCORE_KEY) || 'null'),
          [BADGES_KEY]: JSON.parse(localStorage.getItem(BADGES_KEY) || 'null'),
          [PRESETS_KEY]: JSON.parse(localStorage.getItem(PRESETS_KEY) || 'null'),
          [SESSIONLOG_KEY]: JSON.parse(localStorage.getItem(SESSIONLOG_KEY) || 'null'),
          [HEIGHT_STATS_KEY]: JSON.parse(localStorage.getItem(HEIGHT_STATS_KEY) || 'null'),
          [LOCATOR_STATS_KEY]: JSON.parse(localStorage.getItem(LOCATOR_STATS_KEY) || 'null'),
          [SHIFT_STATS_KEY]: JSON.parse(localStorage.getItem(SHIFT_STATS_KEY) || 'null'),
          [HARM_STATS_KEY]: JSON.parse(localStorage.getItem(HARM_STATS_KEY) || 'null'),
        };
        const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download='vpq_backup.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };
      const restore = async (file) => {
        try {
          const txt = await file.text();
          const obj = JSON.parse(txt);
          Object.entries(obj).forEach(([k,v])=>{ if (v!==undefined && v!==null) localStorage.setItem(k, JSON.stringify(v)); });
          alert('Backup restored. The page will now reload to apply it.'); location.reload();
        } catch(e){ alert('Import failed: ' + e.message); }
      };
      const inputRef = useRef(null);

      // Immediate win #5: generalized CSV export across modes
      const exportCSV = () => {
        const rows = [['mode','key','correct','total','accuracy']];
        const packs = [
          ['speed', stats],
          ['height', loadJSON(HEIGHT_STATS_KEY, {})],
          ['locator', loadJSON(LOCATOR_STATS_KEY, {})],
          ['shift', loadJSON(SHIFT_STATS_KEY, {})],
          ['harmonics', loadJSON(HARM_STATS_KEY, {})],
        ];
        for (const [mode, obj] of packs) {
          Object.entries(obj).forEach(([k, v]) => {
            if (v && typeof v === 'object') {
              // height stats store nested {low/high/natural}
              if ('low' in v && 'high' in v) {
                ['low','high','natural'].forEach(h=>{
                  const c=v[h]?.correct||0, t=v[h]?.total||0, a=t? (c/t).toFixed(4):'0.0000';
                  rows.push([`${mode}:${h}`, k, c, t, a]);
                });
              } else {
                const c=v.correct||0, t=v.total||0, a=t? (c/t).toFixed(4):'0.0000';
                rows.push([mode, k, c, t, a]);
              }
            }
          });
        }
        const csv = rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
        const url = URL.createObjectURL(new Blob([csv], {type:'text/csv'}));
        const a = Object.assign(document.createElement('a'), {href:url, download:'positions_training_stats.csv'});
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };

      const resetAll = () => { if(!confirm('Reset all fingerboard stats & bests?')) return;
        localStorage.removeItem(BEST_KEY); localStorage.removeItem(STATS_KEY);
        localStorage.removeItem(HEIGHT_STATS_KEY); localStorage.removeItem(LOCATOR_STATS_KEY);
        localStorage.removeItem(SHIFT_STATS_KEY); localStorage.removeItem(HARM_STATS_KEY);
        setStats({}); alert('Stats cleared.'); };

      useEffect(()=>{
        // Immediate win #7: prompt only when the new worker is ready
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.getRegistration().then(reg=>{
            if (!reg) return;
            reg.addEventListener('updatefound', ()=>{
              const nw = reg.installing;
              nw?.addEventListener('statechange', ()=>{
                if (nw.state === 'installed' && navigator.serviceWorker.controller) {
                  setUpdateReady(true);
                }
              });
            });
          });
          navigator.serviceWorker.addEventListener('controllerchange', ()=>{ /* optional auto-reload */ });
        }
      },[]);

      const toggleTheme = () => { const next = theme==='light'?'dark':'light'; setTheme(next); setThemeState(next); };

      return (
        <div className="p-4">
          <header className="mb-4 flex items-center justify-between">
            <div>
              <div className="text-3xl font-bold">Violin Positions Quest</div>
              <div className="muted text-sm">Your daily mission to master the fingerboard‚Äîand beyond.</div>
            </div>
            <div className="flex items-center gap-2">
              <button className="btn btn-gray" onClick={toggleTheme}>{theme==='dark'?'Light':'Dark'} Mode</button>
              <button className="btn btn-green" onClick={backup}>Backup</button>
              <button className="btn btn-blue" onClick={()=>inputRef.current?.click()}>Restore</button>
              <input ref={inputRef} type="file" accept="application/json" hidden onChange={e=>e.target.files[0] && restore(e.target.files[0])}/>
            </div>
          </header>

          <div className="grid-cards">
            <CardButton title="Speed Ladder" description="Adaptive fingerboard quiz (Pos 1‚Äì5). Coach + retries." onClick={()=>go('speed')} onHelp={()=>setHelpKey('speed')} />
            <CardButton title="Finger Height Drill" description="Low vs High fingers for intonation." onClick={()=>go('height')} onHelp={()=>setHelpKey('height')} />
            <CardButton title="Note Locator" description="Pick a valid string/position/finger for a pitch." onClick={()=>go('locator')} onHelp={()=>setHelpKey('locator')} />
            <CardButton title="Shift Coach" description="Choose efficient shifts on one string." onClick={()=>go('shift')} onHelp={()=>setHelpKey('shift')} />
            <CardButton title="Harmonics Lab" description="Natural nodes (1/2, 1/3, 1/4) per string." onClick={()=>go('harmonics')} onHelp={()=>setHelpKey('harmonics')} />
            <CardButton title="Flashcards Mode" description="Two decks: direct hits + note‚Üílocations." onClick={()=>go('cards')} onHelp={()=>setHelpKey('cards')} />
            <CardButton title="Positions Bingo" description="Fill a line with focused tasks." onClick={()=>go('bingo')} onHelp={()=>setHelpKey('bingo')} />
            <CardButton title="Dice of Destiny" description="Roll for a practice challenge." onClick={()=>go('dice')} onHelp={()=>setHelpKey('dice')} />
            <CardButton title="Tempo Trainer" description="Italian‚ÜíEnglish flashcards with call-outs." onClick={()=>go('tempoTrainer')} onHelp={()=>setHelpKey('tempoTrainer')} />
            <CardButton title="Tempo Tester" description="Timed MCQ with heatmap + review misses." onClick={()=>go('tempoTester')} onHelp={()=>setHelpKey('tempoTester')} />
            <CardButton title="Bieler Method Lab" description="Vocabulary ‚Üí concepts ‚Üí applications." onClick={()=>go('bielerLab')} onHelp={()=>setHelpKey('bielerLab')} />
          </div>

          <div className="mt-6 grid gap-4" style={{ gridTemplateColumns: '1fr' }}>
            <FiltersPanel prefs={prefs} setPrefs={setPrefs} stats={stats} onResetStats={resetAll} onExportCSV={exportCSV} />
            <AccuracyHeatmap stats={stats} />
          </div>

          <Modal open={!!helpKey} onClose={()=>setHelpKey(null)} title="How to play">
            {helpKey ? HELP[helpKey] : ''}
          </Modal>

          <Toast open={updateReady} text="An update is ready. Refresh to get the latest." action="Refresh" onAction={()=>location.reload()} />
        </div>
      );
    };

    /* =========================================================
       App
    ========================================================== */
    const App = () => {
      const [view,setView]=useState('dashboard');
      const [prefs,setPrefs]=useState(loadPrefs());
      const [stats,setStats]=useState(loadStats());

      useEffect(()=>savePrefs(prefs),[prefs]);
      useEffect(()=>saveStats(stats),[stats]);

      const go = (v)=>setView(v);

      // iOS audio/TTS unlock on first gesture
      useEffect(()=>{
        const unlock=()=>{ try{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); if(ctx&&ctx.state==='suspended') ctx.resume(); }catch{} if(window.speechSynthesis){ try{ window.speechSynthesis.cancel(); }catch{} } window.removeEventListener('touchend',unlock); window.removeEventListener('click',unlock); };
        window.addEventListener('touchend',unlock,{once:true}); window.addEventListener('click',unlock,{once:true});
      },[]);

      return (
        <div style={{minHeight:'100vh'}}>
          {view==='dashboard'   && <Dashboard go={go} prefs={prefs} setPrefs={setPrefs} stats={stats} setStats={setStats} />}
          {view==='speed'       && <SpeedLadderGame prefs={prefs} stats={stats} setStats={setStats} onBack={()=>setView('dashboard')} />}
          {view==='height'      && <HeightDrill prefs={prefs} onBack={()=>setView('dashboard')} />}
          {view==='locator'     && <NoteLocator prefs={prefs} onBack={()=>setView('dashboard')} />}
          {view==='shift'       && <ShiftCoach prefs={prefs} onBack={()=>setView('dashboard')} />}
          {view==='harmonics'   && <HarmonicsLab prefs={prefs} onBack={()=>setView('dashboard')} />}
          {view==='cards'       && <Flashcards onBack={()=>setView('dashboard')} />}
          {view==='bingo'       && <BingoBoard onBack={()=>setView('dashboard')} />}
          {view==='dice'        && <DiceOfDestinyGame onBack={()=>setView('dashboard')} />}
          {view==='tempoTrainer'&& <TempoTrainer prefs={prefs} onBack={()=>setView('dashboard')} />}
          {view==='tempoTester' && <TempoTester prefs={prefs} onBack={()=>setView('dashboard')} />}
          {view==='bielerLab'   && <BielerLab onBack={()=>setView('dashboard')} />}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>

  <!-- Service worker registration (explicit GitHub Pages scope) -->
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("/violin-positions-quest/sw.js", { scope: "/violin-positions-quest/" })
          .catch(()=>{});
      });
    }
  </script>
</body>
</html>
