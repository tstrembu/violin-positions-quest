<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Mastery Quest – Enhanced Trainer (v5)</title>
  <!--
    v5 Changelog (2025-09-04):
    - Redesigned home page into three large cards: Play, Study, Progress & Settings with emoji icons.
    - Added VisualFingerboard component skeleton (SVG grid for strings/positions/fingers). Highlights support and click-to-select capability.
    - Added basic AudioEngine stub with mute toggle; plays notes and intervals (oscillator based).
    - Added Mute toggle and Data export/import/reset utilities in Settings.
    - Snapshot difficulty control retained; added cleanup on unmount.
    - Interval Sprint prompt now uses actual note names instead of finger numbers.
    - Improved button consistency using OptionButton across settings.
    - Added progress bars to theory trainers.
    - Various minor bug fixes and accessibility improvements.
    - Added Bieler Method Lab with vocabulary, concept check, and application modes.
  -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#f8fafc; --card:#fff; --ink:#0f172a; --ink-light:#475569; --primary:#6d28d9; --primary-dark:#5b21b6; --success:#16a34a; --warning:#fbbf24; --danger:#dc2626; --neutral:#9ca3af; --border:rgba(0,0,0,0.1); }
    :root.dark { --bg:#0b1426; --card:#0f1f3d; --ink:#e2e8f0; --ink-light:#94a3b8; --primary:#a78bfa; --primary-dark:#7c3aed; --success:#22c55e; --warning:#facc15; --danger:#ef4444; --neutral:#6b7280; --border:rgba(255,255,255,0.15); }
    body { margin:0; font-family: 'Inter', sans-serif; background:var(--bg); color:var(--ink); padding-bottom:60px; }
    .container { max-width: 960px; margin:auto; padding:1rem; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:1rem 1.5rem; margin-bottom:1.5rem; box-shadow:0 4px 20px rgba(0,0,0,0.05); }
    .btn { display:inline-flex; align-items:center; justify-content:center; padding:0.6rem 1rem; border-radius:9999px; margin:0.25rem; border:none; font-weight:600; cursor:pointer; color:#fff; }
    .btn-primary { background:var(--primary); }
    .btn-primary:hover { background:var(--primary-dark); }
    .btn-secondary { background:var(--ink-light); }
    .btn-secondary:hover { background:var(--ink); }
    .btn-success { background:var(--success); }
    .btn-warning { background:var(--warning); }
    .btn-danger { background:var(--danger); }
    .grid { display:grid; gap:1rem; }
    @media(min-width:640px){ .grid-cols-2 { grid-template-columns: repeat(2,1fr); } }
    .heat-cell { height:2rem; display:flex; align-items:center; justify-content:center; font-size:0.7rem; color:#fff; border-radius:4px; }
    .option-btn { width:100%; padding:0.6rem; border-radius:9999px; margin:0.25rem 0; color:#fff; border:none; cursor:pointer; font-weight:600; }
    .btn:focus-visible, .option-btn:focus-visible { outline:3px solid var(--primary); outline-offset:2px; }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
  </style>
  <script>
    (function(){
      const KEY='vmq.theme';
      const saved=localStorage.getItem(KEY);
      const prefers=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const dark=saved? saved==='dark':prefers;
      document.documentElement.classList.toggle('dark', dark);
      window.__setTheme=(d)=>{ localStorage.setItem(KEY,d?'dark':'light'); document.documentElement.classList.toggle('dark', d); };
    })();
  </script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <div id="sr" class="sr-only" aria-live="polite"></div>
  <script type="text/babel">
    // Helpers
    const loadJSON=(k,fb)=>{ try{ const v=JSON.parse(localStorage.getItem(k)); return v ?? fb; }catch{return fb;} };
    const saveJSON=(k,v)=>{ try{ localStorage.setItem(k,JSON.stringify(v)); }catch{} };
    const STRINGS=['G','D','A','E'];
    const POSITIONS=[1,2,3,4,5];
    const FINGERS=[1,2,3,4];
    const OPEN_PC={G:7,D:2,A:9,E:4};
    const BASE_OFF={1:2,2:4,3:5,4:7};
    const POS_SHIFT={1:0,2:2,3:3,4:5,5:7};
    const NOTE_NAME={0:'C',1:'Db',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};
    const MIDI_BASE={ G:55, D:62, A:69, E:76 };

    // Audio engine for simple oscillator notes and intervals
    class AudioEngine{
      constructor(){ this.ctx=null; this.mute=loadJSON('vmq.v4.mute',false); }
      ensure(){ 
        if(!this.ctx) this.ctx=new (window.AudioContext||window.webkitAudioContext)(); 
        if(this.ctx.state==='suspended') this.ctx.resume(); 
        return this.ctx; 
      }
      playNote({midi,durationMs=800}){
        if(this.mute) return;
        const ctx=this.ensure();
        const now=ctx.currentTime;
        const freq=440*Math.pow(2,(midi-69)/12);
        const osc=ctx.createOscillator();
        const gain=ctx.createGain();
        osc.frequency.value=freq;
        osc.type='sine';
        gain.gain.setValueAtTime(0,now);
        gain.gain.linearRampToValueAtTime(0.8,now+0.01);
        gain.gain.exponentialRampToValueAtTime(0.1,now+durationMs/1000*0.8);
        gain.gain.linearRampToValueAtTime(0,now+durationMs/1000);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now+durationMs/1000);
        osc.onended = () => {
          try { osc.disconnect(); gain.disconnect(); } catch {}
        };
      }
      playInterval({rootMidi,semitones,gapMs=150,durationMs=600}){
        if(this.mute) return;
        this.ensure();
        this.playNote({midi:rootMidi, durationMs});
        const midi2 = rootMidi + semitones;
        setTimeout(() => {
          this.playNote({midi:midi2, durationMs});
        }, gapMs);
      }
      setMute(m){ this.mute=m; saveJSON('vmq.v4.mute',m); }
    }
    const audioEngine=new AudioEngine();

    const canonicalBase=(s,p,f)=>{ const semi=OPEN_PC[s]+POS_SHIFT[p]+BASE_OFF[f]; return NOTE_NAME[((semi%12)+12)%12]; };
    const CELLS=[]; for(const s of STRINGS) for(const p of POSITIONS) for(const f of FINGERS){ CELLS.push({s,p,f,canon:canonicalBase(s,p,f)}); }
    const XP_KEY='vmq.v4.xp';
    const STATS_KEY='vmq.v4.stats';
    const PREFS_KEY='vmq.v4.prefs';
    const FLASH_SIG_KEY='vmq.v4.flashcards.sig';
    const FLASH_KEY='vmq.v4.flashcards';
    const levelForXP=(xp)=>Math.floor(Math.pow(xp/300,0.75))+1;
    const nextLevelXP=(lvl)=>Math.round(300*Math.pow(lvl,1.4));
    const addXP=(amt)=>{ const xp=loadJSON(XP_KEY,0)+amt; saveJSON(XP_KEY,xp); return xp; };
    const updateStat=(key,ok)=>{ const stats=loadJSON(STATS_KEY,{}); const st=stats[key]||{correct:0,total:0}; st.total+=1; if(ok) st.correct+=1; stats[key]=st; saveJSON(STATS_KEY,stats); };
    const shuffle=a=>{ const arr=[...a]; for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; };
    const getRandom=a=>a[Math.floor(Math.random()*a.length)];
    const ordinal=n=>{ const s=['th','st','nd','rd'],v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]); };
    const defaultPrefs={
      strings:Object.fromEntries(STRINGS.map(s=>[s,true])),
      positions:Object.fromEntries(POSITIONS.map(p=>[p,true])),
      flashLevel:'Professional'
    };
    const FLASH_DURATIONS={
      Beginner:3000,
      Intermediate:2000,
      Advanced:1200,
      Professional:800,
      Master:500
    };
    const filteredCells=prefs=>CELLS.filter(c=>prefs.strings[c.s]&&prefs.positions[c.p]);

    // Hook for keyboard shortcuts
    function useAnswerHotkeys(enabled,onIndex,onBack,count=4){
      React.useEffect(()=>{
        if(!enabled) return;
        const handler=(e)=>{
          const t = e.target;
          const tag = (t && t.tagName || '').toLowerCase();
          if(tag==='input' || tag==='select' || tag==='textarea' || (t && t.isContentEditable)) return;
          const k=e.key;
          if(k>='1' && k<='9'){
            const idx=Number(k)-1;
            if(idx < (count??4)) onIndex(idx);
          } else if(k==='Enter') {
            onIndex(0);
          } else if(k==='Escape') {
            onBack();
          }
        };
        window.addEventListener('keydown',handler);
        return ()=>window.removeEventListener('keydown',handler);
      },[enabled,onIndex,onBack,count]);
    }

    function OptionButton({label,selected,onClick}){
      const bg=selected? 'var(--primary-dark)' : 'var(--primary)';
      return (
        <button
          className="option-btn"
          role="radio"
          aria-checked={selected ? 'true' : 'false'}
          style={{background:bg}}
          onClick={onClick}
        >
          {label}
        </button>
      );
    }

    // =========================================================
    // Bieler Method definitions and lab component
    // =========================================================
    // Vocabulary terms and definitions for the Bieler Method.
    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1st–2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shifting—moving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibrato—finger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'Détaché', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'Collé', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'Martelé', def:'Accented, stopped stroke—bite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance point—vertical energy, horizontal timing.' },
      { term:'Sautillé', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term:'Nature', def:'Use body’s natural alignments—economy, ease, resonance.' },
      { term:'Nurture', def:'Stepwise training—patterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];
    // Concept and application questions for the Bieler Method.
    const BIELER_CONCEPT_QA = [
      { q:'Why does “hand frame” matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautillé?', a:'Spiccato is placed/rebounded; sautillé is natural spring at faster tempi.', wrong:['Spiccato is legato','Sautillé is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];
    // Scenario-based application questions for the Bieler Method.
    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy martelé at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist collé','Firm staccato','Always play sul ponticello'] },
    ];
    // Bieler Method Lab component
    function BielerLab({ onBack }) {
      const [mode,setMode] = React.useState('vocab');
      const [vi,setVi] = React.useState(0);
      const [reveal,setReveal] = React.useState(false);
      const nextV=()=>{ setReveal(false); setVi((vi+1)%BIELER_VOCAB.length); };
      const prevV=()=>{ setReveal(false); setVi((vi-1+BIELER_VOCAB.length)%BIELER_VOCAB.length); };
      const makeConceptQ = React.useCallback(()=>{
        const item = getRandom(BIELER_CONCEPT_QA);
        return { prompt:item.q, correct:item.a, options: shuffle([item.a, ...shuffle(item.wrong).slice(0,3)]) };
      },[]);
      const makeApplyQ = React.useCallback(()=>{
        const item = getRandom(BIELER_APPLY);
        return { prompt:item.scenario, correct:item.answer, options: shuffle([item.answer, ...shuffle(item.wrong).slice(0,3)]) };
      },[]);
      const [cq,setCq] = React.useState(makeConceptQ);
      const [aq,setAq] = React.useState(makeApplyQ);
      const [selC,setSelC] = React.useState(null);
      const [selA,setSelA] = React.useState(null);
      const [scoreC,setScoreC] = React.useState(0), [answeredC,setAnsweredC] = React.useState(0);
      const [scoreA,setScoreA] = React.useState(0), [answeredA,setAnsweredA] = React.useState(0);
      const answerConcept=(opt,idx)=>{
        if(selC!==null) return;
        setSelC(idx);
        const ok = opt===cq.correct;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Incorrect';
        setScoreC(s=>s+(ok?1:0)); setAnsweredC(a=>a+1); addXP(ok?4:1);
        setTimeout(()=>{ setCq(makeConceptQ()); setSelC(null); }, ok?350:700);
      };
      const answerApply=(opt,idx)=>{
        if(selA!==null) return;
        setSelA(idx);
        const ok = opt===aq.correct;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Incorrect';
        setScoreA(s=>s+(ok?1:0)); setAnsweredA(a=>a+1); addXP(ok?5:2);
        setTimeout(()=>{ setAq(makeApplyQ()); setSelA(null); }, ok?350:700);
      };
      useAnswerHotkeys(
        mode!=='vocab',
        (i)=>{
          if(mode==='concept' && cq.options[i]) answerConcept(cq.options[i], i);
          if(mode==='apply'   && aq.options[i]) answerApply(aq.options[i], i);
        },
        onBack,
        mode==='concept' ? (cq.options?.length||4) : (aq.options?.length||4)
      );
      React.useEffect(()=>{
        const onKey=(e)=>{
          if(e.key==='Escape'){ onBack(); }
          if(mode==='vocab'){
            if(e.key==='ArrowRight') nextV();
            if(e.key==='ArrowLeft')  prevV();
          }
        };
        window.addEventListener('keydown',onKey);
        return ()=>window.removeEventListener('keydown',onKey);
      },[mode,vi,onBack]);
      return (
        <div>
          <div className="card">
            <h2>Bieler Method Lab</h2>
            <p style={{color:'var(--ink-light)',marginTop:-6}}>
              Progressive study: build vocabulary → check concepts → apply to musical/technique scenarios.
            </p>
            <div style={{display:'flex',gap:'0.5rem',flexWrap:'wrap',margin:'0.5rem 0 1rem'}}>
              <button className="btn btn-primary" onClick={()=>setMode('vocab')}   aria-pressed={mode==='vocab'}>Vocabulary</button>
              <button className="btn btn-primary" onClick={()=>setMode('concept')} aria-pressed={mode==='concept'}>Concept Check</button>
              <button className="btn btn-primary" onClick={()=>setMode('apply')}   aria-pressed={mode==='apply'}>Applications</button>
            </div>
            {mode==='vocab' && (
              <div>
                <div className="card" style={{padding:'1rem',textAlign:'center',marginBottom:'0.5rem'}}>
                  <div style={{fontWeight:700,fontSize:'1.15rem'}}>{BIELER_VOCAB[vi].term}</div>
                  {reveal
                    ? <div style={{marginTop:'0.5rem',color:'var(--ink-light)'}}>{BIELER_VOCAB[vi].def}</div>
                    : <div style={{marginTop:'0.5rem',fontStyle:'italic',color:'var(--ink-light)'}}>Press Reveal to show definition.</div>}
                </div>
                <div style={{display:'flex',gap:'0.5rem',justifyContent:'center'}}>
                  <button className="btn btn-primary"   onClick={()=>setReveal(true)}>Reveal</button>
                  <button className="btn btn-secondary" onClick={prevV}>Previous</button>
                  <button className="btn btn-secondary" onClick={nextV}>Next</button>
                </div>
                <div style={{marginTop:'0.5rem',textAlign:'center',color:'var(--ink-light)'}}>
                  <small>Card {vi+1} / {BIELER_VOCAB.length}</small>
                  <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}>
                    <div style={{width:`${((vi+1)/BIELER_VOCAB.length)*100}%`,height:'100%',background:'var(--primary)'}}/>
                  </div>
                </div>
              </div>
            )}
            {mode==='concept' && (
              <div>
                <div style={{color:'var(--ink-light)',marginBottom:'0.25rem'}}>Score: {scoreC} / {answeredC}</div>
                <p style={{fontWeight:600}}>{cq.prompt}</p>
                <div role="radiogroup" aria-label="Concept answers">
                  {cq.options.map((opt,i)=>(
                    <OptionButton key={i} label={opt} selected={selC===i} onClick={()=>answerConcept(opt,i)} />
                  ))}
                </div>
              </div>
            )}
            {mode==='apply' && (
              <div>
                <div style={{color:'var(--ink-light)',marginBottom:'0.25rem'}}>Score: {scoreA} / {answeredA}</div>
                <p><em>Scenario:</em> {aq.prompt}</p>
                <p style={{fontWeight:600, marginTop:'0.25rem'}}>Choose the best practice approach:</p>
                <div role="radiogroup" aria-label="Application answers">
                  {aq.options.map((opt,i)=>(
                    <OptionButton key={i} label={opt} selected={selA===i} onClick={()=>answerApply(opt,i)} />
                  ))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // Visual fingerboard component: renders 5 positions and 4 strings with finger lanes.
    function VisualFingerboard({highlight=[],onSelect,disabled}) {
      const posW=80, strH=32, fingerH=strH/4, W=posW*5, H=strH*4;
      const hiMap = Object.fromEntries(highlight.map(h => [`${h.s}:${h.p}:${h.f}`, h.kind]));
      const color = k => k==='correct' ? 'var(--success)'
                    : k==='chosen' ? 'var(--primary)'
                    : k==='distractor' ? 'var(--warning)'
                    : 'var(--card)';
      return (
        <svg viewBox={`0 0 ${W} ${H}`} width="100%" height="auto" role="grid" aria-label="Fingerboard" aria-rowcount="4" aria-colcount="5">
          {['G','D','A','E'].map((s,si)=>(
            <g key={s} transform={`translate(0,${(3-si)*strH})`}>
              {POSITIONS.map(p=>(
                <g key={p} transform={`translate(${(p-1)*posW},0)`}>
                  {FINGERS.map((f,fi)=>{
                    const key=`${s}:${p}:${f}`;
                    const kind=hiMap[key];
                    return (
                      <rect key={key}
                        x={4} y={fi*fingerH+4} width={posW-8} height={fingerH-8} rx="3"
                        fill={color(kind)} stroke="var(--border)"
                        tabIndex={disabled?-1:0} role="gridcell" aria-selected={kind==='chosen' || kind==='correct' ? 'true':'false'}
                        aria-label={`${s} string, ${ordinal(p)} pos, finger ${f}`}
                        onClick={()=>!disabled && onSelect?.({s,p,f})}
                        onKeyDown={e=>{ if(!disabled && (e.key==='Enter'||e.key===' ')) onSelect?.({s,p,f}); }}/>
                    );
                  })}
                </g>
              ))}
            </g>
          ))}
        </svg>
      );
    }

    function SpeedDrill({prefs,onBack}){
      const [stats,setStats]=React.useState(()=>loadJSON(STATS_KEY,{}));
      const cells = React.useMemo(() => filteredCells(prefs), [prefs]);
      const [time,setTime]=React.useState(90);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=React.useCallback(()=>{
        if(!cells.length){ setQ(null); return; }
        const weight=c=>{ const k=`${c.s}:${c.p}:${c.f}`; const st=stats[k]||{correct:0,total:0}; const acc=st.total? st.correct/st.total : 0; return 1-acc+0.05; };
        const total=cells.reduce((sum,c)=>sum+weight(c),0);
        let r=Math.random()*total; let chosen=cells[cells.length-1];
        for(const c of cells){ r-=weight(c); if(r<=0){ chosen=c; break;} }
        const correct=chosen.canon;
        const pool=[...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct);
        const opts=shuffle([correct,...shuffle(pool).slice(0,3)]);
        setQ({cell:chosen,options:opts}); setSelected(null);
        try {
          const midi=MIDI_BASE[chosen.s] + POS_SHIFT[chosen.p] + BASE_OFF[chosen.f];
          audioEngine.playNote({midi});
        }catch{}
      },[cells,stats]);
      React.useEffect(()=>{ pick(); },[cells]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok= opt===q.cell.canon;
          document.getElementById('sr').textContent = ok ? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          setStats(prev=>{
            const k=`${q.cell.s}:${q.cell.p}:${q.cell.f}`;
            const st=prev[k]||{correct:0,total:0};
            const next={...prev,[k]:{correct:st.correct+(ok?1:0), total:st.total+1}};
            saveJSON(STATS_KEY,next);
            return next;
          });
          addXP(ok?8:2);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q && q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);
      if(time===0) return <div className="card"><h2>Speed Drill Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      if(!cells.length) return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (<div><div className="card"><h2>Speed Drill</h2><p>Time {time}s | Score {score}/{answered}</p><button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>{q && (<div><p>What is the base note at <strong>{ordinal(q.cell.p)} pos, {ordinal(q.cell.f)} finger on {q.cell.s}</strong>?</p><div role="radiogroup" aria-label="Answer choices">{q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}</div></div>)}</div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>);
    }

    function Flashcards({prefs,onBack}){
      const buildCards=React.useCallback(()=>{
        const cells=filteredCells(prefs);
        const cards=[];
        cells.forEach(c=>{ cards.push({type:'cell',q:`Note at ${ordinal(c.p)} pos, ${ordinal(c.f)} finger on ${c.s}`,a:c.canon,interval:1,due:Date.now()}); });
        const unique=[...new Set(cells.map(c=>c.canon))];
        unique.forEach(n=>{ cards.push({type:'note',q:`Locations for note ${n}?`,a:n,interval:1,due:Date.now()}); });
        return cards;
      },[prefs]);
      const [deck,setDeck]=React.useState(()=>{
        const saved=loadJSON(FLASH_KEY,null);
        const savedSig=localStorage.getItem(FLASH_SIG_KEY);
        const curSig=JSON.stringify({strings:prefs.strings,positions:prefs.positions});
        if(saved && savedSig===curSig) return saved;
        const cards=buildCards(); saveJSON(FLASH_KEY,cards); localStorage.setItem(FLASH_SIG_KEY,curSig); return cards;
      });
      React.useEffect(()=>{
        const curSig=JSON.stringify({strings:prefs.strings,positions:prefs.positions});
        const savedSig=localStorage.getItem(FLASH_SIG_KEY);
        if(curSig!==savedSig){ const cards=buildCards(); saveJSON(FLASH_KEY,cards); localStorage.setItem(FLASH_SIG_KEY,curSig); setDeck(cards); }
      },[prefs,buildCards]);
      const [card,setCard]=React.useState(null);
      const [show,setShow]=React.useState(false);
      const pick=()=>{
        if(!deck.length){ setCard(null); return; }
        const now=Date.now();
        const due=deck.filter(c=>c.due<=now).sort((a,b)=>a.due-b.due);
        const next= due.length? due[0] : getRandom(deck);
        setCard(next); setShow(false);
      };
      React.useEffect(()=>{ pick(); },[deck]);
      const mark=(known)=>{
        setDeck(prev=>{
          const upd=prev.map(c=>{
            if(c===card){ const newInt= known? Math.min(28,c.interval*2) : 1; return {...c, interval:newInt, due: Date.now()+newInt*24*3600*1000}; } return c; }); saveJSON(FLASH_KEY,upd); return upd;
        });
        addXP(known?5:1);
        document.getElementById('sr').textContent = known ? 'Correct' : 'Incorrect';
        pick();
      };
      if(!deck.length) return <div className="card"><h2>No cards</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (<div><div className="card"><h2>Flashcards</h2>{card && (<div><p>{card.q}</p>{show? (<p style={{fontWeight:'bold',fontSize:'1.4rem'}}>{card.a}</p>) : (<button className="btn btn-primary" onClick={()=>setShow(true)}>Reveal</button>)}{show && (<div style={{marginTop:'0.5rem'}}><button className="btn btn-success" onClick={()=>mark(true)}>I knew it</button><button className="btn btn-secondary" onClick={()=>mark(false)}>I forgot</button></div>)}</div>)}</div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>);
    }

    function Snapshot({prefs,onBack}){
      const cells=filteredCells(prefs);
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [state,setState]=React.useState('flash');
      const [flash,setFlash]=React.useState(null);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const flashRef=React.useRef(null);
      const pick=()=>{
        if(!cells.length){ setState('none'); return; }
        const s=getRandom(STRINGS.filter(s=>prefs.strings[s]));
        const p=getRandom(POSITIONS.filter(p=>prefs.positions[p]));
        const labels={}; FINGERS.forEach(f=>{ labels[f]=canonicalBase(s,p,f); });
        setFlash({s,p,labels}); setState('flash'); setSelected(null);
        if(flashRef.current) clearTimeout(flashRef.current);
        const delay=FLASH_DURATIONS[prefs.flashLevel] || 1000;
        flashRef.current=setTimeout(()=>{
          const f=getRandom(FINGERS);
          const correct=labels[f]; const opts=shuffle([correct,...shuffle([...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct)).slice(0,3)]);
          setQ({s,p,f,correct,options:opts}); setState('question'); setSelected(null);
          try {
            const midi=MIDI_BASE[s] + POS_SHIFT[p] + BASE_OFF[f];
            audioEngine.playNote({midi});
          }catch{}
        },delay);
      };
      React.useEffect(()=>{
        pick();
        return () => {
          if(flashRef.current){ clearTimeout(flashRef.current); flashRef.current=null; }
        };
      },[]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok=opt===q.correct;
          document.getElementById('sr').textContent = ok ? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          updateStat(`${q.s}:${q.p}:${q.f}`, ok);
          addXP(ok?6:2);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q && q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length ?? 4);
      if(time===0) return <div className="card"><h2>Snapshot Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      if(state==='none') return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Snapshot</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {state==='flash' && flash && (
              <div>
                <p>Memorize {flash.s} string {ordinal(flash.p)} pos:</p>
                <div className="grid grid-cols-2">
                  {FINGERS.map(f=>(
                    <div key={f} className="card" style={{padding:'0.5rem',textAlign:'center',borderRadius:'8px'}}>
                      <small>F{f}</small><br/>
                      <strong>{flash.labels[f]}</strong>
                    </div>
                  ))}
                </div>
                <button className="btn btn-primary" onClick={()=>{
                  if(flashRef.current){ clearTimeout(flashRef.current); flashRef.current=null; }
                  const s=flash.s; const p=flash.p;
                  const f=getRandom(FINGERS);
                  const correct=flash.labels[f];
                  const opts=shuffle([correct,...shuffle([...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct)).slice(0,3)]);
                  setQ({s,p,f,correct,options:opts}); setState('question'); setSelected(null);
                }}>Ready</button>
              </div>
            )}
            {state==='question' && q && (
              <div>
                <p>Which base note is F{q.f} at {ordinal(q.p)} pos on {q.s}?</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function IntervalSprint({prefs,onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const strings=STRINGS.filter(s=>prefs.strings[s]);
        const pos=POSITIONS.filter(p=>prefs.positions[p]);
        if(!strings.length || !pos.length){ setQ(null); return; }
        const s=getRandom(strings);
        const p=getRandom(pos);
        const [a,b]=getRandom([[1,2],[2,3],[3,4]]);
        const diff=Math.abs(BASE_OFF[b]-BASE_OFF[a]);
        const type= diff===1? 'half':'whole';
        setQ({s,p,a,b,type}); setSelected(null);
        try {
          const root = MIDI_BASE[s] + POS_SHIFT[p] + BASE_OFF[a];
          audioEngine.playInterval({rootMidi: root, semitones: Math.abs(BASE_OFF[b]-BASE_OFF[a])});
        } catch {}
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(choice,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok=choice===q.type;
          document.getElementById('sr').textContent = ok? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          updateStat(`${q.s}:${q.p}:${q.a}-${q.b}`, ok);
          addXP(ok?4:1);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q){ const opt=i===0?'half':'whole'; answer(opt,i); } },onBack,2);
      if(time===0) return <div className="card"><h2>Interval Sprint Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      if(!q) return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      const noteA=canonicalBase(q.s,q.p,q.a);
      const noteB=canonicalBase(q.s,q.p,q.b);
      return (
        <div>
          <div className="card">
            <h2>Interval Sprint</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            <p>In {ordinal(q.p)} pos on {q.s} string, between {noteA} and {noteB}: Half or Whole step?</p>
            <div role="radiogroup" aria-label="Answer choices">
              <OptionButton label="Half Step" selected={selected===0} onClick={()=>answer('half',0)}/>
              <OptionButton label="Whole Step" selected={selected===1} onClick={()=>answer('whole',1)}/>
            </div>
            {q && (
            <button className="btn btn-secondary" onClick={() => {
              try {
                const root = MIDI_BASE[q.s] + POS_SHIFT[q.p] + BASE_OFF[q.a];
                audioEngine.playInterval({ rootMidi: root, semitones: Math.abs(BASE_OFF[q.b]-BASE_OFF[q.a]) });
              } catch {}
            }}>Play Again</button>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function NoteLocator({prefs,onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const strings=STRINGS.filter(s=>prefs.strings[s]);
        const pos=POSITIONS.filter(p=>prefs.positions[p]);
        if(!strings.length || !pos.length){ setQ(null); return; }
        const cells=CELLS.filter(c=>prefs.strings[c.s] && prefs.positions[c.p]);
        const chosen=getRandom(cells);
        const note=chosen.canon;
        const correct={s:chosen.s,p:chosen.p,f:chosen.f};
        const samePitch=cells.filter(c=>c.canon===note && !(c.s===correct.s && c.p===correct.p && c.f===correct.f));
        const distract= samePitch.length>=3? shuffle(samePitch).slice(0,3) : shuffle(cells.filter(c=>c.canon!==note)).slice(0,3);
        const opts=shuffle([{...correct},...distract.map(c=>({s:c.s,p:c.p,f:c.f}))]).slice(0,4);
        setQ({note,correct,options:opts}); setSelected(null);
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        const ok = opt.s===q.correct.s && opt.p===q.correct.p && opt.f===q.correct.f;
        setQ(prev => prev && {
          ...prev,
          feedback: prev.options.map(o => {
            const isCorrect = (o.s===prev.correct.s && o.p===prev.correct.p && o.f===prev.correct.f);
            const isChosen  = (o.s===opt.s && o.p===opt.p && o.f===opt.f);
            return {...o, kind: isCorrect ? 'correct' : isChosen ? 'chosen' : 'distractor'};
          })
        });
        setTimeout(()=>{
          document.getElementById('sr').textContent = ok? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          updateStat(`${q.correct.s}:${q.correct.p}:${q.correct.f}`, ok);
          addXP(ok?4:1);
          pick();
        },450);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q && q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);
      if(time===0) return <div className="card"><h2>Note Locator Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      if(!q) return <div className="card"><h2>No valid notes</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Note Locator</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            <p>Where can you play {q.note}? Click the fingerboard:</p>
            <VisualFingerboard
              highlight={(q.feedback || q.options).map(o=>({
                s:o.s, p:o.p, f:o.f, kind:o.kind || 'distractor'
              }))}
              disabled={!!q.feedback}
              onSelect={(cell)=>answer(cell,0)}
            />
            <details style={{marginTop:'0.5rem'}}>
              <summary>List options</summary>
              {q.options.map((o,i)=>(<OptionButton key={i} label={`${o.s}: Pos ${o.p}, F${o.f}`} selected={false} onClick={()=>answer(o,i)}/>))}
            </details>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function Settings({prefs,setPrefs,onBack}){
      const toggle=(type,key)=>{
        setPrefs(prev=>{
          const copy={...prev,[type]:{...prev[type],[key]:!prev[type][key]}};
          saveJSON(PREFS_KEY,copy);
          return copy;
        });
      };
      return (
        <div>
          <div className="card">
            <h2>Settings</h2>
            <h3>Theme</h3>
            <button className="btn btn-primary" onClick={()=>{ const dark=!document.documentElement.classList.contains('dark'); window.__setTheme(dark); }}>Toggle Dark Mode</button>
            <h3>Strings</h3>
            <div>{STRINGS.map(s=>(<OptionButton key={s} label={s} selected={prefs.strings[s]} onClick={()=>toggle('strings',s)}/>))}</div>
            <h3>Positions</h3>
            <div>{POSITIONS.map(p=>(<OptionButton key={p} label={p} selected={prefs.positions[p]} onClick={()=>toggle('positions',p)}/>))}</div>
            <h3>Snapshot Flash Duration</h3>
            <div>{['Beginner','Intermediate','Advanced','Professional','Master'].map(level=>(
              <OptionButton key={level} label={level} selected={prefs.flashLevel===level} onClick={()=>{
                setPrefs(prev=>{ const next={...prev,flashLevel:level}; saveJSON(PREFS_KEY,next); return next; });
              }}/>
            ))}</div>
            <p style={{marginTop:'1rem',color:'var(--ink-light)'}}>Select strings and positions for drills. Choose flash duration (Beginner = slowest) for Snapshot memorization.</p>
            <h3>Audio</h3>
            <button className="btn btn-primary" onClick={()=>audioEngine.ensure()}>Enable Sound</button>
            <button className="btn" style={{background: audioEngine.mute? 'var(--danger)':'var(--primary)'}} onClick={()=>{ audioEngine.setMute(!audioEngine.mute); }}>
              {audioEngine.mute? 'Unmute' : 'Mute'}
            </button>
            <h3>Data Tools</h3>
            <button className="btn btn-primary" onClick={()=>{
              const data={}; Object.keys(localStorage).filter(k=>k.startsWith('vmq.v4')||k.startsWith('vmq.v5')).forEach(k=>{ data[k]=localStorage.getItem(k); });
              const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
              const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='vmq-data.json'; a.click(); URL.revokeObjectURL(url);
            }}>Export Data</button>
            <label className="btn btn-warning" style={{cursor:'pointer'}}>
              Import Data
              <input type="file" accept="application/json" style={{display:'none'}} onChange={(e)=>{
                const f=e.target.files?.[0]; if(!f) return;
                const r=new FileReader();
                r.onload=()=>{
                  try{
                    const obj=JSON.parse(r.result);
                    Object.entries(obj).forEach(([k,v])=>{ localStorage.setItem(k,v); });
                    alert('Import complete. Please reload.');
                  }catch{ alert('Invalid JSON'); }
                };
                r.readAsText(f);
              }}/>
            </label>
            <button className="btn btn-danger" onClick={()=>{
              if(confirm('Reset all VMQ data?')){
                Object.keys(localStorage).filter(k=>k.startsWith('vmq.v4')||k.startsWith('vmq.v5')).forEach(k=>localStorage.removeItem(k));
                location.reload();
              }
            }}>Reset All Data</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function StatsPage({onBack}){
      const stats=loadJSON(STATS_KEY,{});
      const xp=loadJSON(XP_KEY,0);
      const lvl=levelForXP(xp);
      const prev=lvl>1? nextLevelXP(lvl-1):0;
      const next=nextLevelXP(lvl);
      const pct=Math.max(0, Math.min(1, isFinite((xp-prev)/(next-prev)) ? (xp-prev)/(next-prev) : 0));
      const isCellKey=k=>{
        const parts=k.split(':'); return parts.length===3 && STRINGS.includes(parts[0]) && POSITIONS.includes(Number(parts[1])) && FINGERS.includes(Number(parts[2])); };
      const filteredStats=Object.fromEntries(Object.entries(stats).filter(([k,_])=>isCellKey(k)));
      return (
        <div>
          <div className="card">
            <h2>Your Progress</h2>
            <p>Level {lvl} (XP {xp-prev}/{next-prev})</p>
            <div className="progress-bar" style={{height:'8px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden'}}>
              <div style={{height:'100%',width:`${pct*100}%`,background:'var(--primary)'}}></div>
            </div>
          </div>
          {STRINGS.map(s=>(
            <div className="card" key={s}>
              <h3>{s} string</h3>
              <div className="grid" style={{gridTemplateColumns:'repeat(5,1fr)',gap:'0.3rem'}}>
                {POSITIONS.map(p=>(
                  <div key={p} style={{display:'grid',gridTemplateColumns:'repeat(4,1fr)',gap:'2px'}}>
                    {FINGERS.map(f=>{
                      const k=`${s}:${p}:${f}`;
                      const st=filteredStats[k]||{correct:0,total:0};
                      const acc= st.total? st.correct/st.total:0;
                      let col, ink='#fff';
                      if(st.total===0) {
                        col='var(--neutral)';
                      } else if(acc<0.5) {
                        col='var(--danger)';
                      } else if(acc<0.75) {
                        col='var(--warning)'; ink='#111';
                      } else {
                        col='var(--success)';
                      }
                      const label=st.total? `${Math.round(acc*100)}%`:'';
                      return (
                        <div key={f}
                             className="heat-cell"
                             style={{background:col,color:ink,fontSize:'0.65rem'}}
                             title={`Pos ${p}, F${f}: ${st.correct}/${st.total}`}>{label}</div>
                      );
                    })}
                  </div>
                ))}
              </div>
            </div>
          ))}
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    const TEMPOS=[{it:'Prestissimo',en:'extremely fast',range:'≥200 bpm'},{it:'Presto',en:'very fast',range:'168–200 bpm'},{it:'Allegro',en:'fast, lively',range:'120–168 bpm'},{it:'Allegretto',en:'moderately fast',range:'112–120 bpm'},{it:'Andante',en:'walking tempo',range:'76–108 bpm'},{it:'Andantino',en:'slightly faster than Andante',range:'80–112 bpm'},{it:'Adagio',en:'slow, majestic',range:'66–76 bpm'},{it:'Largo',en:'very broad and slow',range:'40–60 bpm'},{it:'Lento',en:'very slow',range:'40–60 bpm'}];

    const INTERVALS=[
      {name:'Minor 2nd', semitones:1, feel:'Sad, tense, spooky', cue:'Jaws Theme, Für Elise'},
      {name:'Major 2nd', semitones:2, feel:'Happy, bright, curious', cue:'Happy Birthday (1st 2 notes)'},
      {name:'Minor 3rd', semitones:3, feel:'Tragic, melancholy', cue:'Greensleeves, Brahms’ Lullaby'},
      {name:'Major 3rd', semitones:4, feel:'Very happy, warm', cue:'When the Saints Go Marching'},
      {name:'Perfect 4th', semitones:5, feel:'Strong, open', cue:'Here Comes the Bride, Amazing Grace'},
      {name:'Tritone', semitones:6, feel:'Alert, tense', cue:'Emergency sirens, The Simpsons'},
      {name:'Perfect 5th', semitones:7, feel:'Heroic, open', cue:'Twinkle Twinkle, Star Wars'},
      {name:'Minor 6th', semitones:8, feel:'Bittersweet, longing', cue:'In My Life, Imperial March'},
      {name:'Major 6th', semitones:9, feel:'Lyrical, hopeful', cue:'My Bonnie Lies Over the Ocean, NBC chimes'},
      {name:'Minor 7th', semitones:10, feel:'Distant, complex', cue:'Somewhere (West Side Story), Pure Imagination'},
      {name:'Major 7th', semitones:11, feel:'Intense, unresolved', cue:'Take On Me (A-ha)'},
      {name:'Octave', semitones:12, feel:'Complete, powerful', cue:'Somewhere Over the Rainbow'}
    ];

    const KEY_SIGNATURES=[
      {key:'C Major', type:'none', count:0},
      {key:'G Major', type:'sharp', count:1},
      {key:'D Major', type:'sharp', count:2},
      {key:'A Major', type:'sharp', count:3},
      {key:'E Major', type:'sharp', count:4},
      {key:'B Major', type:'sharp', count:5},
      {key:'F# Major', type:'sharp', count:6},
      {key:'C# Major', type:'sharp', count:7},
      {key:'F Major', type:'flat', count:1},
      {key:'Bb Major', type:'flat', count:2},
      {key:'Eb Major', type:'flat', count:3},
      {key:'Ab Major', type:'flat', count:4},
      {key:'Db Major', type:'flat', count:5},
      {key:'Gb Major', type:'flat', count:6},
      {key:'Cb Major', type:'flat', count:7}
    ];

    const TIME_SIGNATURES=[
      {sig:'2/4', description:'2 quarter-note beats per measure (simple duple)'},
      {sig:'3/4', description:'3 quarter-note beats per measure (simple triple)'},
      {sig:'4/4', description:'4 quarter-note beats per measure (common time)'},
      {sig:'6/8', description:'6 eighth-note beats grouped in 2 dotted quarter beats (compound duple)'},
      {sig:'9/8', description:'9 eighth-note beats grouped in 3 dotted quarter beats (compound triple)'},
      {sig:'12/8', description:'12 eighth-note beats grouped in 4 dotted quarter beats (compound quadruple)'}
    ];

    function TempoTrainer({onBack}){
      const [i,setI]=React.useState(0);
      const [show,setShow]=React.useState(false);
      const next=()=>{ setShow(false); setI((i+1)%TEMPOS.length); };
      const prev=()=>{ setShow(false); setI((i-1+TEMPOS.length)%TEMPOS.length); };
      const t=TEMPOS[i];
      const speak=(txt)=>{ try{ const u=new SpeechSynthesisUtterance(txt); u.rate=0.9; speechSynthesis.cancel(); speechSynthesis.speak(u);}catch{} };
      return (<div><div className="card"><h2>Tempo Trainer</h2><p><strong>{t.it}</strong></p>{show? (<p>{t.en} — {t.range}</p>) : (<button className="btn btn-primary" onClick={()=>setShow(true)}>Reveal</button>)}<div style={{marginTop:'0.5rem'}}><button className="btn btn-secondary" onClick={prev}>Prev</button><button className="btn btn-primary" onClick={next}>Next</button><button className="btn btn-success" onClick={()=>{ speak(t.it); speak(t.en); }}>Speak</button></div></div><button className="btn btn-secondary" onClick={onBack}>Back</button></div>);
    }
    function TempoTester({onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const term=getRandom(TEMPOS);
        const correct=term.en;
        const opts=shuffle([correct,...shuffle(TEMPOS.map(x=>x.en).filter(x=>x!==correct)).slice(0,3)]);
        setQ({term:term.it,correct,options:opts}); setSelected(null);
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(opt,idx)=>{
        setSelected(idx);
        setTimeout(()=>{
          const ok=opt===q.correct;
          document.getElementById('sr').textContent = ok? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          addXP(ok?5:2);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q && q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length ?? 4);
      if(time===0) return <div className="card"><h2>Tempo Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Tempo Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>What does {q.term} mean?</p>
                {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function TheoryHome({onBack,onNavigate}){
      return (
        <div>
          <div className="card">
            <h2>Theory & Concepts</h2>
            <p>Explore intervals, key signatures and time signatures.</p>
            <button className="btn btn-primary" onClick={()=>onNavigate('intervalTrainer')}>Intervals Trainer</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('intervalTester')}>Intervals Tester</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('keyTrainer')}>Key Sig Trainer</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('keyTester')}>Key Sig Tester</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('timeTrainer')}>Time Sig Trainer</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('timeTester')}>Time Sig Tester</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function IntervalTrainer({onBack}){
      const [index,setIndex]=React.useState(0);
      const next=()=>setIndex((index+1)%INTERVALS.length);
      const i=INTERVALS[index];
      const total=INTERVALS.length;
      const progress=(index+1)/total;
      return (
        <div>
          <div className="card">
            <h2>Intervals Trainer</h2>
            <p><strong>{i.name}</strong> — {i.semitones} semitone{i.semitones>1?'s':''}</p>
            <p><em>Feel:</em> {i.feel}</p>
            <p><em>Song cue:</em> {i.cue}</p>
            <div style={{margin:'0.5rem 0'}}>
              <small>Card {index+1} of {total}</small>
              <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}><div style={{width:`${progress*100}%`,height:'100%',background:'var(--primary)'}}></div></div>
            </div>
            <button className="btn btn-primary" onClick={next}>Next</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function IntervalTester({onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const item=getRandom(INTERVALS);
        let prompt, correct, opts;
        if(Math.random()<0.5){
          correct=item.name;
          opts=shuffle([correct,...shuffle(INTERVALS.map(x=>x.name).filter(n=>n!==correct)).slice(0,3)]);
          prompt=`Which interval has ${item.semitones} semitone${item.semitones>1?'s':''}?`;
        } else {
          correct=item.name;
          const cue=item.cue.split(',')[0];
          opts=shuffle([correct,...shuffle(INTERVALS.map(x=>x.name).filter(n=>n!==correct)).slice(0,3)]);
          prompt=`Which interval matches the cue “${cue}”?`;
        }
        const semitones=item.semitones;
        const rootMidi = 64 + Math.floor(Math.random()*6);
        setQ({prompt,correct,options:opts,semitones,rootMidi});
        setSelected(null);
        try{ audioEngine.playInterval({rootMidi,semitones:item.semitones}); }catch(e){}
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok=opt===q.correct;
          document.getElementById('sr').textContent= ok? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          addXP(ok?4:1);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);
      if(time===0) return <div className="card"><h2>Intervals Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Intervals Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>{q.prompt}</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
                <button className="btn btn-secondary" onClick={()=>{
                  try{ audioEngine.playInterval({rootMidi:q.rootMidi, semitones:q.semitones}); }catch(e){}
                }}>Play Again</button>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function KeyTrainer({onBack}){
      const [index,setIndex]=React.useState(0);
      const next=()=>setIndex((index+1)%KEY_SIGNATURES.length);
      const k=KEY_SIGNATURES[index];
      const total=KEY_SIGNATURES.length;
      const progress=(index+1)/total;
      return (
        <div>
          <div className="card">
            <h2>Key Signatures Trainer</h2>
            <p><strong>{k.key}</strong></p>
            {k.type==='none'? <p>No sharps or flats.</p> : <p>{k.count} {k.type}{k.count>1?'s':''}.</p>}
            <div style={{margin:'0.5rem 0'}}>
              <small>Card {index+1} of {total}</small>
              <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}><div style={{width:`${progress*100}%`,height:'100%',background:'var(--primary)'}}></div></div>
            </div>
            <button className="btn btn-primary" onClick={next}>Next</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function KeyTester({onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const item=getRandom(KEY_SIGNATURES);
        if(Math.random()<0.5){
          const correct=item.key;
          const desc=item.count===0? 'no sharps or flats' : `${item.count} ${item.type}${item.count>1?'s':''}`;
          const opts=shuffle([correct,...shuffle(KEY_SIGNATURES.map(x=>x.key).filter(k=>k!==correct)).slice(0,3)]);
          setQ({prompt:`Which major key has ${desc}?`,correct,options:opts});
        } else {
          const correct=item.count===0? 'no sharps or flats' : `${item.count} ${item.type}${item.count>1?'s':''}`;
          const descList=[...new Set(KEY_SIGNATURES.map(x=> x.count===0? 'no sharps or flats' : `${x.count} ${x.type}${x.count>1?'s':''}`))];
          const opts=shuffle([correct,...shuffle(descList.filter(v=>v!==correct)).slice(0,3)]);
          setQ({prompt:`How many sharps/flats does ${item.key} have?`,correct,options:opts});
        }
        setSelected(null);
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok=opt===q.correct;
          document.getElementById('sr').textContent= ok? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          addXP(ok?4:1);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length ?? 4);
      if(time===0) return <div className="card"><h2>Key Sig Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Key Sig Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>{q.prompt}</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function TimeTrainer({onBack}){
      const [index,setIndex]=React.useState(0);
      const next=()=>setIndex((index+1)%TIME_SIGNATURES.length);
      const t=TIME_SIGNATURES[index];
      const total=TIME_SIGNATURES.length;
      const progress=(index+1)/total;
      return (
        <div>
          <div className="card">
            <h2>Time Sig Trainer</h2>
            <p><strong>{t.sig}</strong></p>
            <p>{t.description}</p>
            <div style={{margin:'0.5rem 0'}}>
              <small>Card {index+1} of {total}</small>
              <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}><div style={{width:`${progress*100}%`,height:'100%',background:'var(--primary)'}}></div></div>
            </div>
            <button className="btn btn-primary" onClick={next}>Next</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function TimeTester({onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const item=getRandom(TIME_SIGNATURES);
        const correct=item.sig;
        const opts=shuffle([correct,...shuffle(TIME_SIGNATURES.map(x=>x.sig).filter(s=>s!==correct)).slice(0,3)]);
        setQ({prompt:item.description,correct,options:opts}); setSelected(null);
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok=opt===q.correct;
          document.getElementById('sr').textContent= ok? 'Correct' : 'Incorrect';
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          addXP(ok?4:1);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length ?? 4);
      if(time===0) return <div className="card"><h2>Time Sig Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Time Sig Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>{q.prompt}</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function App(){
      const [page,setPage]=React.useState('home');
      const [prefs,setPrefs]=React.useState(()=>loadJSON(PREFS_KEY,defaultPrefs));
      return (
        <div className="container">
          {page==='home' && (
            <div>
              <h1>Violin Mastery Quest</h1>
              <p style={{color:'var(--ink-light)'}}>Tailor your practice by choosing strings & positions. Enjoy drills, study tools and track progress.</p>
              <div className="grid" style={{gridTemplateColumns:'repeat(auto-fit,minmax(260px,1fr))',gap:'1rem'}}>
                <div className="card">
                  <h2>🎻 Play</h2>
                  <button className="btn btn-primary" onClick={()=>setPage('speed')}>Speed Drill</button>
                  <button className="btn btn-primary" onClick={()=>setPage('snapshot')}>Snapshot</button>
                  <button className="btn btn-primary" onClick={()=>setPage('interval')}>Interval Sprint</button>
                  <button className="btn btn-primary" onClick={()=>setPage('locator')}>Note Locator</button>
                </div>
                <div className="card">
                  <h2>📘 Study</h2>
                  <button className="btn btn-primary" onClick={()=>setPage('theoryHome')}>Theory</button>
                  <button className="btn btn-primary" onClick={()=>setPage('flash')}>Flashcards</button>
                  <button className="btn btn-primary" onClick={()=>setPage('tempo')}>Tempo Trainer</button>
                  <button className="btn btn-primary" onClick={()=>setPage('tempoTest')}>Tempo Tester</button>
                  <button className="btn btn-primary" onClick={()=>setPage('bieler')}>Bieler Lab</button>
                </div>
                <div className="card">
                  <h2>📊 Progress & Settings</h2>
                  <button className="btn btn-primary" onClick={()=>setPage('stats')}>View Stats</button>
                  <button className="btn btn-primary" onClick={()=>setPage('settings')}>Settings</button>
                </div>
              </div>
            </div>
          )}
          {page==='speed'&&<SpeedDrill prefs={prefs} onBack={()=>setPage('home')}/>}
          {page==='flash'&&<Flashcards prefs={prefs} onBack={()=>setPage('home')}/>}
          {page==='snapshot'&&<Snapshot prefs={prefs} onBack={()=>setPage('home')}/>}
          {page==='interval'&&<IntervalSprint prefs={prefs} onBack={()=>setPage('home')}/>}
          {page==='locator'&&<NoteLocator prefs={prefs} onBack={()=>setPage('home')}/>}
          {page==='tempo'&&<TempoTrainer onBack={()=>setPage('home')}/>}
          {page==='tempoTest'&&<TempoTester onBack={()=>setPage('home')}/>}
          {page==='stats'&&<StatsPage onBack={()=>setPage('home')}/>}
          {page==='settings'&&<Settings prefs={prefs} setPrefs={setPrefs} onBack={()=>setPage('home')}/>}
          {page==='theoryHome'&&<TheoryHome onBack={()=>setPage('home')} onNavigate={(p)=>setPage(p)}/>}
          {page==='intervalTrainer'&&<IntervalTrainer onBack={()=>setPage('theoryHome')}/>}
          {page==='intervalTester'&&<IntervalTester onBack={()=>setPage('theoryHome')}/>}
          {page==='keyTrainer'&&<KeyTrainer onBack={()=>setPage('theoryHome')}/>}
          {page==='keyTester'&&<KeyTester onBack={()=>setPage('theoryHome')}/>}
          {page==='timeTrainer'&&<TimeTrainer onBack={()=>setPage('theoryHome')}/>}
          {page==='timeTester'&&<TimeTester onBack={()=>setPage('theoryHome')}/>}
          {page==='bieler'&&<BielerLab onBack={()=>setPage('home')}/>}
        </div>
      );
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>