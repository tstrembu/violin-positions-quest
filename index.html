<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Mastery Quest – Enhanced Trainer (v5)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#f8fafc; --card:#fff; --ink:#0f172a; --ink-light:#475569;
      --primary:#3a5ba0; --primary-dark:#2f4b7e;
      --success:#009e73; --warning:#e69f00; --danger:#d55e00; --neutral:#6c757d; --border:rgba(0,0,0,0.1);
    }
    :root.dark {
      --bg:#0b1426; --card:#0f1f3d; --ink:#e2e8f0; --ink-light:#94a3b8;
      --primary:#4a78b6; --primary-dark:#355a8a;
      --success:#00b58a; --warning:#f3ae3d; --danger:#d5672f; --neutral:#6b7280; --border:rgba(255,255,255,0.15);
    }
    html,body { height:100% }
    body { margin:0; font-family:'Inter',sans-serif; background:var(--bg); color:var(--ink); padding-bottom:64px }
    .container { max-width: 980px; margin:auto; padding:1rem }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:1rem 1.25rem; margin-bottom:1rem; box-shadow:0 4px 20px rgba(0,0,0,0.05) }
    .btn { display:inline-flex; align-items:center; justify-content:center; padding:0.6rem 1rem; border-radius:9999px; margin:0.25rem; border:none; font-weight:600; cursor:pointer; color:#fff }
    .btn-primary { background:var(--primary) } .btn-primary:hover { background:var(--primary-dark) }
    .btn-secondary { background:var(--ink-light) } .btn-secondary:hover { background:var(--ink) }
    .btn-success { background:var(--success) } .btn-warning { background:var(--warning) } .btn-danger { background:var(--danger) }
    .grid { display:grid; gap:1rem }
    @media(min-width:640px){ .grid-cols-2 { grid-template-columns: repeat(2,1fr) } .grid-cols-3 { grid-template-columns: repeat(3,1fr) } }
    .heat-cell { height:2rem; display:flex; align-items:center; justify-content:center; font-size:0.7rem; color:#fff; border-radius:4px }
    .option-btn { width:100%; padding:0.6rem; border-radius:9999px; margin:0.25rem 0; color:#fff; border:none; cursor:pointer; font-weight:600 }
    .btn:focus-visible, .option-btn:focus-visible { outline:3px solid var(--primary); outline-offset:2px }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
    header.appbar { position:sticky; top:0; z-index:10; backdrop-filter:saturate(1.2) blur(6px); background:color-mix(in oklab, var(--bg) 84%, transparent) }
    .row { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center }
    .spacer { flex:1 1 auto }
    @media (prefers-reduced-motion: reduce){ *{ animation-duration: .001ms !important; animation-iteration-count: 1 !important; transition-duration: .001ms !important } }
  </style>

  <!-- Early theme bootstrapping + SR helper -->
  <script>
    (function(){
      const KEY='vmq.theme';
      const saved=localStorage.getItem(KEY);
      window.speakSR = (txt) => { const el = document.getElementById('sr'); if (el) el.textContent = txt || ''; };
      const prefers=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const dark=saved? saved==='dark':prefers;
      document.documentElement.classList.toggle('dark', dark);
      window.__setTheme=(d)=>{ localStorage.setItem(KEY,d?'dark':'light'); document.documentElement.classList.toggle('dark', d); };
    })();
  </script>

  <!-- Pitchy (module) -->
  <script type="module">
    import { PitchDetector } from 'https://cdn.jsdelivr.net/npm/pitchy/dist/pitchy.min.mjs';
    window.__PITCHY = { PitchDetector };
  </script>

  <!-- React 18 + ReactDOM 18 (UMD, defer keeps order) -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js" defer></script>
  <!-- Babel Standalone to run JSX in-browser -->
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <header class="appbar">
    <div class="container row">
      <strong>🎻 Violin Mastery Quest</strong>
      <span class="spacer"></span>
      <button class="btn btn-secondary" onclick="window.__setTheme(!document.documentElement.classList.contains('dark'))">Toggle Theme</button>
    </div>
  </header>

  <div id="root" class="container"></div>
  <div id="sr" class="sr-only" aria-live="polite"></div>
  <noscript>
    <div class="container"><div class="card"><strong>This app needs JavaScript enabled.</strong></div></div>
  </noscript>

  <script type="text/babel" data-presets="react">
    // ===== Helpers =================================================================
    function speak(text, { rate = 0.9, pitch = 1, lang, voiceName } = {}) {
      try {
        if (!text) return;
        const synth = window.speechSynthesis;
        const Utterance = window.SpeechSynthesisUtterance;
        if (!synth || !Utterance) return;
        let voices = [];
        try {
          voices = synth.getVoices?.() || [];
          if (typeof synth.onvoiceschanged === 'undefined') { void voices.length; }
        } catch {}
        const u = new Utterance(String(text));
        u.rate = rate; u.pitch = pitch; if (lang) u.lang = lang;
        if (voiceName && Array.isArray(voices)) {
          const v = voices.find(v => v.name === voiceName); if (v) u.voice = v;
        }
        try { synth.cancel(); } catch {}
        synth.speak(u);
      } catch {}
    }
    const loadJSON=(k,fb)=>{ try{ const v=JSON.parse(localStorage.getItem(k)); return v ?? fb; }catch{return fb;} };
    const saveJSON=(k,v)=>{ try{ localStorage.setItem(k,JSON.stringify(v)); }catch{} };
    const STRINGS=['G','D','A','E'];
    const POSITIONS=[1,2,3,4,5];
    const FINGERS=[1,2,3,4];
    const OPEN_PC={G:7,D:2,A:9,E:4};
    const BASE_OFF={1:2,2:4,3:5,4:7};
    const POS_SHIFT={1:0,2:2,3:3,4:5,5:7};
    const NOTE_NAME={0:'C',1:'Db',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};
    const NOTE_TO_PC = Object.fromEntries(Object.entries(NOTE_NAME).map(([k, v]) => [v, Number(k)]));
    const MIDI_BASE={ G:55, D:62, A:69, E:76 };
    const canonicalBase=(s,p,f)=>{ const semi=OPEN_PC[s]+POS_SHIFT[p]+BASE_OFF[f]; return NOTE_NAME[((semi%12)+12)%12]; };
    const CELLS=[]; for(const s of STRINGS) for(const p of POSITIONS) for(const f of FINGERS){ CELLS.push({s,p,f,canon:canonicalBase(s,p,f)}); }
    const XP_KEY='vmq.v4.xp'; const STATS_KEY='vmq.v4.stats'; const PREFS_KEY='vmq.v4.prefs';
    const FLASH_SIG_KEY='vmq.v4.flashcards.sig'; const FLASH_KEY='vmq.v4.flashcards';
    const levelForXP=(xp)=>Math.floor(Math.pow(xp/300,0.75))+1;
    const nextLevelXP=(lvl)=>Math.round(300*Math.pow(lvl,1.4));
    const addXP=(amt)=>{ const xp=loadJSON(XP_KEY,0)+amt; saveJSON(XP_KEY,xp); return xp; };
    const updateStat=(key,ok)=>{ const stats=loadJSON(STATS_KEY,{}); const st=stats[key]||{correct:0,total:0}; st.total+=1; if(ok) st.correct+=1; stats[key]=st; saveJSON(STATS_KEY,stats); };
    const shuffle=a=>{ const arr=[...a]; for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; };
    const getRandom=a=>a[Math.floor(Math.random()*a.length)];
    const ordinal=n=>{ const s=['th','st','nd','rd'],v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]); };
    const defaultPrefs={ strings:Object.fromEntries(STRINGS.map(s=>[s,true])), positions:Object.fromEntries(POSITIONS.map(p=>[p,true])), flashLevel:'Professional' };
    const FLASH_DURATIONS={ Beginner:3000, Intermediate:2000, Advanced:1200, Professional:800, Master:500 };
    const filteredCells=prefs=>CELLS.filter(c=>prefs.strings[c.s]&&prefs.positions[c.p]);
    const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));
    const midiToHz = (m)=> 440*Math.pow(2,(m-69)/12);
    const hzToMidi = (hz)=> 69 + 12*Math.log2(hz/440);
    const centsDiff = (hz, refHz)=> 1200*Math.log2(hz/refHz);

    // ===== Audio ====================================================================
    class AudioEngine{
      constructor(){ this.ctx=null; this.mute=loadJSON('vmq.v4.mute',false); }
      ensure(){ if(!this.ctx) this.ctx=new (window.AudioContext||window.webkitAudioContext)(); if(this.ctx.state==='suspended') this.ctx.resume(); return this.ctx; }
      playNote({midi,durationMs=800}){ if(this.mute) return; const ctx=this.ensure(); const now=ctx.currentTime; const freq=440*Math.pow(2,(midi-69)/12); const osc=ctx.createOscillator(); const gain=ctx.createGain(); osc.frequency.value=freq; osc.type='sine'; gain.gain.setValueAtTime(0,now); gain.gain.linearRampToValueAtTime(0.8,now+0.01); gain.gain.exponentialRampToValueAtTime(0.1,now+durationMs/1000*0.8); gain.gain.linearRampToValueAtTime(0,now+durationMs/1000); osc.connect(gain); gain.connect(ctx.destination); osc.start(now); osc.stop(now+durationMs/1000); osc.onended=()=>{ try{osc.disconnect(); gain.disconnect();}catch{} }; }
      playInterval({rootMidi, semitones, gapMs = 150, durationMs = 600}) {
        if (this.mute) return; const ctx=this.ensure(); const t0=ctx.currentTime+0.01;
        const note=(m,t)=>{ const o=ctx.createOscillator(), g=ctx.createGain(); o.type='sine'; o.frequency.value=440*Math.pow(2,(m-69)/12); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.8,t+0.01); g.gain.exponentialRampToValueAtTime(0.1,t+durationMs/1000*0.8); g.gain.linearRampToValueAtTime(0,t+durationMs/1000); o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t+durationMs/1000); o.onended=()=>{try{o.disconnect(); g.disconnect();}catch{}}; };
        note(rootMidi,t0); note(rootMidi+semitones,t0+gapMs/1000);
      }
      setMute(m){ this.mute=m; saveJSON('vmq.v4.mute',m); }
      playFeedback(ok){ if(this.mute) return; const ctx=this.ensure(); const now=ctx.currentTime; const freq= ok?880:220; const o=ctx.createOscillator(); const g=ctx.createGain(); o.frequency.value=freq; o.type='square'; g.gain.setValueAtTime(0,now); g.gain.linearRampToValueAtTime(0.3,now+0.01); g.gain.linearRampToValueAtTime(0,now+0.2); o.connect(g); g.connect(ctx.destination); o.start(now); o.stop(now+0.2); o.onended=()=>{ try{o.disconnect(); g.disconnect();}catch{} }; }
    }
    const audioEngine=new AudioEngine();
    window.addEventListener('pointerdown', () => { try { audioEngine.ensure(); } catch {} }, { once: true });

    // ===== Pitch detection (mic) ====================================================
    function autoCorrelate(buf, sampleRate){
      let rms=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; rms+=v*v; } rms=Math.sqrt(rms/buf.length);
      if (rms < 0.008) return { hz: null, clarity: 0 };
      const SIZE=buf.length, minHz=65,maxHz=1047, maxLag=Math.floor(sampleRate/minHz), minLag=Math.floor(sampleRate/maxHz);
      let bestLag=-1,bestCorr=0;
      for(let lag=minLag; lag<=maxLag; lag++){ let corr=0; for(let i=0;i<SIZE-lag;i++){ corr += buf[i] * buf[i+lag]; } if (corr>bestCorr){ bestCorr=corr; bestLag=lag; } }
      if (bestLag<=0) return { hz:null, clarity:0 };
      const prevLag = bestLag-1 >= minLag ? bestLag-1 : bestLag; const nextLag = bestLag+1 <= maxLag ? bestLag+1 : bestLag;
      let c0=0,c1=0,c2=0;
      for(let i=0;i<SIZE-prevLag;i++){ c0 += buf[i]*buf[i+prevLag]; }
      for(let i=0;i<SIZE-bestLag;i++){ c1 += buf[i]*buf[i+bestLag]; }
      for(let i=0;i<SIZE-nextLag;i++){ c2 += buf[i]*buf[i+nextLag]; }
      const denom = 2*(2*c1 - c0 - c2) || 1; const offset=(c0-c2)/denom; const refinedLag = bestLag + clamp(offset,-1,1);
      const hz = sampleRate / refinedLag; const clarity = clamp(bestCorr / (SIZE - bestLag) / (rms || 1e-9), 0, 1);
      if (!Number.isFinite(hz) || hz<30 || hz>4000) return { hz:null, clarity:0 }; return { hz, clarity };
    }

    class MicPitch {
      constructor(){ this.ctx=null; this.analyser=null; this.src=null; this.stream=null; this.buf=new Float32Array(2048); this.running=false; this._raf=0; this._usePitchy=false; this._pitchyDetector=null; this.subscribers=new Set(); }
      async enable(){
        if (this.running || this.analyser) return;
        this.ctx = audioEngine.ensure();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true, channelCount:1 } });
        this.stream = stream; this.src = this.ctx.createMediaStreamSource(stream); this.analyser = this.ctx.createAnalyser(); this.analyser.fftSize=2048; this.src.connect(this.analyser);
        if (window.__PITCHY?.PitchDetector){ this._usePitchy=true; this._pitchyDetector = window.__PITCHY.PitchDetector.forFloat32Array(this.ctx.sampleRate); }
      }
      on(cb){ this.subscribers.add(cb); return ()=>this.subscribers.delete(cb); }
      start(){
        if (!this.analyser) throw new Error('MicPitch not enabled. Call enable() after user gesture.');
        if (this.running) return; this.running=true;
        const loop = ()=>{ if (!this.running) return;
          this.analyser.getFloatTimeDomainData(this.buf);
          let hz=null, clarity=0;
          if (this._usePitchy){ const [f,c]=this._pitchyDetector.findPitch(this.buf, this.ctx.sampleRate); hz=(f && Number.isFinite(f))?f:null; clarity=Number.isFinite(c)?c:0; }
          else { const r=autoCorrelate(this.buf, this.ctx.sampleRate); hz=r.hz; clarity=r.clarity; }
          this.subscribers.forEach(cb=>cb({ hz, clarity })); this._raf=requestAnimationFrame(loop);
        }; this._raf=requestAnimationFrame(loop);
      }
      stop(){ this.running=false; if (this._raf) cancelAnimationFrame(this._raf); this._raf=0; }
      async disable(){ this.stop(); try{ this.src&&this.src.disconnect(); }catch{} try{ this.analyser&&this.analyser.disconnect(); }catch{} try{ this.stream&&this.stream.getTracks().forEach(t=>t.stop()); }catch{} this.src=null; this.analyser=null; this.stream=null; }
    }
    const micPitch = new MicPitch();

    // ===== UI bits ==================================================================
    function TunerNeedle({ cents=0, clarity=0, active=false }){
      const C = clamp(cents, -50, 50);
      const ok = Math.abs(C) <= 10 && clarity >= 0.6;
      const barW = ((C+50)/100)*100;
      return (
        <div className="card" style={{padding:'0.75rem'}}>
          <div style={{display:'flex', alignItems:'center', gap:'0.75rem', flexWrap:'wrap'}}>
            <div style={{flex:'1 1 280px'}}>
              <div style={{height:10, background:'var(--border)', borderRadius:9999, position:'relative', overflow:'hidden'}}>
                <div style={{position:'absolute', left:'50%', top:0, bottom:0, width:2, background:'var(--ink-light)', opacity:0.35}}/>
                <div style={{height:'100%', width:`${barW}%`, background: ok?'var(--success)':'var(--warning)'}}/>
              </div>
              <div style={{display:'flex', justifyContent:'space-between', fontSize:12, color:'var(--ink-light)', marginTop:4}}>
                <span>-50¢</span><span>0</span><span>+50¢</span>
              </div>
            </div>
            <div style={{minWidth:140, textAlign:'center'}}>
              <div style={{fontWeight:700, color: ok ? 'var(--success)' : 'var(--ink)'}}>{ok ? 'IN TUNE' : 'Adjust'}</div>
              <div style={{fontSize:12, color:'var(--ink-light)'}}>Δ {Math.round(C)}¢ • clarity {Math.round(clarity*100)}%</div>
            </div>
          </div>
        </div>
      );
    }

    function ListenPlayPanel({ targetMidi, targetPc, mode='exact', label, onSuccess, running=true, allowReplay=true }){
      const [enabled, setEnabled] = React.useState(false);
      const [cents, setCents] = React.useState(0);
      const [clarity, setClarity] = React.useState(0);
      const [stableMs, setStableMs] = React.useState(0);
      React.useEffect(()=>{
        let off=null; let lastTs=performance.now();
        if (!enabled || !running) { setStableMs(0); return; }
        off = micPitch.on(({hz, clarity:c})=>{
          const now=performance.now(); const dt=now-lastTs; lastTs=now;
          if (!hz){ setClarity(c||0); setStableMs(0); return; }
          let refHz=null;
          if (mode==='exact' && Number.isFinite(targetMidi)) refHz=midiToHz(targetMidi);
          else if (mode==='class' && Number.isFinite(targetPc)){
            const m=hzToMidi(hz); const nearest=Math.round(m);
            let cand = nearest + ((targetPc - (nearest%12) + 12) % 12);
            if (Math.abs(cand - m) > 6) cand -= 12;
            refHz = midiToHz(cand);
          }
          if (!refHz){ setStableMs(0); return; }
          const cts = centsDiff(hz, refHz);
          setCents(cts); setClarity(c||0);
          if (Math.abs(cts) <= 20 && (c||0) >= 0.6) setStableMs(s=>s+dt); else setStableMs(0);
        });
        return ()=>{ off && off(); };
      },[enabled,running,targetMidi,targetPc,mode]);
      React.useEffect(()=>{ if (stableMs>=400){ onSuccess?.(); setStableMs(0);} },[stableMs,onSuccess]);

      return (
        <div>
          <div className="card">
            <h3 style={{marginTop:0}}>Listen &amp; Play</h3>
            <p style={{marginTop:-6, color:'var(--ink-light)'}}>{label}</p>
            {!enabled ? (
              <button className="btn btn-primary" onClick={async()=>{
                try{ await micPitch.enable(); micPitch.start(); setEnabled(true); }
                catch(e){ alert('Microphone permission is needed to use Listen & Play.'); }
              }}>Enable Microphone</button>
            ) : (
              <div style={{display:'flex', gap:'.5rem', flexWrap:'wrap', alignItems:'center'}}>
                {allowReplay && (
                  <button className="btn btn-secondary" onClick={()=>{
                    try{ if (mode==='exact' && Number.isFinite(targetMidi)) audioEngine.playNote({ midi: targetMidi, durationMs: 900 }); } catch{}
                  }}>Play Target</button>
                )}
                <button className="btn" style={{background: running ? 'var(--warning)' : 'var(--primary)'}}
                  onClick={()=>{ if (running){ micPitch.stop(); } else { micPitch.start(); } }}>
                  {running ? 'Pause Listening' : 'Resume Listening'}
                </button>
                <button className="btn btn-danger" onClick={async()=>{ await micPitch.disable(); setEnabled(false); }}>Disable Mic</button>
              </div>
            )}
          </div>
          <TunerNeedle cents={cents} clarity={clarity} active={enabled && running}/>
        </div>
      );
    }

    function useAnswerHotkeys(enabled, onIndex, onBack, count = 4) {
      const cursorRef = React.useRef(-1);
      React.useEffect(() => {
        if (!enabled) return;
        const handler = (e) => {
          const t=e.target; const tag=(t&&t.tagName||'').toLowerCase();
          if (['input','select','textarea'].includes(tag) || (t && t.isContentEditable)) return;
          const k=e.key; const max=(count??4)-1; let handled=false;
          if (k>='1' && k<='9'){ const idx=Number(k)-1; if (idx<=max){ cursorRef.current=idx; onIndex(idx); handled=true; } }
          else if (k==='Enter'){ cursorRef.current=0; onIndex(0); handled=true; }
          else if (k==='Escape'){ onBack?.(); handled=true; }
          else if (k==='ArrowRight' || k==='ArrowDown'){ const next=Math.min((cursorRef.current<0?0:cursorRef.current)+1, max); cursorRef.current=next; onIndex(next); handled=true; }
          else if (k==='ArrowLeft'  || k==='ArrowUp'){   const prev=Math.max((cursorRef.current<0?0:cursorRef.current)-1, 0);  cursorRef.current=prev; onIndex(prev); handled=true; }
          if (handled){ e.preventDefault(); e.stopPropagation(); }
        };
        window.addEventListener('keydown', handler);
        return () => window.removeEventListener('keydown', handler);
      }, [enabled, onIndex, onBack, count]);
      React.useEffect(() => { cursorRef.current = -1; }, [enabled, count]);
    }

    function OptionButton({ label, selected, onClick, shortcut, ...rest }) {
      const bg = selected ? 'var(--primary-dark)' : 'var(--primary)';
      return (
        <button type="button" className="option-btn" role="button" aria-keyshortcuts={shortcut ?? ''} style={{ background: bg }} onClick={onClick} {...rest}>
          {label}{shortcut ? <span className="sr-only"> (Shortcut {shortcut})</span> : null}
        </button>
      );
    }
    function PillToggle({ label, pressed, onClick, ...rest }) {
      const bg = pressed ? 'var(--primary-dark)' : 'var(--primary)';
      return (<button type="button" className="option-btn" aria-pressed={!!pressed} style={{ background: bg }} onClick={onClick} {...rest}>{label}</button>);
    }

    // ===== Visual fingerboard =======================================================
    function VisualFingerboard({ highlight = [], onSelect, disabled }) {
      const patId = React.useMemo(() => 'pat-' + Math.random().toString(36).slice(2), []);
      const POS_W=120, LEFT_PAD=72, RIGHT_PAD=24, TOP_PAD=36, BOTTOM_PAD=28, ROW_H=56, MARK_W=36, MARK_H=20, RADIUS=6;
      const POS_N = POSITIONS.length, W=LEFT_PAD + POS_W*POS_N + RIGHT_PAD, H=TOP_PAD + ROW_H*4 + BOTTOM_PAD;
      const fingerX = { 1: POS_W * 0.18, 2: POS_W * 0.40, 3: POS_W * 0.62, 4: POS_W * 0.82 };
      const ORDER = ['E','A','D','G'];
      const yForString = s => TOP_PAD + ORDER.indexOf(s) * ROW_H + ROW_H/2;
      const hiMap = Object.fromEntries(highlight.map(h => [`${h.s}:${h.p}:${h.f}`, h.kind]));
      const fillForKind=k=> k==='correct'?'var(--success)': k==='chosen'?'var(--primary)': k==='distractor'?`url(#${patId})`:'var(--card)';
      const act = cell => { if (!disabled && onSelect) onSelect(cell); };

      return (
        <svg viewBox={`0 0 ${W} ${H}`} width="100%" height="auto" role="grid" aria-label="Fingerboard (horizontal). Press Enter to choose." aria-rowcount={4} aria-colcount={POSITIONS.length * 4}>
          <defs>
            <pattern id={patId} patternUnits="userSpaceOnUse" width="8" height="8">
              <rect width="8" height="8" fill="var(--warning)" />
              <path d="M0 0 L8 8 M8 0 L0 8" stroke="var(--card)" strokeWidth="1" />
            </pattern>
          </defs>
          <rect x={LEFT_PAD} y={TOP_PAD - 16} width={POS_W * POS_N} height={ROW_H * 4 + 32} rx="10" fill="var(--card)" stroke="var(--border)" />
          <rect x={LEFT_PAD - 8} y={TOP_PAD - 16} width={6} height={ROW_H * 4 + 32} rx="2" fill="var(--ink-light)" opacity="0.35" />
          {POSITIONS.map((p,i)=>{ const x=LEFT_PAD+(p-1)*POS_W; return (
            <g key={`lane-${p}`}>
              <line x1={x} y1={TOP_PAD - 16} x2={x} y2={TOP_PAD - 16 + ROW_H*4 + 32} stroke="var(--border)" />
              <text x={x + POS_W/2} y={TOP_PAD - 18} textAnchor="middle" fontSize="12" fill="var(--ink-light)">{ordinal(p)} pos</text>
            </g>
          );})}
          {['E','A','D','G'].map(s=>{ const y=yForString(s); return (
            <g key={`string-${s}`}>
              <text x={LEFT_PAD - 14} y={y + 4} textAnchor="end" fontWeight="700">{s}</text>
              <line x1={LEFT_PAD} y1={y} x2={LEFT_PAD + POS_W * POS_N} y2={y} stroke="var(--ink-light)" strokeWidth="1.5" opacity="0.35" />
            </g>
          );})}
          {STRINGS.map(s => (POSITIONS.map(p => (FINGERS.map(f => {
            const x=LEFT_PAD+(p-1)*POS_W+fingerX[f]-MARK_W/2, y=yForString(s)-MARK_H/2;
            const key=`${s}:${p}:${f}`, kind=hiMap[key], fill=fillForKind(kind);
            return (
              <g key={key}>
                <rect x={x} y={y} width={MARK_W} height={MARK_H} rx={RADIUS} fill={fill} stroke="var(--border)" role="gridcell"
                  aria-selected={kind==='chosen'||kind==='correct'} aria-label={`${s} string, ${ordinal(p)} position, finger ${f}`} tabIndex={disabled?-1:0}
                  style={{ cursor: disabled ? 'default' : 'pointer' }}
                  onClick={()=>act({s,p,f})}
                  onKeyDown={(e)=>{ if(!disabled && (e.key==='Enter'||e.key===' ')){ e.preventDefault(); e.stopPropagation(); act({s,p,f}); } }}
                />
                {kind==='correct' && (<text x={x + MARK_W/2} y={y + MARK_H/2 + 4} textAnchor="middle" fontSize="12" fill="var(--card)" pointerEvents="none">✓</text>)}
                {kind==='chosen'  && kind!=='correct' && (<text x={x + MARK_W/2} y={y + MARK_H/2 + 4} textAnchor="middle" fontSize="12" fill="var(--card)" pointerEvents="none">✕</text>)}
              </g>
            );
          }))))}
        </svg>
      );
    }

    // ===== Drills / Labs / Theory (components) ======================================
    // -- Bieler Lab (as in your original, unchanged logic except feedback beeps) -----
    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1st–2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shifting—moving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibrato—finger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'Détaché', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'Collé', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'Martelé', def:'Accented, stopped stroke—bite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance point—vertical energy, horizontal timing.' },
      { term:'Sautillé', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term:'Nature', def:'Use body’s natural alignments—economy, ease, resonance.' },
      { term:'Nurture', def:'Stepwise training—patterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];
    const BIELER_CONCEPT_QA = [
      { q:'Why does “hand frame” matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautillé?', a:'Spiccato is placed/rebounded; sautillé is natural spring at faster tempi.', wrong:['Spiccato is legato','Sautillé is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];
    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy martelé at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist collé','Firm staccato','Always play sul ponticello'] },
    ];
    function BielerLab({ onBack }) {
      const [mode,setMode] = React.useState('vocab');
      const [vi,setVi] = React.useState(0);
      const [reveal,setReveal] = React.useState(false);
      const nextV=()=>{ setReveal(false); setVi((vi+1)%BIELER_VOCAB.length); };
      const prevV=()=>{ setReveal(false); setVi((vi-1+BIELER_VOCAB.length)%BIELER_VOCAB.length); };
      const makeConceptQ = React.useCallback(()=>{
        const item = getRandom(BIELER_CONCEPT_QA);
        return { prompt:item.q, correct:item.a, options: shuffle([item.a, ...shuffle(item.wrong).slice(0,3)]) };
      },[]);
      const makeApplyQ = React.useCallback(()=>{
        const item = getRandom(BIELER_APPLY);
        return { prompt:item.scenario, correct:item.answer, options: shuffle([item.answer, ...shuffle(item.wrong).slice(0,3)]) };
      },[]);
      const [cq,setCq] = React.useState(makeConceptQ);
      const [aq,setAq] = React.useState(makeApplyQ);
      const [selC,setSelC] = React.useState(null);
      const [selA,setSelA] = React.useState(null);
      const [scoreC,setScoreC] = React.useState(0), [answeredC,setAnsweredC] = React.useState(0);
      const [scoreA,setScoreA] = React.useState(0), [answeredA,setAnsweredA] = React.useState(0);
      const answerConcept=(opt,idx)=>{
        if(selC!==null) return;
        setSelC(idx);
        const ok = opt===cq.correct;
        speakSR(ok ? 'Correct, great job!' : 'Oops, almost!');
        if(ok) setScoreC(s=>s+1);
        setAnsweredC(a=>a+1);
        addXP(ok?4:1);
        audioEngine.playFeedback(ok);
        setTimeout(()=>{ setCq(makeConceptQ()); setSelC(null); }, ok?350:700);
      };
      const answerApply=(opt,idx)=>{
        if(selA!==null) return;
        setSelA(idx);
        const ok = opt===aq.correct;
        speakSR(ok ? 'Correct, great job!' : 'Oops, almost!');
        if(ok) setScoreA(s=>s+1);
        setAnsweredA(a=>a+1);
        addXP(ok?5:2);
        audioEngine.playFeedback(ok);
        setTimeout(()=>{ setAq(makeApplyQ()); setSelA(null); }, ok?350:700);
      };
      useAnswerHotkeys(
        mode!=='vocab',
        (i)=>{ if(mode==='concept' && cq.options[i]) answerConcept(cq.options[i], i); if(mode==='apply' && aq.options[i]) answerApply(aq.options[i], i); },
        onBack,
        mode==='concept' ? (cq.options?.length||4) : (aq.options?.length||4)
      );
      React.useEffect(()=>{
        const onKey=(e)=>{
          if(e.key==='Escape'){ onBack(); }
          if(mode==='vocab'){
            if(e.key==='ArrowRight') nextV();
            if(e.key==='ArrowLeft')  prevV();
          }
        };
        window.addEventListener('keydown',onKey);
        return ()=>window.removeEventListener('keydown',onKey);
      },[mode,vi,onBack]);
      return (
        <div>
          <div className="card">
            <h2>Technique Lab</h2>
            <p style={{color:'var(--ink-light)',marginTop:-6}}>Progressive study: build vocabulary → check concepts → apply to musical/technique scenarios.</p>
            <div className="row" style={{margin:'0.5rem 0 1rem'}}>
              <button className="btn btn-primary" onClick={()=>setMode('vocab')}   aria-pressed={mode==='vocab'}>Vocabulary</button>
              <button className="btn btn-primary" onClick={()=>setMode('concept')} aria-pressed={mode==='concept'}>Concept Check</button>
              <button className="btn btn-primary" onClick={()=>setMode('apply')}   aria-pressed={mode==='apply'}>Applications</button>
            </div>
            {mode==='vocab' && (
              <div>
                <div className="card" style={{padding:'1rem',textAlign:'center',marginBottom:'0.5rem'}}>
                  <div style={{fontWeight:700,fontSize:'1.15rem'}}>{BIELER_VOCAB[vi].term}</div>
                  {reveal ? <div style={{marginTop:'0.5rem',color:'var(--ink-light)'}}>{BIELER_VOCAB[vi].def}</div>
                          : <div style={{marginTop:'0.5rem',fontStyle:'italic',color:'var(--ink-light)'}}>Press Reveal to show definition.</div>}
                </div>
                <div className="row" style={{justifyContent:'center'}}>
                  <button className="btn btn-primary"   onClick={()=>setReveal(true)}>Reveal</button>
                  <button className="btn btn-secondary" onClick={prevV}>Previous</button>
                  <button className="btn btn-secondary" onClick={nextV}>Next</button>
                </div>
                <div style={{marginTop:'0.5rem',textAlign:'center',color:'var(--ink-light)'}}>
                  <small>Card {vi+1} / {BIELER_VOCAB.length}</small>
                  <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}>
                    <div style={{width:`${((vi+1)/BIELER_VOCAB.length)*100}%`,height:'100%',background:'var(--primary)'}}/>
                  </div>
                </div>
              </div>
            )}
            {mode==='concept' && (
              <div>
                <div style={{color:'var(--ink-light)',marginBottom:'0.25rem'}}>Score: {scoreC} / {answeredC}</div>
                <p style={{fontWeight:600}}>{cq.prompt}</p>
                <div role="radiogroup" aria-label="Concept answers">
                  {cq.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selC===i} onClick={()=>answerConcept(opt,i)} />))}
                </div>
              </div>
            )}
            {mode==='apply' && (
              <div>
                <div style={{color:'var(--ink-light)',marginBottom:'0.25rem'}}>Score: {scoreA} / {answeredA}</div>
                <p><em>Scenario:</em> {aq.prompt}</p>
                <p style={{fontWeight:600, marginTop:'0.25rem'}}>Choose the best practice approach:</p>
                <div role="radiogroup" aria-label="Application answers">
                  {aq.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selA===i} onClick={()=>answerApply(opt,i)} />))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Speed Drill -----------------------------------------------------------------
    function SpeedDrill({prefs,onBack}){
      const [stats,setStats]=React.useState(()=>loadJSON(STATS_KEY,{}));
      const cells = React.useMemo(() => filteredCells(prefs), [prefs]);
      const [time,setTime]=React.useState(90);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const [mode, setMode] = React.useState('choose'); // 'choose' | 'listen'

      const pick = React.useCallback((statsArg) => {
        if(!cells.length){ setQ(null); return; }
        const sstats = statsArg ?? stats;
        const weight = c => {
          const k = `${c.s}:${c.p}:${c.f}`;
          const st = sstats[k] || { correct: 0, total: 0 };
          const acc = st.total ? st.correct / st.total : 0;
          return 1 - acc + 0.05;
        };
        const total=cells.reduce((sum,c)=>sum+weight(c),0);
        let r=Math.random()*total; let chosen=cells[cells.length-1];
        for(const c of cells){ r-=weight(c); if(r<=0){ chosen=c; break;} }
        const correct=chosen.canon;
        const pool=[...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct);
        const opts=shuffle([correct,...shuffle(pool).slice(0,3)]);
        setQ({cell:chosen,options:opts});
        setSelected(null);
        try{ const midi=MIDI_BASE[chosen.s] + POS_SHIFT[chosen.p] + BASE_OFF[chosen.f]; audioEngine.playNote({midi}); }catch{}
      },[cells,stats]);

      React.useEffect(()=>{ pick(); },[cells]);

      React.useEffect(()=>{
        if(paused) return;
        const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000);
        return ()=>clearInterval(id);
      },[paused]);

      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok= opt===q.cell.canon;
          speakSR(ok ? 'Correct, great job!' : 'Oops, almost!');
          audioEngine.playFeedback(ok);
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          setStats(prev=>{
            const k = `${q.cell.s}:${q.cell.p}:${q.cell.f}`;
            const st = prev[k] || { correct: 0, total: 0 };
            const next = { ...prev, [k]: { correct: st.correct + (ok ? 1 : 0), total: st.total + 1 } };
            saveJSON(STATS_KEY, next);
            setTimeout(() => pick(next), 0);
            return next;
          });
          addXP(ok?8:2);
        },200);
      };
      useAnswerHotkeys(mode==='choose' && !!q,(i)=>{ if(q && q.options[i]) answer(q.options[i],i) },onBack,q?.options?.length??4);

      const listenLabel = React.useMemo(()=> q ? `Play ${q.cell.canon} (finger ${q.cell.f}) in ${ordinal(q.cell.p)} position on ${q.cell.s} string` : '', [q]);
      const handleListenSuccess = React.useCallback(()=>{
        if (!q) return;
        speakSR('Correct, in tune!'); audioEngine.playFeedback(true);
        setAnswered(a=>a+1); setScore(s=>s+1);
        setStats(prev=>{
          const k = `${q.cell.s}:${q.cell.p}:${q.cell.f}`;
          const st = prev[k] || { correct: 0, total: 0 };
          const next = { ...prev, [k]: { correct: st.correct + 1, total: st.total + 1 } };
          saveJSON(STATS_KEY, next);
          setTimeout(() => pick(next), 0);
          return next;
        });
        addXP(10);
      }, [q, pick]);

      if(time===0) return (<div className="card"><h2>Speed Drill Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>);
      if(!cells.length) return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;

      return (
        <div>
          <div className="card">
            <h2>Speed Drill</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <div className="row" style={{marginBottom:'.5rem'}}>
              <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
              <PillToggle label={mode==='choose' ? 'Mode: Choose' : 'Mode: Listen & Play'} pressed={mode==='listen'} onClick={()=>setMode(m=> m==='choose' ? 'listen' : 'choose')} />
            </div>

            {q && mode==='choose' && (
              <div>
                <p>What is the base note at <strong>{ordinal(q.cell.p)} pos, {ordinal(q.cell.f)} finger on {q.cell.s}</strong>?</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
              </div>
            )}

            {q && mode==='listen' && (
              <div>
                <ListenPlayPanel
                  targetMidi={MIDI_BASE[q.cell.s] + POS_SHIFT[q.cell.p] + BASE_OFF[q.cell.f]}
                  mode="exact"
                  label={listenLabel}
                  running={!paused}
                  onSuccess={handleListenSuccess}
                />
                <div className="row">
                  <button className="btn btn-secondary" onClick={()=>{
                    try{ const midi=MIDI_BASE[q.cell.s] + POS_SHIFT[q.cell.p] + BASE_OFF[q.cell.f]; audioEngine.playNote({midi}); }catch{}
                  }}>Replay Target</button>
                  <button className="btn btn-warning" onClick={()=>{
                    speakSR('Skipping.'); audioEngine.playFeedback(false);
                    setAnswered(a=>a+1);
                    setStats(prev=>{
                      const k = `${q.cell.s}:${q.cell.p}:${q.cell.f}`;
                      const st = prev[k] || { correct: 0, total: 0 };
                      const next = { ...prev, [k]: { correct: st.correct, total: st.total + 1 } };
                      saveJSON(STATS_KEY, next); setTimeout(() => pick(next), 0); return next;
                    });
                    addXP(1);
                  }}>Skip</button>
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Snapshot --------------------------------------------------------------------
    function Snapshot({prefs,onBack}){
      const cells=filteredCells(prefs);
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [state,setState]=React.useState('flash');
      const [flash,setFlash]=React.useState(null);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const flashRef=React.useRef(null);

      const pick=()=>{
        if(!cells.length){ setState('none'); return; }
        const s=getRandom(STRINGS.filter(s=>prefs.strings[s]));
        const p=getRandom(POSITIONS.filter(p=>prefs.positions[p]));
        const labels={}; FINGERS.forEach(f=>{ labels[f]=canonicalBase(s,p,f); });
        setFlash({s,p,labels}); setState('flash'); setSelected(null);
        if(flashRef.current) clearTimeout(flashRef.current);
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const delay = (FLASH_DURATIONS[prefs.flashLevel] || 1000) * (prefersReduced ? 1.5 : 1);
        flashRef.current=setTimeout(()=>{
          const f=getRandom(FINGERS);
          const correct=labels[f];
          const opts=shuffle([correct,...shuffle([...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct)).slice(0,3)]);
          setQ({s,p,f,correct,options:opts}); setState('question'); setSelected(null);
          try { const midi=MIDI_BASE[s] + POS_SHIFT[p] + BASE_OFF[f]; audioEngine.playNote({midi}); }catch{}
        },delay);
      };
      React.useEffect(()=>{ pick(); return () => { if(flashRef.current){ clearTimeout(flashRef.current); flashRef.current=null; } }; },[]);
      React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]);

      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        setTimeout(()=>{
          const ok = opt === q.correct;
          speakSR(ok ? 'Correct, great job!' : 'Oops, almost!');
          audioEngine.playFeedback(ok);
          setAnswered(a=>a+1);
          if(ok) setScore(s=>s+1);
          updateStat(`${q.s}:${q.p}:${q.f}`, ok);
          addXP(ok?6:2);
          pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q && q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length ?? 4);

      if(time===0) return <div className="card"><h2>Snapshot Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      if(state==='none') return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;

      return (
        <div>
          <div className="card">
            <h2>Snapshot</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {state==='flash' && flash && (
              <div>
                <p>Memorize {flash.s} string {ordinal(flash.p)} pos:</p>
                <div className="grid grid-cols-2">
                  {FINGERS.map(f=>(
                    <div key={f} className="card" style={{padding:'0.5rem',textAlign:'center',borderRadius:'8px'}}>
                      <small>F{f}</small><br/><strong>{flash.labels[f]}</strong>
                    </div>
                  ))}
                </div>
                <button className="btn btn-primary" onClick={()=>{
                  if(flashRef.current){ clearTimeout(flashRef.current); flashRef.current=null; }
                  const s=flash.s; const p=flash.p; const f=getRandom(FINGERS); const correct=flash.labels[f];
                  const opts=shuffle([correct,...shuffle([...new Set(cells.map(c=>c.canon))].filter(n=>n!==correct)).slice(0,3)]);
                  setQ({s,p,f,correct,options:opts}); setState('question'); setSelected(null);
                  try { const midi=MIDI_BASE[s] + POS_SHIFT[p] + BASE_OFF[f]; audioEngine.playNote({midi}); }catch{}
                }}>Ready</button>
              </div>
            )}
            {state==='question' && q && (
              <div>
                <p>Which base note is F{q.f} at {ordinal(q.p)} pos on {q.s}?</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Interval Sprint -------------------------------------------------------------
    function IntervalSprint({prefs,onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const tRef = React.useRef(null);
      const pick=()=>{
        const strings=STRINGS.filter(s=>prefs.strings[s]);
        const pos=POSITIONS.filter(p=>prefs.positions[p]);
        if(!strings.length || !pos.length){ setQ(null); return; }
        const s=getRandom(strings); const p=getRandom(pos); const [a,b]=getRandom([[1,2],[2,3],[3,4]]);
        const diff=Math.abs(BASE_OFF[b]-BASE_OFF[a]); const type= diff===1? 'half':'whole';
        setQ({s,p,a,b,type}); setSelected(null);
        try { const root = MIDI_BASE[s] + POS_SHIFT[p] + BASE_OFF[a]; audioEngine.playInterval({rootMidi: root, semitones: Math.abs(BASE_OFF[b]-BASE_OFF[a])}); } catch {}
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]);
      const answer=(choice,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        clearTimeout(tRef.current);
        tRef.current = setTimeout(()=>{
          const ok=choice===q.type;
          speakSR(ok ? 'Correct, great job!' : 'Oops, almost!'); audioEngine.playFeedback(ok);
          setAnswered(a=>a+1); if(ok) setScore(s=>s+1);
          updateStat(`${q.s}:${q.p}:${q.a}-${q.b}`, ok); addXP(ok?4:1);
          pick();
        },200);
      };
      React.useEffect(()=>()=>clearTimeout(tRef.current),[]);
      useAnswerHotkeys(!!q,(i)=>{ if(q){ const opt=i===0?'half':'whole'; answer(opt,i); } },onBack,2);
      if(time===0) return <div className="card"><h2>Interval Sprint Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      if(!q) return <div className="card"><h2>No valid cells</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      const noteA=canonicalBase(q.s,q.p,q.a), noteB=canonicalBase(q.s,q.p,q.b);
      return (
        <div>
          <div className="card">
            <h2>Interval Sprint</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            <p>In {ordinal(q.p)} pos on {q.s} string, between {noteA} and {noteB}: Half or Whole step?</p>
            <div role="radiogroup" aria-label="Answer choices">
              <OptionButton label="Half Step" selected={selected===0} onClick={()=>answer('half',0)}/>
              <OptionButton label="Whole Step" selected={selected===1} onClick={()=>answer('whole',1)}/>
            </div>
            {q && (<button className="btn btn-secondary" onClick={()=>{
              try{ const root = MIDI_BASE[q.s] + POS_SHIFT[q.p] + BASE_OFF[q.a];
                audioEngine.playInterval({ rootMidi: root, semitones: Math.abs(BASE_OFF[q.b]-BASE_OFF[q.a]) }); } catch {}
            }}>Play Again</button>)}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Note Locator ----------------------------------------------------------------
    function NoteLocator({prefs,onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const [mode, setMode] = React.useState('choose');

      const pick=()=>{
        const strings=STRINGS.filter(s=>prefs.strings[s]);
        const pos=POSITIONS.filter(p=>prefs.positions[p]);
        if(!strings.length || !pos.length){ setQ(null); return; }
        const cells=CELLS.filter(c=>prefs.strings[c.s] && prefs.positions[c.p]);
        const chosen=getRandom(cells); const note=chosen.canon;
        const correct={s:chosen.s,p:chosen.p,f:chosen.f};
        const samePitch=cells.filter(c=>c.canon===note && !(c.s===correct.s && c.p===correct.p && c.f===correct.f));
        const distract= samePitch.length>=3? shuffle(samePitch).slice(0,3) : shuffle(cells.filter(c=>c.canon!==note)).slice(0,3);
        const opts=shuffle([{...correct},...distract.map(c=>({s:c.s,p:c.p,f:c.f}))]).slice(0,4);
        setQ({note,correct,options:opts, feedback:null}); setSelected(null);
        try{ const midi = MIDI_BASE[correct.s] + POS_SHIFT[correct.p] + BASE_OFF[correct.f]; audioEngine.playNote({midi}); }catch{}
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]);

      const answer=(opt,idx)=>{
        if(selected !== null) return;
        setSelected(idx);
        const ok = opt.s===q.correct.s && opt.p===q.correct.p && opt.f===q.correct.f;
        setQ(prev => prev && {
          ...prev,
          feedback: prev.options.map(o => {
            const isCorrect = (o.s===prev.correct.s && o.p===prev.correct.p && o.f===prev.correct.f);
            const isChosen  = (o.s===opt.s && o.p===opt.p && o.f===opt.f);
            return {...o, kind: isCorrect ? 'correct' : isChosen ? 'chosen' : 'distractor'};
          })
        });
        setTimeout(()=>{
          speakSR(ok ? 'Correct, great job!' : 'Oops, almost!'); audioEngine.playFeedback(ok);
          setAnswered(a=>a+1); if(ok) setScore(s=>s+1);
          updateStat(`${q.correct.s}:${q.correct.p}:${q.correct.f}`, ok); addXP(ok?4:1);
          pick();
        },450);
      };
      useAnswerHotkeys(mode==='choose' && !!q,(i)=>{ if(q && q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);

      const ENH_PC = {0:'C',1:'C#/Db',2:'D',3:'D#/Eb',4:'E',5:'F',6:'F#/Gb',7:'G',8:'G#/Ab',9:'A',10:'A#/Bb',11:'B'};
      const targetPc = React.useMemo(()=> Object.entries(ENH_PC).find(([,n])=>n.includes(q?.note||'')) ? NOTE_TO_PC[q?.note] : null, [q]);
      const listenLabel = React.useMemo(()=> q ? `Play the note ${q.note} (any octave)` : '', [q]);

      const handleListenSuccess = React.useCallback(()=>{
        if (!q) return;
        speakSR('Correct, in tune!'); audioEngine.playFeedback(true);
        setAnswered(a=>a+1); setScore(s=>s+1); updateStat(`mic.note:${q.note}`, true); addXP(8); pick();
      }, [q]);

      if(time===0) return (<div className="card"><h2>Note Locator Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>);
      if(!q) return <div className="card"><h2>No valid notes</h2><p>Enable strings and positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;

      return (
        <div>
          <div className="card">
            <h2>Note Locator</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <div className="row" style={{marginBottom:'.5rem'}}>
              <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
              <PillToggle label={mode==='choose' ? 'Mode: Choose' : 'Mode: Listen & Play'} pressed={mode==='listen'} onClick={()=>setMode(m=> m==='choose' ? 'listen' : 'choose')} />
            </div>

            {mode==='choose' && (
              <>
                <p>Where can you play {q.note}? Click the fingerboard:</p>
                <VisualFingerboard
                  highlight={(q.feedback || q.options).map(o=>({ s:o.s, p:o.p, f:o.f, kind:o.kind || 'distractor' }))}
                  disabled={!!q.feedback}
                  onSelect={(cell)=>answer(cell,0)}
                />
                <div className="row" style={{marginTop:'0.5rem',fontSize:'0.75rem',color:'var(--ink-light)'}}>
                  <span><strong>✓</strong> Correct</span>
                  <span><strong>✕</strong> Your choice</span>
                  <span>Pattern = available options</span>
                </div>
                <details style={{marginTop:'0.5rem'}}>
                  <summary>List options</summary>
                  {q.options.map((o,i)=>(<OptionButton key={i} label={`${o.s}: Pos ${o.p}, F${o.f}`} selected={false} onClick={()=>answer(o,i)}/>))}
                </details>
              </>
            )}

            {mode==='listen' && (
              <>
                <ListenPlayPanel
                  targetPc={targetPc}
                  mode="class"
                  label={listenLabel}
                  running={!paused}
                  allowReplay={false}
                  onSuccess={handleListenSuccess}
                />
                <div className="row">
                  <button className="btn btn-warning" onClick={()=>{
                    speakSR('Skipping.'); audioEngine.playFeedback(false);
                    setAnswered(a=>a+1); updateStat(`mic.note:${q.note}`, false); addXP(1); pick();
                  }}>Skip</button>
                </div>
              </>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Settings --------------------------------------------------------------------
    function Settings({prefs,setPrefs,onBack}){
      const [muted, setMuted] = React.useState(audioEngine.mute);
      const toggle=(type,key)=>{
        setPrefs(prev=>{
          const copy={...prev,[type]:{...prev[type],[key]:!prev[type][key]}};
          saveJSON(PREFS_KEY,copy); return copy;
        });
      };
      return (
        <div>
          <div className="card">
            <h2>Settings</h2>
            <h3>Theme</h3>
            <button className="btn btn-primary" onClick={()=>{ const dark=!document.documentElement.classList.contains('dark'); window.__setTheme(dark); }}>Toggle Dark Mode</button>
            <h3>Strings</h3>
            <div>{STRINGS.map(s=>(<PillToggle key={s} label={s} pressed={prefs.strings[s]} onClick={()=>toggle('strings',s)} />))}</div>
            <h3>Positions</h3>
            <div>{POSITIONS.map(p=>(<PillToggle key={p} label={p} pressed={prefs.positions[p]} onClick={()=>toggle('positions',p)} />))}</div>
            <h3>Snapshot Flash Duration</h3>
            <div>{['Beginner','Intermediate','Advanced','Professional','Master'].map(level=>(
              <PillToggle key={level} label={level} pressed={prefs.flashLevel===level} onClick={()=>{
                setPrefs(prev=>{ const next={...prev,flashLevel:level}; saveJSON(PREFS_KEY,next); return next; });
              }}/>
            ))}</div>
            <p style={{marginTop:'1rem',color:'var(--ink-light)'}}>Select strings and positions for drills. Choose flash duration (Beginner = slowest) for Snapshot memorization.</p>
            <h3>Audio</h3>
            <button className="btn btn-primary" onClick={()=>audioEngine.ensure()}>Enable Sound</button>
            <button className="btn" style={{background: muted ? 'var(--danger)' : 'var(--primary)'}}
              onClick={()=>{ audioEngine.setMute(!muted); setMuted(!muted); }}>
              {muted ? 'Unmute' : 'Mute'}
            </button>
            <h3>Data Tools</h3>
            <button className="btn btn-primary" onClick={()=>{
              const data={}; Object.keys(localStorage).filter(k=>k.startsWith('vmq.v4')||k.startsWith('vmq.v5')).forEach(k=>{ data[k]=localStorage.getItem(k); });
              const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
              const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='vmq-data.json'; a.click(); URL.revokeObjectURL(url);
            }}>Export Data</button>
            <label className="btn btn-warning" style={{cursor:'pointer'}}>
              Import Data
              <input type="file" accept="application/json" style={{display:'none'}} onChange={(e)=>{
                const f=e.target.files?.[0]; if(!f) return;
                const r=new FileReader();
                r.onload=()=>{
                  try{
                    const obj=JSON.parse(r.result);
                    Object.entries(obj).forEach(([k,v])=>{ if (/^vmq\.v[45]\./.test(k)) localStorage.setItem(k, v); });
                    alert('Import complete. Please reload.');
                  }catch{ alert('Invalid JSON'); }
                };
                r.readAsText(f);
              }}/>
            </label>
            <button className="btn btn-danger" onClick={()=>{
              if(confirm('Reset all VMQ data?')){
                Object.keys(localStorage).filter(k=>k.startsWith('vmq.v4')||k.startsWith('vmq.v5')).forEach(k=>localStorage.removeItem(k));
                location.reload();
              }
            }}>Reset All Data</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Stats -----------------------------------------------------------------------
    function StatsPage({onBack}){
      const stats = loadJSON(STATS_KEY,{});
      const xp    = loadJSON(XP_KEY,0);
      const lvl   = levelForXP(xp);
      const prev  = lvl>1? nextLevelXP(lvl-1):0;
      const next  = nextLevelXP(lvl);
      const pct   = Math.max(0, Math.min(1, isFinite((xp-prev)/(next-prev)) ? (xp-prev)/(next-prev) : 0));

      const isCellKey = (k)=>{ const parts=k.split(':'); return parts.length===3 && STRINGS.includes(parts[0]) && POSITIONS.includes(Number(parts[1])) && FINGERS.includes(Number(parts[2])) && !parts[2].includes('-'); };
      const isIntervalKey = (k)=>{ const parts=k.split(':'); return parts.length===3 && STRINGS.includes(parts[0]) && POSITIONS.includes(Number(parts[1])) && /^(1|2|3|4)-(1|2|3|4)$/.test(parts[2]); };

      const filteredCells = Object.fromEntries(Object.entries(stats).filter(([k])=>isCellKey(k)));
      const intervalPairs = Object.entries(stats).filter(([k])=>isIntervalKey(k)).map(([k,st])=>{
        const [s,p,ab] = k.split(':'); const [a,b] = ab.split('-').map(Number);
        const diff = Math.abs(BASE_OFF[b]-BASE_OFF[a]); const typ  = diff===1 ? 'Half Step' : 'Whole Step';
        return { s, p:Number(p), a, b, type:typ, ...st };
      });

      function csvEscape(v){ const s=String(v??''); return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s; }
      function exportCSV(){
        const student = prompt('Student name (optional):') || '';
        const klass   = prompt('Class/Teacher (optional):') || '';
        const dateStr = new Date().toISOString();
        const rows = [['Student','Class','Date','Category','Item','Correct','Total','Accuracy%']];
        for (const [k, st] of Object.entries(filteredCells)){
          const [s,p,f] = k.split(':'); const acc = st.total ? Math.round((st.correct/st.total)*100) : 0;
          rows.push([student, klass, dateStr, 'Note (Fingerboard)', `${s}, ${ordinal(Number(p))} pos, F${f}`, st.correct, st.total, acc]);
        }
        for (const it of intervalPairs){
          const acc = it.total ? Math.round((it.correct/it.total)*100) : 0;
          rows.push([student, klass, dateStr, 'Interval', `${it.s}, ${ordinal(it.p)} pos, F${it.a}\u2192F${it.b} (${it.type})`, it.correct, it.total, acc]);
        }
        const csv = rows.map(r=>r.map(csvEscape).join(',')).join('\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `vmq-progress-${dateStr.slice(0,10)}.csv`; a.click(); URL.revokeObjectURL(a.href);
      }

      return (
        <div>
          <div className="card">
            <h2>Your Progress</h2>
            <p>Level {lvl} (XP {xp-prev}/{next-prev})</p>
            <div className="progress-bar" style={{height:'8px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden'}}>
              <div style={{height:'100%',width:`${pct*100}%`,background:'var(--primary)'}} />
            </div>
            <p style={{marginTop:'0.5rem'}}>Badges: <span aria-label={`Level ${lvl} badges`} title={`Level ${lvl}`}>{'⭐'.repeat(Math.min(10, lvl))}{lvl > 10 ? ` ×${lvl}` : ''}</span></p>
            <div className="row" style={{marginTop:'.5rem'}}>
              <button className="btn btn-primary" onClick={exportCSV}>Export CSV</button>
              <button className="btn btn-secondary" onClick={()=>{ speakSR('Preparing print view.'); window.print(); }}>Print Report</button>
            </div>
          </div>

          {STRINGS.map(s=>(
            <div className="card" key={s}>
              <h3>{s} string</h3>
              <div className="grid" style={{gridTemplateColumns:'repeat(5,1fr)',gap:'0.3rem', overflowX:'auto'}}>
                {POSITIONS.map(p=>(
                  <div key={p} style={{display:'grid',gridTemplateColumns:'repeat(4,1fr)',gap:'2px'}}>
                    {FINGERS.map(f=>{
                      const k=`${s}:${p}:${f}`; const st=filteredCells[k]||{correct:0,total:0}; const acc= st.total? st.correct/st.total:0;
                      let col, ink='#fff';
                      if(st.total===0) { col='var(--neutral)'; }
                      else if(acc<0.5){ col='var(--danger)'; }
                      else if(acc<0.75){ col='var(--warning)'; ink='#111'; }
                      else { col='var(--success)'; }
                      const label=st.total? `${Math.round(acc*100)}%`:'';
                      return (<div key={f} className="heat-cell" style={{background:col,color:ink,fontSize:'0.65rem'}} title={`Pos ${p}, F${f}: ${st.correct}/${st.total}`}>{label}</div>);
                    })}
                  </div>
                ))}
              </div>
            </div>
          ))}

          <div className="card">
            <h3>Intervals (summary)</h3>
            {intervalPairs.length===0 ? (
              <p style={{color:'var(--ink-light)'}}>No interval data yet.</p>
            ) : (
              <div style={{overflowX:'auto'}}>
                <table style={{width:'100%', borderCollapse:'collapse'}}>
                  <thead>
                    <tr>
                      <th style={{textAlign:'left', borderBottom:'1px solid var(--border)'}}>Item</th>
                      <th style={{textAlign:'right', borderBottom:'1px solid var(--border)'}}>Correct</th>
                      <th style={{textAlign:'right', borderBottom:'1px solid var(--border)'}}>Total</th>
                      <th style={{textAlign:'right', borderBottom:'1px solid var(--border)'}}>Accuracy</th>
                    </tr>
                  </thead>
                  <tbody>
                    {intervalPairs.sort((a,b)=> (a.total? a.correct/a.total:0) - (b.total? b.correct/b.total:0)).map((it,i)=>{
                      const acc = it.total ? Math.round((it.correct/it.total)*100) : 0;
                      return (
                        <tr key={i}>
                          <td>{it.s}, {ordinal(it.p)} pos, F{it.a}→F{it.b} ({it.type})</td>
                          <td style={{textAlign:'right'}}>{it.correct}</td>
                          <td style={{textAlign:'right'}}>{it.total}</td>
                          <td style={{textAlign:'right'}}>{acc}%</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            )}
          </div>

          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Theory (Tempo/Interval/Key/Time trainers & testers) -------------------------
    const TEMPOS=[{it:'Prestissimo',en:'extremely fast',range:'≥200 bpm'},{it:'Presto',en:'very fast',range:'168–200 bpm'},{it:'Allegro',en:'fast, lively',range:'120–168 bpm'},{it:'Allegretto',en:'moderately fast',range:'112–120 bpm'},{it:'Andante',en:'walking tempo',range:'76–108 bpm'},{it:'Andantino',en:'slightly faster than Andante',range:'80–112 bpm'},{it:'Adagio',en:'slow, majestic',range:'66–76 bpm'},{it:'Largo',en:'very broad and slow',range:'40–60 bpm'},{it:'Lento',en:'very slow',range:'40–60 bpm'}];
    const INTERVALS=[{name:'Minor 2nd', semitones:1, feel:'Sad, tense, spooky', cue:'Jaws Theme, Für Elise'},{name:'Major 2nd', semitones:2, feel:'Happy, bright, curious', cue:'Happy Birthday (1st 2 notes)'},{name:'Minor 3rd', semitones:3, feel:'Tragic, melancholy', cue:'Greensleeves, Brahms’ Lullaby'},{name:'Major 3rd', semitones:4, feel:'Very happy, warm', cue:'When the Saints Go Marching'},{name:'Perfect 4th', semitones:5, feel:'Strong, open', cue:'Here Comes the Bride, Amazing Grace'},{name:'Tritone', semitones:6, feel:'Alert, tense', cue:'Emergency sirens, The Simpsons'},{name:'Perfect 5th', semitones:7, feel:'Heroic, open', cue:'Twinkle Twinkle, Star Wars'},{name:'Minor 6th', semitones:8, feel:'Bittersweet, longing', cue:'In My Life, Imperial March'},{name:'Major 6th', semitones:9, feel:'Lyrical, hopeful', cue:'My Bonnie Lies Over the Ocean, NBC chimes'},{name:'Minor 7th', semitones:10, feel:'Distant, complex', cue:'Somewhere (West Side Story), Pure Imagination'},{name:'Major 7th', semitones:11, feel:'Intense, unresolved', cue:'Take On Me (A-ha)'},{name:'Octave', semitones:12, feel:'Complete, powerful', cue:'Somewhere Over the Rainbow'}];
    const KEY_SIGNATURES=[{key:'C Major', type:'none', count:0},{key:'G Major', type:'sharp', count:1},{key:'D Major', type:'sharp', count:2},{key:'A Major', type:'sharp', count:3},{key:'E Major', type:'sharp', count:4},{key:'B Major', type:'sharp', count:5},{key:'F# Major', type:'sharp', count:6},{key:'C# Major', type:'sharp', count:7},{key:'F Major', type:'flat', count:1},{key:'Bb Major', type:'flat', count:2},{key:'Eb Major', type:'flat', count:3},{key:'Ab Major', type:'flat', count:4},{key:'Db Major', type:'flat', count:5},{key:'Gb Major', type:'flat', count:6},{key:'Cb Major', type:'flat', count:7}];
    const TIME_SIGNATURES=[{sig:'2/4', description:'2 quarter-note beats per measure (simple duple)'},{sig:'3/4', description:'3 quarter-note beats per measure (simple triple)'},{sig:'4/4', description:'4 quarter-note beats per measure (common time)'},{sig:'6/8', description:'6 eighth-note beats grouped in 2 dotted quarter beats (compound duple)'},{sig:'9/8', description:'9 eighth-note beats grouped in 3 dotted quarter beats (compound triple)'},{sig:'12/8', description:'12 eighth-note beats grouped in 4 dotted quarter beats (compound quadruple)'}];

    function TempoTrainer({ onBack }) {
      const [i, setI] = React.useState(0); const [show, setShow] = React.useState(false);
      const next = () => { setShow(false); setI((i + 1) % TEMPOS.length); };
      const prev = () => { setShow(false); setI((i - 1 + TEMPOS.length) % TEMPOS.length); };
      const t = TEMPOS[i];
      return (
        <div>
          <div className="card">
            <h2>Tempo Trainer</h2>
            <p><strong>{t.it}</strong></p>
            {show ? <p>{t.en} — {t.range}</p> : <button className="btn btn-primary" onClick={() => setShow(true)}>Reveal</button>}
            <div style={{ marginTop: '0.5rem' }}>
              <button className="btn btn-secondary" onClick={prev}>Prev</button>
              <button className="btn btn-primary" onClick={next}>Next</button>
              <button className="btn btn-success" onClick={() => { speak(t.it); speak(t.en); }}>Speak</button>
            </div>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }
    function TempoTester({onBack}){
      const [cursor, setCursor] = React.useState(0);
      const [time,setTime]=React.useState(60); const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0); const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null); const [selected,setSelected]=React.useState(null);
      const tRef = React.useRef(null);
      const pick=()=>{ const term=getRandom(TEMPOS); const correct=term.en;
        const opts=shuffle([correct,...shuffle(TEMPOS.map(x=>x.en).filter(x=>x!==correct)).slice(0,3)]);
        setQ({term:term.it,correct,options:opts}); setSelected(null);
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]);
      const answer=(opt,idx)=>{
        setSelected(idx); clearTimeout(tRef.current);
        tRef.current = setTimeout(()=>{
          const ok = opt === q.correct; speakSR(ok ? 'Correct, great job!' : 'Oops, almost!'); audioEngine.playFeedback(ok);
          setAnswered(a=>a+1); if(ok) setScore(s=>s+1); addXP(ok?5:2); pick();
        },200);
      };
      React.useEffect(()=>()=>clearTimeout(tRef.current),[]);
      function useRadioHotkeys(enabled, { count = 4, onMove, onSubmit, onBack }) {
        const cursorRef = React.useRef(0);
        React.useEffect(() => { cursorRef.current = 0; }, [enabled, count]);
        React.useEffect(() => {
          if (!enabled) return;
          const handler = (e) => {
            const t=e.target; const tag=(t&&t.tagName||'').toLowerCase();
            if (['input','select','textarea'].includes(tag) || (t && t.isContentEditable)) return;
            const max=Math.max(0,(count??4)-1); const k=e.key; let handled=false;
            if (k>='1' && k<='9'){ const idx=Math.min(Number(k)-1,max); cursorRef.current=idx; onMove?.(idx); handled=true; }
            else if (k==='ArrowRight'||k==='ArrowDown'){ const next=Math.min((cursorRef.current<0?0:cursorRef.current)+1, max); cursorRef.current=next; onMove?.(next); handled=true; }
            else if (k==='ArrowLeft'||k==='ArrowUp'){ const prev=Math.max((cursorRef.current<0?0:cursorRef.current)-1, 0); cursorRef.current=prev; onMove?.(prev); handled=true; }
            else if (k==='Enter'||k===' '){ onSubmit?.(cursorRef.current); handled=true; }
            else if (k==='Escape'){ onBack?.(); handled=true; }
            if (handled){ e.preventDefault(); e.stopPropagation(); }
          };
          window.addEventListener('keydown', handler);
          return () => window.removeEventListener('keydown', handler);
        }, [enabled, count, onMove, onSubmit, onBack]);
      }
      useRadioHotkeys(!!q, { count: q?.options?.length ?? 4, onMove: setCursor, onSubmit: (i)=>{ if (q && q.options[i]) answer(q.options[i], i); }, onBack });
      if(time===0) return <div className="card"><h2>Tempo Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Tempo Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>What does {q.term} mean?</p>
                {q.options.map((opt,i)=>(
                  <OptionButton key={i} label={opt} selected={cursor===i} shortcut={String(i+1)} onClick={()=>answer(opt,i)} autoFocus={i===0} />
                ))}
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    function TheoryHome({onBack,onNavigate}){
      return (
        <div>
          <div className="card">
            <h2>Music Theory</h2>
            <p>Explore intervals, key signatures and time signatures.</p>
            <button className="btn btn-primary" onClick={()=>onNavigate('intervalTrainer')}>Intervals Trainer</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('intervalTester')}>Intervals Tester</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('keyTrainer')}>Key Sig Trainer</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('keyTester')}>Key Sig Tester</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('timeTrainer')}>Time Sig Trainer</button>
            <button className="btn btn-primary" onClick={()=>onNavigate('timeTester')}>Time Sig Tester</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }
    function IntervalTrainer({onBack}){
      const [index,setIndex]=React.useState(0);
      const next=()=>setIndex((index+1)%INTERVALS.length);
      const i=INTERVALS[index]; const total=INTERVALS.length; const progress=(index+1)/total;
      return (
        <div>
          <div className="card">
            <h2>Intervals Trainer</h2>
            <p><strong>{i.name}</strong> — {i.semitones} semitone{i.semitones>1?'s':''}</p>
            <p><em>Feel:</em> {i.feel}</p>
            <p><em>Song cue:</em> {i.cue}</p>
            <div style={{margin:'0.5rem 0'}}>
              <small>Card {index+1} of {total}</small>
              <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}>
                <div style={{width:`${progress*100}%`,height:'100%',background:'var(--primary)'}}></div>
              </div>
            </div>
            <button className="btn btn-primary" onClick={next}>Next</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }
    function IntervalTester({onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const item=getRandom(INTERVALS);
        let prompt, correct, opts;
        if(Math.random()<0.5){
          correct=item.name;
          opts=shuffle([correct,...shuffle(INTERVALS.map(x=>x.name).filter(n=>n!==correct)).slice(0,3)]);
          prompt=`Which interval has ${item.semitones} semitone${item.semitones>1?'s':''}?`;
        } else {
          correct=item.name;
          const cue=item.cue.split(',')[0];
          opts=shuffle([correct,...shuffle(INTERVALS.map(x=>x.name).filter(n=>n!==correct)).slice(0,3)]);
          prompt=`Which interval matches the cue “${cue}”?`;
        }
        const semitones=item.semitones; const rootMidi = 64 + Math.floor(Math.random()*6);
        setQ({prompt,correct,options:opts,semitones,rootMidi}); setSelected(null);
        try{ audioEngine.playInterval({rootMidi,semitones:item.semitones}); }catch(e){}
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return; setSelected(idx);
        setTimeout(()=>{
          const ok = opt === q.correct; speakSR(ok ? 'Correct, great job!' : 'Oops, almost!'); audioEngine.playFeedback(ok);
          setAnswered(a=>a+1); if(ok) setScore(s=>s+1); addXP(ok?4:1); pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);
      if(time===0) return <div className="card"><h2>Intervals Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Intervals Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>{q.prompt}</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
                <button className="btn btn-secondary" onClick={()=>{ try{ audioEngine.playInterval({rootMidi:q.rootMidi, semitones:q.semitones}); }catch(e){} }}>Play Again</button>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }
    function KeyTrainer({onBack}){
      const [index,setIndex]=React.useState(0);
      const next=()=>setIndex((index+1)%KEY_SIGNATURES.length);
      const k=KEY_SIGNATURES[index]; const total=KEY_SIGNATURES.length; const progress=(index+1)/total;
      return (
        <div>
          <div className="card">
            <h2>Key Signatures Trainer</h2>
            <p><strong>{k.key}</strong></p>
            {k.type==='none'? <p>No sharps or flats.</p> : <p>{k.count} {k.type}{k.count>1?'s':''}.</p>}
            <div style={{margin:'0.5rem 0'}}>
              <small>Card {index+1} of {total}</small>
              <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}><div style={{width:`${progress*100}%`,height:'100%',background:'var(--primary)'}}></div></div>
            </div>
            <button className="btn btn-primary" onClick={next}>Next</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }
    function KeyTester({onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const item=getRandom(KEY_SIGNATURES);
        if(Math.random()<0.5){
          const correct=item.key;
          const desc=item.count===0? 'no sharps or flats' : `${item.count} ${item.type}${item.count>1?'s':''}`;
          const opts=shuffle([correct,...shuffle(KEY_SIGNATURES.map(x=>x.key).filter(k=>k!==correct)).slice(0,3)]);
          setQ({prompt:`Which major key has ${desc}?`,correct,options:opts});
        } else {
          const correct=item.count===0? 'no sharps or flats' : `${item.count} ${item.type}${item.count>1?'s':''}`;
          const descList=[...new Set(KEY_SIGNATURES.map(x=> x.count===0? 'no sharps or flats' : `${x.count} ${x.type}${x.count>1?'s':''}`))];
          const opts=shuffle([correct,...shuffle(descList.filter(v=>v!==correct)).slice(0,3)]);
          setQ({prompt:`How many sharps/flats does ${item.key} have?`,correct,options:opts});
        }
        setSelected(null);
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return; setSelected(idx);
        setTimeout(()=>{
          const ok = opt === q.correct; speakSR(ok ? 'Correct, great job!' : 'Oops, almost!'); audioEngine.playFeedback(ok);
          setAnswered(a=>a+1); if(ok) setScore(s=>s+1); addXP(ok?4:1); pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);
      if(time===0) return <div className="card"><h2>Key Sig Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Key Sig Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>{q.prompt}</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }
    function TimeTrainer({onBack}){
      const [index,setIndex]=React.useState(0);
      const next=()=>setIndex((index+1)%TIME_SIGNATURES.length);
      const t=TIME_SIGNATURES[index]; const total=TIME_SIGNATURES.length; const progress=(index+1)/total;
      return (
        <div>
          <div className="card">
            <h2>Time Sig Trainer</h2>
            <p><strong>{t.sig}</strong></p>
            <p>{t.description}</p>
            <div style={{margin:'0.5rem 0'}}>
              <small>Card {index+1} of {total}</small>
              <div style={{height:'6px',background:'var(--border)',borderRadius:'9999px',overflow:'hidden',marginTop:'2px'}}><div style={{width:`${progress*100}%`,height:'100%',background:'var(--primary)'}}></div></div>
            </div>
            <button className="btn btn-primary" onClick={next}>Next</button>
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }
    function TimeTester({onBack}){
      const [time,setTime]=React.useState(60);
      const [paused,setPaused]=React.useState(false);
      const [score,setScore]=React.useState(0);
      const [answered,setAnswered]=React.useState(0);
      const [q,setQ]=React.useState(null);
      const [selected,setSelected]=React.useState(null);
      const pick=()=>{
        const item=getRandom(TIME_SIGNATURES);
        const correct=item.sig;
        const opts=shuffle([correct,...shuffle(TIME_SIGNATURES.map(x=>x.sig).filter(s=>s!==correct)).slice(0,3)]);
        setQ({prompt:item.description,correct,options:opts}); setSelected(null);
      };
      React.useEffect(()=>{ pick(); },[]);
      React.useEffect(()=>{ if(paused) return; const id=setInterval(()=>setTime(t=>t<=1?0:t-1),1000); return ()=>clearInterval(id); },[paused]);
      const answer=(opt,idx)=>{
        if(selected !== null) return; setSelected(idx);
        setTimeout(()=>{
          const ok = opt === q.correct; speakSR(ok ? 'Correct, great job!' : 'Oops, almost!'); audioEngine.playFeedback(ok);
          setAnswered(a=>a+1); if(ok) setScore(s=>s+1); addXP(ok?4:1); pick();
        },200);
      };
      useAnswerHotkeys(!!q,(i)=>{ if(q&&q.options[i]) answer(q.options[i],i); },onBack,q?.options?.length??4);
      if(time===0) return <div className="card"><h2>Time Sig Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>;
      return (
        <div>
          <div className="card">
            <h2>Time Sig Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={()=>setPaused(p=>!p)}>{paused?'Resume':'Pause'}</button>
            {q && (
              <div>
                <p>{q.prompt}</p>
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt,i)=>(<OptionButton key={i} label={opt} selected={selected===i} onClick={()=>answer(opt,i)}/>))}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // -- Arpeggio Tester -------------------------------------------------------------
    function ArpeggioTester({ prefs, onBack }) {
      const [time, setTime] = React.useState(60);
      const [paused, setPaused] = React.useState(false);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      const [q, setQ] = React.useState(null);
      const [locked, setLocked] = React.useState(false);
      const cells = React.useMemo(() => filteredCells(prefs), [prefs]);
      const ENH = {0:'C',1:'C♯/D♭',2:'D',3:'D♯/E♭',4:'E',5:'F',6:'F♯/G♭',7:'G',8:'G♯/A♭',9:'A',10:'A♯/B♭',11:'B'};
      const pcName = (pc) => ENH[((pc % 12) + 12) % 12];

      const pick = React.useCallback(() => {
        if (!cells.length) { setQ(null); return; }
        const rootPc = Math.floor(Math.random() * 12);
        const type = Math.random() < 0.5 ? 'Major' : 'Minor';
        const thirdPc = (rootPc + (type === 'Major' ? 4 : 3)) % 12;
        const fifthPc = (rootPc + 7) % 12;
        const pcs = [rootPc, thirdPc, fifthPc];
        const pcNames = pcs.map(pcName);
        const keyName = `${pcName(rootPc)} ${type}`;
        setQ({ rootPc, type, pcs, pcNames, keyName, step: 0, picks: [] });
        setLocked(false);
        try { const base = 60; pcs.forEach((pc, i) => { setTimeout(() => audioEngine.playNote({ midi: base + pc, durationMs: 420 }), i * 220); }); } catch {}
      }, [cells]);

      React.useEffect(() => { pick(); }, [pick]);
      React.useEffect(() => { if (paused) return; const id = setInterval(() => setTime(t => (t <= 1 ? 0 : t - 1)), 1000); return () => clearInterval(id); }, [paused]);

      if (time === 0) return (<div className="card"><h2>Arpeggio Tester Complete</h2><p>Score {score}/{answered}</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>);
      if (!q) return (<div className="card"><h2>Arpeggio Tester</h2><p>No valid cells. Enable strings/positions in Settings.</p><button className="btn btn-secondary" onClick={onBack}>Back</button></div>);

      const onSelectCell = (cell) => {
        if (!q || locked) return;
        const expectedPc = q.pcs[q.step];
        const chosenName = canonicalBase(cell.s, cell.p, cell.f);
        const chosenPc = NOTE_TO_PC[chosenName] ?? -1;
        const ok = chosenPc === expectedPc;

        if (ok) {
          const picks = [...q.picks, { s: cell.s, p: cell.p, f: cell.f }];
          const nextStep = q.step + 1;
          if (nextStep >= q.pcs.length) {
            speakSR('Correct, great job!'); audioEngine.playFeedback(true);
            setScore(s => s + 1); setAnswered(a => a + 1); addXP(8); setLocked(true);
            setTimeout(() => pick(), 400);
          } else {
            audioEngine.playFeedback(true);
            setQ({ ...q, step: nextStep, picks });
          }
        } else {
          speakSR('Oops, almost!'); audioEngine.playFeedback(false);
          setAnswered(a => a + 1); addXP(2); setLocked(true);
          setTimeout(() => pick(), 600);
        }
      };
      const highlight = (q.picks || []).map(p => ({ ...p, kind: 'correct' }));

      return (
        <div>
          <div className="card">
            <h2>Arpeggio Tester</h2>
            <p>Time {time}s | Score {score}/{answered}</p>
            <button className="btn btn-secondary" onClick={() => setPaused(p => !p)}>{paused ? 'Resume' : 'Pause'}</button>
            <p style={{ marginTop: '0.5rem' }}>Build <strong>{q.keyName}</strong> — click <strong>{q.pcNames[q.step]}</strong> ({q.step + 1} of 3)</p>
            <button className="btn btn-primary" onClick={() => {
              try { const base = 60; q.pcs.forEach((pc, i) => { setTimeout(() => audioEngine.playNote({ midi: base + pc, durationMs: 420 }), i * 220); }); } catch {}
            }}>Play Arpeggio</button>
            <VisualFingerboard highlight={highlight} onSelect={onSelectCell} disabled={locked} />
          </div>
          <button className="btn btn-secondary" onClick={onBack}>Back</button>
        </div>
      );
    }

    // ===== App shell ================================================================
    function Home({navigate, prefs}) {
      const xp=loadJSON(XP_KEY,0); const lvl=levelForXP(xp);
      return (
        <div>
          <div className="card">
            <h2>Welcome!</h2>
            <p>Level <strong>{lvl}</strong> • XP <strong>{xp}</strong></p>
            <div className="grid grid-cols-2">
              <button className="btn btn-primary" onClick={()=>navigate('speed')}>Speed Drill</button>
              <button className="btn btn-primary" onClick={()=>navigate('snapshot')}>Snapshot</button>
              <button className="btn btn-primary" onClick={()=>navigate('intervalSprint')}>Interval Sprint</button>
              <button className="btn btn-primary" onClick={()=>navigate('noteLocator')}>Note Locator</button>
              <button className="btn btn-primary" onClick={()=>navigate('bielerLab')}>Technique Lab (Bieler)</button>
              <button className="btn btn-primary" onClick={()=>navigate('arpeggioTester')}>Arpeggio Tester</button>
              <button className="btn btn-secondary" onClick={()=>navigate('theoryHome')}>Music Theory</button>
              <button className="btn btn-secondary" onClick={()=>navigate('stats')}>Progress</button>
              <button className="btn btn-secondary" onClick={()=>navigate('settings')}>Settings</button>
            </div>
          </div>
          <div className="card">
            <h3>Tip</h3>
            <p>Use number keys 1–4 to answer quickly. Enable your mic for the “Listen &amp; Play” modes. For best results, open this file via a local server (e.g. <code>python3 -m http.server</code>) so the mic works.</p>
          </div>
        </div>
      );
    }

    function App(){
      const [route,setRoute]=React.useState('home');
      const [prefs,setPrefs]=React.useState(()=>loadJSON(PREFS_KEY, defaultPrefs));
      React.useEffect(()=>{ if(!localStorage.getItem(PREFS_KEY)) saveJSON(PREFS_KEY,prefs); },[]);
      const back=()=>setRoute('home');
      return (
        <div>
          {route==='home' && <Home navigate={setRoute} prefs={prefs} />}
          {route==='speed' && <SpeedDrill prefs={prefs} onBack={back} />}
          {route==='snapshot' && <Snapshot prefs={prefs} onBack={back} />}
          {route==='intervalSprint' && <IntervalSprint prefs={prefs} onBack={back} />}
          {route==='noteLocator' && <NoteLocator prefs={prefs} onBack={back} />}
          {route==='bielerLab' && <BielerLab onBack={back} />}
          {route==='theoryHome' && <TheoryHome onBack={back} onNavigate={setRoute} />}
          {route==='intervalTrainer' && <IntervalTrainer onBack={back} />}
          {route==='intervalTester' && <IntervalTester onBack={back} />}
          {route==='keyTrainer' && <KeyTrainer onBack={back} />}
          {route==='keyTester' && <KeyTester onBack={back} />}
          {route==='timeTrainer' && <TimeTrainer onBack={back} />}
          {route==='timeTester' && <TimeTester onBack={back} />}
          {route==='arpeggioTester' && <ArpeggioTester prefs={prefs} onBack={back} />}
          {route==='settings' && <Settings prefs={prefs} setPrefs={setPrefs} onBack={back} />}
          {route==='stats' && <StatsPage onBack={back} />}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>