<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Violin Mastery Quest</title>
  <style>
    /*
      This simplified implementation of the Violin Mastery Quest provides
      learners with multiple interactive modes while remaining selfâ€‘contained
      and easy to extend. It is not as feature rich as the original code,
      but it retains the essence of interval training, rhythm practice,
      flashcard review and Bieler vocabulary. Achievements track progress
      across modes and a small settings panel allows users to toggle
      instrument and mute audio. Feel free to build upon these styles or
      replace them entirely.
    */
    body {
      font-family: Arial, sans-serif;
      background-color: #f7f7f7;
      color: #333;
      margin: 0;
      padding: 0;
    }
    .app-container {
      max-width: 800px;
      margin: auto;
      padding: 20px;
    }
    h1, h2 {
      margin-bottom: 0.5rem;
    }
    .menu .menu-buttons button,
    .choices button,
    .flashcards button,
    .intervals button,
    .rhythm button,
    .settings button,
    .bieler button {
      margin: 0.25rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      background-color: #4a90e2;
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button:hover {
      background-color: #357ab8;
    }
    .note-card {
      font-size: 2rem;
      margin: 1rem 0;
      text-align: center;
    }
    input {
      padding: 0.25rem;
      margin-right: 0.5rem;
    }
    .achievements ul {
      list-style: none;
      padding-left: 0;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <!--
    Load React and Babel from unpkg. These scripts are served from a CDN
    rather than being bundled locally to keep the page lightweight. In
    production you would typically bundle your code with a build tool and
    avoid the Babel runtime overhead.
  -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    /*
      AudioEngine wraps a Web Audio context and provides a simple beep
      generator. The muted property allows toggling sound on and off at
      runtime. Frequencies are based on A440 standard tuning.
    */
    class AudioEngine {
      constructor() {
        this.audioCtx = null;
        this.muted = false;
      }
      ensureContext() {
        if (!this.audioCtx) {
          this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
      }
      beep(frequency = 440, duration = 0.5) {
        if (this.muted) return;
        this.ensureContext();
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.type = 'sine';
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        osc.frequency.value = frequency;
        osc.start();
        osc.stop(this.audioCtx.currentTime + duration);
      }
      setMute(mute) {
        this.muted = mute;
      }
    }

    /*
      App is the root component that manages navigation between different
      training modes, settings and achievements. It holds shared state
      representing the current screen, user achievements and settings such
      as the selected instrument and mute status. Each subâ€‘component
      receives callbacks to update these shared states when appropriate.
    */
    function App() {
      const [screen, setScreen] = React.useState('menu');
      const [achievements, setAchievements] = React.useState({
        intervals: 0,
        rhythm: 0,
        flashcards: 0,
        bieler: 0,
      });
      const [settings, setSettings] = React.useState({
        instrument: 'violin',
        mute: false,
      });
      // create one audio engine instance to be shared across modes
      const audioEngineRef = React.useRef(new AudioEngine());

      const incrementAchievement = (key) => {
        setAchievements((prev) => ({ ...prev, [key]: prev[key] + 1 }));
      };

      return (
        <div className="app-container">
          {screen === 'menu' && (
            <MainMenu
              onNavigate={setScreen}
              achievements={achievements}
            />
          )}
          {screen === 'intervals' && (
            <Intervals
              onBack={() => setScreen('menu')}
              audioEngine={audioEngineRef.current}
              onComplete={() => incrementAchievement('intervals')}
            />
          )}
          {screen === 'rhythm' && (
            <Rhythm
              onBack={() => setScreen('menu')}
              audioEngine={audioEngineRef.current}
              onComplete={() => incrementAchievement('rhythm')}
            />
          )}
          {screen === 'flashcards' && (
            <Flashcards
              onBack={() => setScreen('menu')}
              onComplete={() => incrementAchievement('flashcards')}
            />
          )}
          {screen === 'bieler' && (
            <Bieler
              onBack={() => setScreen('menu')}
              onComplete={() => incrementAchievement('bieler')}
            />
          )}
          {screen === 'settings' && (
            <Settings
              onBack={() => setScreen('menu')}
              settings={settings}
              onUpdate={(s) => {
                setSettings(s);
                audioEngineRef.current.setMute(s.mute);
              }}
              audioEngine={audioEngineRef.current}
            />
          )}
        </div>
      );
    }

    /*
      MainMenu displays the application title, a simple achievements overview
      and buttons to navigate to each of the training modes or settings. It
      remains intentionally uncluttered so learners can quickly jump to
      their desired activity.
    */
    function MainMenu({ onNavigate, achievements }) {
      return (
        <div className="menu">
          <h1>ðŸŽ» Violin Mastery Quest</h1>
          <p>An adaptive learning experience</p>
          <div className="achievements">
            <h2>Achievements</h2>
            <ul>
              <li>Intervals completed: {achievements.intervals}</li>
              <li>Rhythms completed: {achievements.rhythm}</li>
              <li>Flashcards reviewed: {achievements.flashcards}</li>
              <li>Bieler terms learned: {achievements.bieler}</li>
            </ul>
          </div>
          <div className="menu-buttons">
            <button onClick={() => onNavigate('intervals')}>Interval Training</button>
            <button onClick={() => onNavigate('rhythm')}>Rhythm Training</button>
            <button onClick={() => onNavigate('flashcards')}>Flashcards</button>
            <button onClick={() => onNavigate('bieler')}>Bieler Vocab</button>
            <button onClick={() => onNavigate('settings')}>Settings</button>
          </div>
        </div>
      );
    }

    /*
      Intervals presents pairs of notes and asks the learner to identify the
      interval between them. It plays the notes through the AudioEngine
      and displays a set of interval names to choose from. After the
      learner answers, a new question is generated. Correct answers
      increase the interval achievement count via the onComplete callback.
    */
    function Intervals({ onBack, audioEngine, onComplete }) {
      // define a chromatic octave of note names and their corresponding
      // frequencies (A4 = 440Hz; others derived via equal temperament)
      const notes = [
        'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4',
      ];
      const freqMap = {
        C4: 261.63,
        'C#4': 277.18,
        D4: 293.66,
        'D#4': 311.13,
        E4: 329.63,
        F4: 349.23,
        'F#4': 369.99,
        G4: 392.0,
        'G#4': 415.3,
        A4: 440.0,
        'A#4': 466.16,
        B4: 493.88,
      };
      // Candidate interval names and their semitone distances
      const intervalNames = ['m2', 'M2', 'm3', 'M3', 'P4', 'P5', 'M6', 'm7', 'P8'];
      const intervalSemitones = [1, 2, 3, 4, 5, 7, 9, 10, 12];
      const [current, setCurrent] = React.useState(null);
      const [feedback, setFeedback] = React.useState('');

      React.useEffect(() => {
        generateQuestion();
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);

      function generateQuestion() {
        // pick a random starting note
        const idx1 = Math.floor(Math.random() * notes.length);
        // pick a random interval from our list
        const interval = intervalSemitones[Math.floor(Math.random() * intervalSemitones.length)];
        let idx2 = idx1 + interval;
        // wrap around within the octave array
        idx2 = ((idx2 % notes.length) + notes.length) % notes.length;
        const n1 = notes[idx1];
        const n2 = notes[idx2];
        setCurrent({ n1, n2, semitone: ((idx2 - idx1 + notes.length) % notes.length) });
        setFeedback('');
        // play the two notes sequentially
        audioEngine.beep(freqMap[n1], 0.4);
        setTimeout(() => audioEngine.beep(freqMap[n2], 0.4), 600);
      }

      function handleGuess(i) {
        if (!current) return;
        const correct = current.semitone;
        const guess = intervalSemitones[i] % notes.length;
        if (guess === correct) {
          setFeedback('Correct!');
          onComplete();
        } else {
          setFeedback('Incorrect. Try again.');
        }
        // generate a new question after a short delay
        setTimeout(() => generateQuestion(), 1000);
      }

      return (
        <div className="intervals">
          <h2>Interval Training</h2>
          {current && (
            <div>
              <p>Listen to the two notes and choose the interval between them:</p>
              <div className="note-display">
                {current.n1} â†’ {current.n2}
              </div>
              <div className="choices">
                {intervalNames.map((name, i) => (
                  <button key={i} onClick={() => handleGuess(i)}>
                    {name}
                  </button>
                ))}
              </div>
            </div>
          )}
          <p style={{ minHeight: '1rem' }}>{feedback}</p>
          <button onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    /*
      Rhythm presents simple rhythmic patterns composed of quarter (â™©), eighth
      (â™ª) and half (ð…ž) notes. The pattern is played back using the
      AudioEngine and the learner must select the matching pattern from a
      list of options. A correct selection increments the rhythm
      achievement count.
    */
    function Rhythm({ onBack, audioEngine, onComplete }) {
      // Patterns are arrays of strings representing note durations. We'll
      // translate them to musical symbols for display.
      const patterns = [
        ['quarter', 'quarter', 'quarter', 'quarter'],
        ['quarter', 'eighth', 'eighth', 'quarter'],
        ['eighth', 'eighth', 'quarter', 'quarter'],
        ['quarter', 'half', 'quarter'],
      ];
      const displaySymbol = (v) => {
        return v === 'quarter' ? 'â™©' : v === 'eighth' ? 'â™ª' : 'ð…ž';
      };
      const displayPattern = (p) => p.map(displaySymbol).join(' ');
      const [current, setCurrent] = React.useState(null);
      const [feedback, setFeedback] = React.useState('');

      React.useEffect(() => {
        generate();
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);

      function generate() {
        const idx = Math.floor(Math.random() * patterns.length);
        setCurrent(patterns[idx]);
        setFeedback('');
        playPattern(patterns[idx]);
      }

      function playPattern(pat) {
        let time = 0;
        pat.forEach((v) => {
          const dur = v === 'quarter' ? 0.4 : v === 'eighth' ? 0.2 : 0.8;
          setTimeout(() => audioEngine.beep(440, dur * 0.7), time * 1000);
          time += dur;
        });
      }

      function handleSelect(i) {
        if (!current) return;
        const selected = patterns[i];
        const isEqual = selected.length === current.length && selected.every((v, idx) => v === current[idx]);
        if (isEqual) {
          setFeedback('Correct!');
          onComplete();
        } else {
          setFeedback('Incorrect. Try again.');
        }
        setTimeout(() => generate(), 1000);
      }

      return (
        <div className="rhythm">
          <h2>Rhythm Training</h2>
          <p>Listen to the pattern and select the matching one:</p>
          {current && (
            <div className="choices">
              {patterns.map((p, i) => (
                <button key={i} onClick={() => handleSelect(i)}>
                  {displayPattern(p)}
                </button>
              ))}
            </div>
          )}
          <p>{feedback}</p>
          <button onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    /*
      Flashcards presents single note names to the learner and asks them to
      type the correct letter name. After submission the next card is
      automatically presented. This component tracks correct answers via
      the onComplete callback passed from App.
    */
    function Flashcards({ onBack, onComplete }) {
      const notes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const [current, setCurrent] = React.useState(null);
      const [input, setInput] = React.useState('');
      const [feedback, setFeedback] = React.useState('');

      React.useEffect(() => {
        generate();
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);

      function generate() {
        const n = notes[Math.floor(Math.random() * notes.length)];
        setCurrent(n);
        setInput('');
        setFeedback('');
      }

      function check() {
        if (!current) return;
        if (input.trim().toUpperCase() === current) {
          setFeedback('Correct!');
          onComplete();
        } else {
          setFeedback('Incorrect.');
        }
        setTimeout(() => generate(), 1000);
      }

      return (
        <div className="flashcards">
          <h2>Flashcards</h2>
          {current && (
            <div>
              <p>Identify the note:</p>
              <div className="note-card">{current}</div>
              <input
                value={input}
                onChange={(e) => setInput(e.target.value)}
                maxLength={1}
                style={{ textTransform: 'uppercase' }}
              />
              <button onClick={check}>Submit</button>
            </div>
          )}
          <p>{feedback}</p>
          <button onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    /*
      Bieler exposes a handful of violinâ€‘specific terms for learners to
      memorize. A term is shown and the learner must enter its definition.
      Whether correct or not, the true meaning is displayed afterwards and
      the next term appears automatically. Correct answers trigger the
      onComplete callback.
    */
    function Bieler({ onBack, onComplete }) {
      const vocab = [
        { term: 'Portato', meaning: 'Smooth but separated bow strokes' },
        { term: 'Col legno', meaning: 'With the wood of the bow' },
        { term: 'Sul tasto', meaning: 'Bowing over the fingerboard' },
        { term: 'Sul ponticello', meaning: 'Bowing near the bridge' },
        { term: 'Spiccato', meaning: 'Bouncing bow' },
      ];
      const [current, setCurrent] = React.useState(null);
      const [input, setInput] = React.useState('');
      const [feedback, setFeedback] = React.useState('');

      React.useEffect(() => {
        generate();
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);

      function generate() {
        const idx = Math.floor(Math.random() * vocab.length);
        setCurrent(vocab[idx]);
        setInput('');
        setFeedback('');
      }

      function check() {
        if (!current) return;
        const normalized = input.trim().toLowerCase();
        const correct = current.meaning.trim().toLowerCase();
        if (normalized === correct) {
          setFeedback('Correct!');
          onComplete();
        } else {
          setFeedback('Definition: ' + current.meaning);
        }
        setTimeout(() => generate(), 1500);
      }

      return (
        <div className="bieler">
          <h2>Bieler Vocabulary</h2>
          {current && (
            <div>
              <p>
                Define: <strong>{current.term}</strong>
              </p>
              <input
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="Enter definition"
              />
              <button onClick={check}>Submit</button>
            </div>
          )}
          <p>{feedback}</p>
          <button onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    /*
      Settings allows the learner to toggle audio muting and select an
      instrument. Changing the mute flag updates the AudioEngine so that
      subsequent training activities obey the userâ€™s preference.
    */
      function Settings({ onBack, settings, onUpdate, audioEngine }) {
        function toggleMute() {
          const newMute = !settings.mute;
          const newSettings = { ...settings, mute: newMute };
          onUpdate(newSettings);
          audioEngine.setMute(newMute);
        }
        function changeInstrument(e) {
          onUpdate({ ...settings, instrument: e.target.value });
        }
        return (
          <div className="settings">
            <h2>Settings</h2>
            <div>
              <label>
                <input
                  type="checkbox"
                  checked={settings.mute}
                  onChange={toggleMute}
                />{' '}
                Mute audio
              </label>
            </div>
            <div style={{ marginTop: '0.5rem' }}>
              <label>
                Instrument:&nbsp;
                <select value={settings.instrument} onChange={changeInstrument}>
                  <option value="violin">Violin</option>
                  <option value="piano">Piano</option>
                </select>
              </label>
            </div>
            <button style={{ marginTop: '1rem' }} onClick={onBack}>Back to Menu</button>
          </div>
        );
      }

    // Render the application into the root div
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>