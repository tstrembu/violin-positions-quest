<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Mastery Quest ‚Äì Professional Edition 7.2.8</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--
    Provide a descriptive summary of what this page offers. This helps search engines
    understand the content and improves SEO when the file is hosted publicly (for
    example on GitHub Pages). Keep the description concise and in plain language.
  -->
  <meta name="description" content="Violin Mastery Quest is an interactive training app designed to help violinists practice notes, positions and music theory through responsive exercises and engaging challenges." />
  <meta name="color-scheme" content="light dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#f8fafc;
      --card:#fff;
      --ink:#0f172a;
      --ink-light:#475569;
      --primary:#3a5ba0;
      --primary-dark:#2f4b7e;
      --primary-light:#5a7bc0;
      --success:#009e73;
      --warning:#e69f00;
      --danger:#d55e00;
      --neutral:#6c757d;
      --accent:#8b5cf6;
      --accent-light:#a78bfa;
      --border:rgba(0,0,0,0.1);
      --shadow:rgba(0,0,0,0.08);
      --gradient-1:#667eea;
      --gradient-2:#764ba2;
    }
    :root.dark {
      --bg:#0b1426;
      --card:#0f1f3d;
      --ink:#e2e8f0;
      --ink-light:#94a3b8;
      --primary:#4a78b6;
      --primary-dark:#355a8a;
      --primary-light:#6a98d6;
      --success:#00b58a;
      --warning:#f3ae3d;
      --danger:#d5672f;
      --neutral:#6b7280;
      --accent:#9f7aea;
      --accent-light:#b794f4;
      --border:rgba(255,255,255,0.15);
      --shadow:rgba(0,0,0,0.3);
    }
    
    * { box-sizing: border-box; }
    
    body {
      margin:0;
      font-family: 'Inter', sans-serif;
      background:var(--bg);
      color:var(--ink);
      padding-bottom:80px;
      line-height:1.6;
    }
    
    .container {
      max-width: 1000px;
      margin:auto;
      padding:1rem;
    }
    
    .card {
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:1.5rem 1.75rem;
      margin-bottom:1.5rem;
      box-shadow:0 4px 24px var(--shadow);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow:0 8px 32px var(--shadow);
    }
    
    .card-compact {
      padding:1rem 1.25rem;
    }
    
    h1, h2, h3 {
      margin-top:0;
      line-height:1.2;
    }
    
    h1 {
      font-size:2rem;
      font-weight:800;
      background:linear-gradient(135deg, var(--gradient-1), var(--gradient-2));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      margin-bottom:0.5rem;
    }
    
    h2 {
      font-size:1.5rem;
      font-weight:700;
      color:var(--ink);
    }
    
    h3 {
      font-size:1.15rem;
      font-weight:600;
      color:var(--ink);
    }
    
    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:0.5rem;
      padding:0.75rem 1.5rem;
      border-radius:12px;
      margin:0.25rem;
      border:none;
      font-weight:600;
      cursor:pointer;
      color:#fff;
      font-size:0.95rem;
      transition: all 0.2s ease;
      position:relative;
      overflow:hidden;
    }
    
    .btn::before {
      content:'';
      position:absolute;
      top:50%;
      left:50%;
      width:0;
      height:0;
      border-radius:50%;
      background:rgba(255,255,255,0.3);
      transform:translate(-50%,-50%);
      transition: width 0.6s ease, height 0.6s ease;
    }
    
    .btn:active::before {
      width:300px;
      height:300px;
    }
    
    .btn-primary { background:var(--primary); }
    .btn-primary:hover { background:var(--primary-dark); transform:translateY(-2px); box-shadow:0 4px 12px var(--shadow); }
    .btn-primary:active { transform:translateY(0); }
    
    .btn-secondary { background:var(--ink-light); }
    .btn-secondary:hover { background:var(--ink); transform:translateY(-2px); }
    
    .btn-success { background:var(--success); }
    .btn-success:hover { filter:brightness(1.1); transform:translateY(-2px); }
    
    .btn-warning { background:var(--warning); }
    .btn-danger { background:var(--danger); }
    .btn-accent { background:var(--accent); }
    .btn-accent:hover { background:var(--accent-light); transform:translateY(-2px); }
    
    .btn-large {
      padding:1rem 2rem;
      font-size:1.1rem;
      border-radius:16px;
    }
    
    .btn:disabled {
      opacity:0.5;
      cursor:not-allowed;
      transform:none !important;
    }
    
    .btn {
      touch-action: manipulation; /* ELIMINATES 300MS TAP DELAY ON MOBILE */
    }
    
    .grid {
      display:grid;
      gap:1rem;
    }
    
    .grid-cols-2 { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .grid-cols-3 { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
    
    .option-btn {
      width:100%;
      padding:0.875rem 1rem;
      border-radius:12px;
      margin:0.35rem 0;
      color:#fff;
      border:2px solid transparent;
      cursor:pointer;
      font-weight:600;
      font-size:1rem;
      transition: all 0.2s ease;
      position:relative;
      text-align:left;
    }
    
    /* Compact chip layout just for the Positions Charts selector */
    .position-nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    /* Override the global .option-btn width ONLY inside the position selector */
    .position-nav .option-btn {
      width: auto;
      min-width: 3.1rem;       /* fits ‚Äú10th‚Äù comfortably */
      padding: 0.45rem 0.9rem; /* slightly more compact */
      margin: 0;
      font-size: 0.9rem;
      text-align: center;
    }

    /* Optional: tiny tweak for very small phones */
    @media (max-width: 480px) {
      .position-nav {
        max-width: 360px;
        margin-inline: auto;
      }
    }
    
    .option-btn:hover:not(:disabled) {
      transform:translateX(4px);
      border-color:rgba(255,255,255,0.3);
    }
    
    .option-btn:disabled {
      cursor:not-allowed;
      opacity:0.7;
    }
    
    .option-btn.correct {
      background:var(--success) !important;
      animation: correctPulse 0.5s ease;
    }
    
    .option-btn.incorrect {
      background:var(--danger) !important;
      animation: shake 0.4s ease;
    }
    
    @keyframes correctPulse {
      0%, 100% { transform:scale(1); }
      50% { transform:scale(1.03); }
    }
    
    @keyframes shake {
      0%, 100% { transform:translateX(0); }
      25% { transform:translateX(-8px); }
      75% { transform:translateX(8px); }
    }
    
    @keyframes slideIn {
      from { opacity:0; transform:translateY(20px); }
      to { opacity:1; transform:translateY(0); }
    }
    
    @keyframes celebrate {
      0%, 100% { transform:scale(1) rotate(0deg); }
      25% { transform:scale(1.1) rotate(-5deg); }
      75% { transform:scale(1.1) rotate(5deg); }
    }
    
    .stat-card {
      background:linear-gradient(135deg, var(--primary), var(--primary-dark));
      color:#fff;
      padding:1.25rem;
      border-radius:12px;
      text-align:center;
      box-shadow:0 4px 16px var(--shadow);
    }
    
    .stat-value {
      font-size:2.5rem;
      font-weight:800;
      line-height:1;
      margin:0.5rem 0;
    }
    
    .stat-label {
      font-size:0.9rem;
      opacity:0.9;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    
    .progress-bar {
      height:12px;
      background:var(--border);
      border-radius:9999px;
      overflow:hidden;
      position:relative;
    }
    
    .progress-fill {
      height:100%;
      background:linear-gradient(90deg, var(--gradient-1), var(--gradient-2));
      border-radius:9999px;
      transition: width 0.5s ease;
      position:relative;
    }
    
    .progress-fill::after {
      content:'';
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 2s infinite;
    }
    
    @keyframes shimmer {
      0% { transform:translateX(-100%); }
      100% { transform:translateX(100%); }
    }
    
    .badge {
      display:inline-flex;
      align-items:center;
      gap:0.35rem;
      padding:0.35rem 0.75rem;
      background:var(--accent);
      color:#fff;
      border-radius:9999px;
      font-size:0.85rem;
      font-weight:600;
      margin:0.25rem;
    }
    
    .badge-large {
      padding:0.75rem 1.25rem;
      font-size:1.1rem;
      animation: celebrate 1s ease;
    }
    
    .streak-fire {
      font-size:1.5rem;
      animation: flicker 1.5s infinite alternate;
    }
    
    @keyframes flicker {
      0%, 100% { opacity:1; transform:scale(1); }
      50% { opacity:0.8; transform:scale(1.1); }
    }
    
    .heat-cell {
      height:2.5rem;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:0.8rem;
      font-weight:600;
      color:#fff;
      border-radius:6px;
      transition: transform 0.2s ease;
      cursor:help;
    }
    
    .heat-cell:hover {
      transform:scale(1.05);
      box-shadow:0 2px 8px var(--shadow);
    }
    
    .toast {
      position:fixed;
      top:20px;
      right:20px;
      background:var(--card);
      border:2px solid var(--border);
      border-radius:12px;
      padding:1rem 1.5rem;
      box-shadow:0 8px 24px var(--shadow);
      animation: slideIn 0.3s ease;
      z-index:1000;
      max-width:320px;
    }
    
    .toast-success { border-color:var(--success); }
    .toast-warning { border-color:var(--warning); }
    
    .pulse-ring {
      position:absolute;
      border:3px solid var(--success);
      border-radius:50%;
      animation: pulse-ring 1.5s ease-out infinite;
    }
    
    @keyframes pulse-ring {
      0% { transform:scale(0.8); opacity:1; }
      100% { transform:scale(1.4); opacity:0; }
    }
    
    .metronome-beat {
      width:60px;
      height:60px;
      border-radius:50%;
      background:var(--primary);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.5rem;
      color:#fff;
      font-weight:700;
      position:relative;
    }
    
    .metronome-beat.active {
      background:var(--success);
      animation: beatPulse 0.3s ease;
    }
    
    @keyframes beatPulse {
      0%, 100% { transform:scale(1); }
      50% { transform:scale(1.2); }
    }
    
    .tutorial-highlight {
      position:relative;
      z-index:10;
      box-shadow:0 0 0 4px var(--accent), 0 0 0 8px rgba(139, 92, 246, 0.3);
      border-radius:12px;
    }
    
    .sr-only {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
    
    .btn:focus-visible,
    .option-btn:focus-visible {
      outline:3px solid var(--accent);
      outline-offset:3px;
    }
    
    .achievement-popup {
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%, -50%) scale(0);
      background:var(--card);
      border-radius:20px;
      padding:2rem;
      box-shadow:0 20px 60px rgba(0,0,0,0.3);
      z-index:2000;
      text-align:center;
      animation: achievementPop 0.6s ease forwards;
    }
    
    @keyframes achievementPop {
      0% { transform:translate(-50%, -50%) scale(0) rotate(-180deg); opacity:0; }
      60% { transform:translate(-50%, -50%) scale(1.1) rotate(10deg); opacity:1; }
      100% { transform:translate(-50%, -50%) scale(1) rotate(0deg); opacity:1; }
    }
    
    .confetti {
      position:fixed;
      width:10px;
      height:10px;
      background:var(--accent);
      position:fixed;
      animation: confettiFall 3s ease-out forwards;
    }
    
    @keyframes confettiFall {
      to {
        transform:translateY(100vh) rotate(360deg);
        opacity:0;
      }
    }
    
    @media (max-width:640px) {
      .container { padding:0.75rem; }
      .card { padding:1rem 1.25rem; border-radius:12px; }
      h1 { font-size:1.5rem; }
      h2 { font-size:1.25rem; }
      .btn { padding:0.65rem 1rem; font-size:0.9rem; }
      .stat-value { font-size:2rem; }
    }
    
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.001ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.001ms !important;
      }
    }
  </style>
  <script>
    (function () {
      const KEY = 'vmq.theme';
      const saved = localStorage.getItem(KEY);
  
      // Screen reader status helper
      window.speakSR = (txt) => {
        const el = document.getElementById('sr');
        if (el) el.textContent = txt;
      };
  
      const prefers =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches;
  
      const dark = saved ? saved === 'dark' : prefers;
      document.documentElement.classList.toggle('dark', dark);
  
      window.__setTheme = (d) => {
        localStorage.setItem(KEY, d ? 'dark' : 'light');
        document.documentElement.classList.toggle('dark', d);
      };
    })();
  </script>
  <!--
    Load React and ReactDOM from a CDN. Using the `defer` attribute ensures that
    these external scripts do not block HTML parsing. The `crossorigin`
    attribute is added so that if subresource integrity attributes are added
    later, the requests will be CORS-enabled. Order is preserved: React
    must load before ReactDOM and Babel so that the Babel-compiled JSX can
    resolve React properly.
  -->
  <!-- React + ReactDOM + Babel (synchronous, in this order) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
  <!--
    The application is built entirely in React and requires JavaScript to function.
    If JavaScript is disabled in the user's browser, display a friendly message
    encouraging them to enable it. This content will only appear when scripts
    are blocked.
    -->
<body>
  <!-- Loading Screen -->
  <div id="app-loader">
    <div class="loader-content">
      <div class="loader-spinner"></div>
      <h1 class="loader-title">Violin Mastery Quest</h1>
      <p class="loader-status" id="loader-status">Loading application...</p>
    </div>
  </div>

  <div id="root"></div>
  
  <noscript>
    <p style="padding:1rem;color:#b91c1c;">This application requires JavaScript to run properly. Please enable JavaScript in your browser settings.</p>
  </noscript>
  
  <div id="sr" class="sr-only" aria-live="polite" aria-atomic="true"></div>

<script type="text/babel" data-presets="react">
(function() {
  'use strict';
  
  // Wait for all dependencies to load
  function checkDependencies() {
    const status = document.getElementById('loader-status');
    
    if (typeof React === 'undefined') {
      if (status) status.textContent = 'Loading React...';
      return false;
    }
    if (typeof ReactDOM === 'undefined') {
      if (status) status.textContent = 'Loading ReactDOM...';
      return false;
    }
    if (typeof Babel === 'undefined') {
      if (status) status.textContent = 'Loading Babel...';
      return false;
    }
    
    return true;
  }
  
  function initializeApp() {
    if (!checkDependencies()) {
      setTimeout(initializeApp, 100);
      return;
    }
    
    const status = document.getElementById('loader-status');
    if (status) status.textContent = 'Compiling application...';
    
    // Give Babel MORE time to finish transforming (increase from 300 to 1500ms)
    setTimeout(startApp, 2000);
  }
  
  function startApp() {
    const status = document.getElementById('loader-status');
    if (status) status.textContent = 'Starting application...';
    
    // Add a check to see if App is defined
    let attempts = 0;
    const maxAttempts = 20;
    
    function tryRender() {
      attempts++;
      
      if (typeof App === 'undefined') {
        if (attempts < maxAttempts) {
          if (status) status.textContent = `Compiling... (${attempts}/${maxAttempts})`;
          setTimeout(tryRender, 200);
          return;
        } else {
          console.error('App component not defined after compilation timeout');
          const loader = document.getElementById('app-loader');
          if (loader) {
            loader.innerHTML = 
              '<div style="color:white;padding:2rem;text-align:center;">' +
              '<h2>Compilation Error</h2>' +
              '<p>The application took too long to compile. This can happen with slow connections or browsers.</p>' +
              '<button onclick="location.reload()" style="margin-top:1rem;padding:0.75rem 1.5rem;background:white;color:#764ba2;border:none;border-radius:8px;font-weight:600;cursor:pointer;">Refresh Page</button>' +
              '</div>';
          }
          return;
        }
      }
      
      // App is defined, proceed with render
      doRender();
    }
    
    function doRender() {
      try {
 
    // ============================================================================
    // CONSTANTS & DATA STRUCTURES
    // ============================================================================
    
    const STRINGS = ['G','D','A','E'];
    const POSITIONS = [1,2,3,4,5,6,7,8,9,10];
    const FINGERS = [1,2,3,4];
    const VISUAL_STRING_ORDER = ['E', 'A', 'D', 'G']; // display order: what the player sees, top ‚Üí bottom
    const OPEN_PC = {G:7, D:2, A:9, E:4};
    const BASE_OFF = {1:2, 2:4, 3:5, 4:7};
    const POS_SHIFT = {1:0, 2:2, 3:3, 4:5, 5:7, 6:9, 7:10, 8:12, 9:14, 10:16};
    const NOTE_NAME = {0:'C',1:'Db',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};
    const NOTE_TO_PC = Object.fromEntries(Object.entries(NOTE_NAME).map(([k,v])=>[v,Number(k)]));
    const MIDI_BASE = {G:55, D:62, A:69, E:76};
    
    // Interval definitions with semitones
    const INTERVALS = {
      'Minor 2nd': 1,
      'Major 2nd': 2,
      'Minor 3rd': 3,
      'Major 3rd': 4,
      'Perfect 4th': 5,
      'Tritone': 6,
      'Perfect 5th': 7,
      'Minor 6th': 8,
      'Major 6th': 9,
      'Minor 7th': 10,
      'Major 7th': 11,
      'Octave': 12
    };
    
    // Rhythm patterns (in terms of beat subdivisions)
    const RHYTHM_PATTERNS = {
      'Quarter Notes': [1,1,1,1],
      'Eighth Notes': [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5],
      'Quarter-Eighth': [1,0.5,0.5,1,1],
      'Dotted Quarter-Eighth': [1.5,0.5,1,1],
      'Syncopation': [0.5,1,0.5,1,1],
      'Triplets': [0.66,0.66,0.66,1,1]
    };
    
    // Achievement definitions
    const ACHIEVEMENTS = [
      { id:'first_note', name:'First Steps', desc:'Play your first note', icon:'üéµ', xp:0 },
      { id:'speed_10', name:'Quick Learner', desc:'Answer 10 speed drill questions', icon:'‚ö°', xp:10 },
      { id:'speed_50', name:'Speed Demon', desc:'Answer 50 speed drill questions', icon:'üî•', xp:50 },
      { id:'perfect_5', name:'Perfectionist', desc:'Get 5 correct answers in a row', icon:'‚ú®', xp:15 },
      { id:'perfect_10', name:'Flawless', desc:'Get 10 correct answers in a row', icon:'üíé', xp:25 },
      { id:'streak_3', name:'Committed', desc:'Maintain a 3-day streak', icon:'üìÖ', xp:3 },
      { id:'streak_7', name:'Dedicated', desc:'Maintain a 7-day streak', icon:'üåü', xp:7 },
      { id:'streak_30', name:'Legend', desc:'Maintain a 30-day streak', icon:'üèÜ', xp:30 },
      { id:'level_5', name:'Apprentice', desc:'Reach Level 5', icon:'üéì', xp:5 },
      { id:'level_10', name:'Expert', desc:'Reach Level 10', icon:'üéØ', xp:10 },
      { id:'interval_master', name:'Interval Master', desc:'Master all interval recognition', icon:'üé∂', xp:20 },
      { id:'rhythm_master', name:'Rhythm Master', desc:'Master all rhythm patterns', icon:'ü•Å', xp:20 },
      { id:'all_positions', name:'Position Expert', desc:'Practice all 10 positions', icon:'üéª', xp:15 },
      { id:'bieler_scholar', name:'Bieler Scholar', desc:'Complete Technique Lab', icon:'üìö', xp:25 },
      { id:'reflection_10', name:'Thoughtful Practitioner', desc:'Write 10 reflection entries', icon:'üìù', xp:15 }
    ];
    
    // Encouraging messages
    const PRAISE_MESSAGES = [
      "Outstanding! üåü", "Perfect! ‚ú®", "Excellent work! üéµ", "Brilliant! üíé",
      "You're on fire! üî•", "Magnificent! üéª", "Superb! ‚≠ê", "Incredible! üé∂",
      "Amazing job! üèÜ", "You're a natural! üéØ", "Flawless! üí´", "Phenomenal! üåà"
    ];
    
    const ENCOURAGEMENT_MESSAGES = [
      "Keep trying! üí™", "Almost there! üéµ", "You're learning! üìö", "Good effort! ‚≠ê",
      "Practice makes perfect! üéª", "You'll get it! üåü", "Keep going! üéØ", "Nice try! üí´"
    ];
    
    // ============================================================================
    // STORAGE KEYS
    // ============================================================================
    
    const XP_KEY = 'vmq.v7.xp';
    const STATS_KEY = 'vmq.v7.stats';
    const PREFS_KEY = 'vmq.v7.prefs';
    const FLASH_KEY = 'vmq.v7.flashcards';
    const FLASH_SIG_KEY = 'vmq.v7.flashcards.sig';
    const ACHIEVEMENTS_KEY = 'vmq.v7.achievements';
    const STREAK_KEY = 'vmq.v7.streak';
    const LAST_VISIT_KEY = 'vmq.v7.lastVisit';
    const TUTORIAL_KEY = 'vmq.v7.tutorialComplete';
    const REFLECTIONS_KEY = 'vmq.v7.reflections';

    const INTERVAL_STATS_KEY = 'vmq.v7.intervalStats';
    const RHYTHM_STATS_KEY = 'vmq.v7.rhythmStats';
    const BIELER_STATS_KEY = 'vmq.v7.bielerStats';  
    
    const BKT_KEY = 'vmq.v7.bkt';
    
    // Daily Quest storage
    const QUEST_KEY = 'vmq.v7.dailyQuest';
    const QUEST_DATE_KEY = 'vmq.v7.dailyQuestDate';

    const BKT_DEFAULT_PARAMS = {
      pInit: 0.25,   // initial belief student knows a new cell
      pSlip: 0.10,   // chance of error despite knowing
      pGuess: 0.20,  // chance of correct despite not knowing
      pLearn: 0.08   // learning per exposure
    };
    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    
    const loadJSON = (k, fb) => {
      try {
        const raw = localStorage.getItem(k);
        if (raw == null) return fb;
    
        const v = JSON.parse(raw);
        // Preserve the ‚Äúnull/undefined ‚Üí fallback‚Äù semantics of ??
        return v == null ? fb : v;
      } catch {
        return fb;
      }
    };
    
    const saveJSON = (k,v) => {
      try {
        localStorage.setItem(k, JSON.stringify(v));
      } catch {}
    };
    
    // ----- BKT core helpers -----

    // Key for any (string, position, finger) triple
    const cellKey = (s, p, f) => `${s}:${p}:${f}`;
    
    // Load full BKT map: { [key]: { pKnow, seen, last, params? } }
    const loadBKT = () => loadJSON(BKT_KEY, {});
    
    // Save BKT
    const saveBKT = (state) => saveJSON(BKT_KEY, state);
    
    // Get current BKT state for a cell, with sensible defaults
    const getBKTForCell = (bktState, s, p, f) => {
      const key = cellKey(s, p, f);
      const existing = bktState[key];
      if (existing) return existing;
      return {
        pKnow: BKT_DEFAULT_PARAMS.pInit,
        seen: 0,
        last: null
      };
    };
    
    // One BKT update step given previous P(K) and an observed correctness
    const updateBKTProbability = (pKnowPrev, correct, params = BKT_DEFAULT_PARAMS) => {
      const { pSlip, pGuess, pLearn } = params;
    
      // P(L_t | observation)
      let num, den, pGivenObs;
    
      if (correct) {
        num = pKnowPrev * (1 - pSlip);
        den = num + (1 - pKnowPrev) * pGuess;
      } else {
        num = pKnowPrev * pSlip;
        den = num + (1 - pKnowPrev) * (1 - pGuess);
      }
    
      // Guard against weird edge cases
      pGivenObs = den > 0 ? num / den : pKnowPrev;
    
      // Apply learning transition to get P(L_{t+1})
      const pNext = pGivenObs + (1 - pGivenObs) * pLearn;
    
      // Clamp to [0,1]
      return Math.min(0.999, Math.max(0.001, pNext));
    };
    
    // Update the BKT store for a single cell after a response
    const recordBKTObservation = (s, p, f, correct) => {
      const bkt = loadBKT();
      const key = cellKey(s, p, f);
      const prev = getBKTForCell(bkt, s, p, f);
    
      const pNext = updateBKTProbability(prev.pKnow, correct);
      bkt[key] = {
        ...prev,
        pKnow: pNext,
        seen: (prev.seen || 0) + 1,
        last: Date.now(),
      };
    
      saveBKT(bkt);
      return bkt;
    };
    
    // Weight for item selection: low-mastery cells are picked more often
    const bktPracticeWeight = (bktState, s, p, f) => {
      const { pKnow, seen } = getBKTForCell(bktState, s, p, f);
    
      // Base weight: inverse of mastery
      let w = 1 - pKnow;
    
      // Light boost if the cell has never or rarely been seen
      if (!seen || seen < 3) {
        w += 0.25;
      }
    
      // Keep everything above a small floor to avoid "dead" items
      return Math.max(0.05, w);
    };
  
    const shuffle = (a) => {
      const arr = [...a];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    };
    
    const getRandom = a => a[Math.floor(Math.random()*a.length)];
    
    // ---------------------------------------------------------------------------
    // Shared ordinal helpers (single source of truth)
    // ---------------------------------------------------------------------------
    
    const ordinal = n => {
      if (n == null) return '';
      const s = String(n);
      const last = s[s.length - 1];
      const last2 = s.length > 1 ? s.slice(-2) : s;
    
      if (last2 === '11' || last2 === '12' || last2 === '13') return `${s}th`;
      if (last === '1') return `${s}st`;
      if (last === '2') return `${s}nd`;
      if (last === '3') return `${s}rd`;
      return `${s}th`;
    };
    
    // Short variant ‚Äì currently identical, but easy to style differently later
    const ordinalShort = n => ordinal(n);
    
    // Position label ‚Äì kept separate for possible "half position" etc. later
    const positionLabelShort = n => ordinalShort(n);
    
    const canonicalBase = (s,p,f) => {
      const semi = OPEN_PC[s] + POS_SHIFT[p] + BASE_OFF[f];
      return NOTE_NAME[((semi%12)+12)%12];
    };
    
    const levelForXP = (xp) => Math.floor(Math.pow(xp/300, 0.75)) + 1;
    const nextLevelXP = (lvl) => Math.round(300 * Math.pow(lvl, 1.4));
    
    const addXP = (amt) => {
      const xp = loadJSON(XP_KEY, 0) + amt;
      saveJSON(XP_KEY, xp);
      return xp;
    };
    
    const updateStat = (key, ok) => {
      const stats = loadJSON(STATS_KEY, {});
      const st = stats[key] || {correct:0, total:0, lastPracticed: Date.now()};
      st.total += 1;
      if(ok) st.correct += 1;
      st.lastPracticed = Date.now();
      stats[key] = st;
      saveJSON(STATS_KEY, stats);
    };
    
    const checkAchievement = (achievementId) => {
      const unlocked = loadJSON(ACHIEVEMENTS_KEY, []);
      if(!unlocked.includes(achievementId)) {
        unlocked.push(achievementId);
        saveJSON(ACHIEVEMENTS_KEY, unlocked);
        return true;
      }
      return false;
    };
    
    const updateStreak = () => {
      const streak = loadJSON(STREAK_KEY, {current:0, longest:0, lastDate:null});
      const lastVisit = loadJSON(LAST_VISIT_KEY, null);
      const today = new Date().toDateString();
      
      if(lastVisit === today) {
        return streak;
      }
      
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = yesterday.toDateString();
      
      if(lastVisit === yesterdayStr) {
        streak.current += 1;
      } else if(lastVisit !== null) {
        streak.current = 1;
      } else {
        streak.current = 1;
      }
      
      streak.longest = Math.max(streak.longest, streak.current);
      streak.lastDate = today;
      
      saveJSON(STREAK_KEY, streak);
      saveJSON(LAST_VISIT_KEY, today);
      
      // Check streak achievements
      if(streak.current >= 3) checkAchievement('streak_3');
      if(streak.current >= 7) checkAchievement('streak_7');
      if(streak.current >= 30) checkAchievement('streak_30');
      
      return streak;
    };
    
    const CELLS = [];
    for(const s of STRINGS) {
      for(const p of POSITIONS) {
        for(const f of FINGERS) {
          CELLS.push({s, p, f, canon: canonicalBase(s,p,f)});
        }
      }
    }
    
    // --------------------------------------------------------------------------
    // Preferences, selection + position-unlock logic
    // --------------------------------------------------------------------------

    // Core vs advanced positions for gating
    const CORE_POSITIONS = [1, 2, 3, 4, 5];
    const ADVANCED_POSITIONS = POSITIONS.filter((p) => !CORE_POSITIONS.includes(p));

    // Positions that are ON by default in a fresh profile.
    const DEFAULT_UNLOCKED_POSITIONS = CORE_POSITIONS;

    // Baseline mastery (across positions 1‚Äì5) required to unlock 6‚Äì10.
    const POSITION_UNLOCK_THRESHOLD = 0.75;

    const defaultPrefs = {
      strings: Object.fromEntries(STRINGS.map((s) => [s, true])),
      // Only core positions (1‚Äì5) are on by default; 6‚Äì10 start off
      positions: Object.fromEntries(
        POSITIONS.map((p) => [p, DEFAULT_UNLOCKED_POSITIONS.includes(p)])
      ),
      flashLevel: 'Professional',
      difficulty: 'medium',
      soundEnabled: true,
      hapticEnabled: true,
      tutorialComplete: false,
    };

    /**
     * Filter global CELLS by prefs so only allowed string/position combos are practiced.
     */
    const filterActiveCells = (prefs) =>
      CELLS.filter((c) => prefs.strings[c.s] && prefs.positions[c.p]);

    // Backwards-compatible alias: older code still using `filteredCells`
    const filteredCells = filterActiveCells;

    /**
     * Average BKT mastery across core positions (1‚Äì5).
     * Accepts an optional positionHeat matrix to avoid recomputing if already built.
     * Returns a 0‚Äì1 value.
     */
    function corePositionsMastery(positionHeat) {
      const heat = positionHeat || buildPositionHeat(); // { position: { string: mastery } }
      let sum = 0;
      let count = 0;
    
      for (const p of CORE_POSITIONS) {
        const row = heat[p];
        if (!row) continue;
        for (const s of STRINGS) {
          const v = row[s];
          sum += typeof v === 'number' ? v : 0;
          count += 1;
        }
      }
    
      return count ? sum / count : 0;
    }

    /**
     * Normalize preferences:
     *  - Merge with defaultPrefs (so every key exists).
     *  - Enforce hard gating rules for advanced positions (6‚Äì10).
     *
     * This function is the single source of truth for what positions may
     * *legally* be practiced right now.
     */
    const normalizePrefs = (rawPrefs) => {
      const base = { ...defaultPrefs, ...(rawPrefs || {}) };

      const current = { ...base.positions };
      const mastery = corePositionsMastery();
      const advancedUnlocked = mastery >= POSITION_UNLOCK_THRESHOLD;

      // Core positions (1‚Äì5) are always allowed; if the prefs object somehow
      // omitted them, default to true.
      for (const p of CORE_POSITIONS) {
        if (typeof current[p] !== 'boolean') {
          current[p] = true;
        }
      }

      // Advanced positions: cannot be ON unless they are unlocked.
      for (const p of ADVANCED_POSITIONS) {
        if (!advancedUnlocked) {
          // Not unlocked yet ‚Üí force hard OFF.
          current[p] = false;
        } else if (typeof current[p] !== 'boolean') {
          // Unlocked but missing ‚Üí default ON.
          current[p] = true;
        }
      }

      return { ...base, positions: current };
    };
    
    // --------------------------------------------------------------------------
    // Mastery helpers for the current selection (based on BKT)
    // --------------------------------------------------------------------------
    
    // Average P(know) across all currently-enabled cells
    const avgMasteryForSelection = (prefs) => {
      const cells = filteredCells(prefs);
      if (!cells.length) return 0;
      const bkt = loadBKT();
      const total = cells.reduce((sum, c) =>
        sum + getBKTForCell(bkt, c.s, c.p, c.f).pKnow, 0);
      return total / cells.length;
    };
    
    // Convert an average mastery score into a human-friendly difficulty tier
    const difficultyTierFromMastery = (m) => {
      if (m < 0.5) return 'easy';     // student is still stabilizing basics
      if (m < 0.85) return 'medium';  // solid but still room to grow
      return 'hard';                  // ready for challenge / transfer tasks
    };
    
    // Build a per-position, per-string mastery grid (average P(know))
    // Used for heatmaps / progress visualizations.
    const buildPositionHeat = () => {
      const bkt = loadBKT();
      const result = {}; // { position: { string: {sum,count} } }
    
      for (const { s, p, f } of CELLS) {
        const state = getBKTForCell(bkt, s, p, f);
        if (!result[p]) result[p] = {};
        if (!result[p][s]) result[p][s] = { sum: 0, count: 0 };
        result[p][s].sum   += state.pKnow;
        result[p][s].count += 1;
      }
    
      const out = {};
      for (const p of POSITIONS) {
        out[p] = {};
        const row = result[p] || {};
        for (const s of STRINGS) {
          const cell = row[s];
          out[p][s] = cell ? cell.sum / cell.count : 0;
        }
      }
      return out;
    };

    // ============================================================================
    // AUDIO ENGINE (Enhanced, with feedback + celebration)
    // ============================================================================
    
    class AudioEngine {
      constructor() {
        this.ctx = null;
        this.mute = loadJSON('vmq.v7.mute', false);
      }
    
      ensure() {
        if (!this.ctx) {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
        return this.ctx;
      }
    
      // Simple pitched note (used all over the app)
      playNote({ midi, durationMs = 800, waveform = 'sine' }) {
        if (this.mute) return;
        const ctx = this.ensure();
        const now = ctx.currentTime + 0.01;
    
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
    
        osc.type = waveform;
        osc.frequency.value = 440 * Math.pow(2, (midi - 69) / 12);
    
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.9, now + 0.02);
        gain.gain.setTargetAtTime(0, now + durationMs / 1000, 0.1);
    
        osc.connect(gain);
        gain.connect(ctx.destination);
    
        osc.start(now);
        osc.stop(now + durationMs / 1000 + 0.2);
      }
    
      // Interval playback for the Interval Trainer
      playInterval({ rootMidi, semitones, gapMs = 150, durationMs = 600, simultaneous = false }) {
        if (this.mute) return;
        const ctx = this.ensure();
        const t0 = ctx.currentTime + 0.01;
    
        const note = (midi, t) => {
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = 440 * Math.pow(2, (midi - 69) / 12);
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(0.8, t + 0.01);
          g.gain.setTargetAtTime(0, t + durationMs / 1000, 0.15);
          osc.connect(g);
          g.connect(ctx.destination);
          osc.start(t);
          osc.stop(t + durationMs / 1000 + 0.2);
        };
    
        if (simultaneous) {
          note(rootMidi, t0);
          note(rootMidi + semitones, t0);
        } else {
          note(rootMidi, t0);
          note(rootMidi + semitones, t0 + gapMs / 1000);
        }
      }
    
      // Short ‚Äúcorrect / incorrect‚Äù blip, used by drills
      playFeedback(ok) {
        if (this.mute) return;
        const ctx = this.ensure();
        const now = ctx.currentTime + 0.01;
    
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
    
        // Higher pitch for correct, lower for incorrect
        const midi = ok ? 84 : 60; // A5 vs C4
        osc.type = 'sine';
        osc.frequency.value = 440 * Math.pow(2, (midi - 69) / 12);
    
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(ok ? 0.7 : 0.5, now + 0.02);
        gain.gain.setTargetAtTime(0, now + 0.25, 0.1);
    
        osc.connect(gain);
        gain.connect(ctx.destination);
    
        osc.start(now);
        osc.stop(now + 0.4);
      }
    
      // Little celebratory arpeggio for achievements
      playCelebration() {
        if (this.mute) return;
        const ctx = this.ensure();
        const now = ctx.currentTime + 0.01;
    
        // Simple major triad up the octave
        const freqs = [440, 554.37, 659.25, 880]; // A4‚ÄìC#5‚ÄìE5‚ÄìA5
    
        freqs.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          const t = now + i * 0.12;
    
          osc.frequency.value = freq;
    
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.6, t + 0.03);
          gain.gain.setTargetAtTime(0, t + 0.35, 0.12);
    
          osc.connect(gain);
          gain.connect(ctx.destination);
    
          osc.start(t);
          osc.stop(t + 0.7);
        });
      }
    }
    
    const audioEngine = new AudioEngine();
    
    // Unlock audio on first user interaction
    window.addEventListener(
      'pointerdown',
      () => {
        try {
          audioEngine.ensure();
        } catch {
          // ignore
        }
      },
      { once: true }
    );
    
    // ============================================================================
    // SPEECH SYNTHESIS (Enhanced)
    // ============================================================================
    
    function speak(text, { rate = 0.9, pitch = 1, lang, voiceName } = {}) {
      try {
        if (!text) return;
        const synth = window.speechSynthesis;
        const Utterance = window.SpeechSynthesisUtterance;
        if (!synth || !Utterance) return;
        
        let voices = [];
        try {
          if (typeof synth.getVoices === 'function') {
            voices = synth.getVoices() || [];
          }
          if (typeof synth.onvoiceschanged === 'undefined') {
            // Touch voices to trigger lazy loading on some browsers
            void voices.length;
          }
        } catch {}
        
        const u = new Utterance(String(text));
        u.rate = rate;
        u.pitch = pitch;
        
        if (lang) u.lang = lang;
        if (voiceName && Array.isArray(voices)) {
          const v = voices.find(v => v.name === voiceName);
          if (v) u.voice = v;
        }
        
        try { synth.cancel(); } catch {}
        synth.speak(u);
      } catch {}
    }
    
    // ============================================================================
    // HAPTIC FEEDBACK
    // ============================================================================
    
    const vibrate = (pattern = [50]) => {
      try {
        if(navigator.vibrate && loadJSON(PREFS_KEY, defaultPrefs).hapticEnabled) {
          navigator.vibrate(pattern);
        }
      } catch {}
    };
    
    // ============================================================================
    // REACT HOOKS
    // ============================================================================
    
    function useAnswerHotkeys(enabled, onIndex, onBack, count = 4) {
      const cursorRef = React.useRef(-1);
      
      React.useEffect(() => {
        if (!enabled) return;
        const handler = (e) => {
          const t = e.target;
          const tag = (t && t.tagName || '').toLowerCase();
          if (tag === 'input' || tag === 'select' || tag === 'textarea' || (t && t.isContentEditable)) return;
          
          const k = e.key;
          const max = (typeof count === 'number' ? count : 4) - 1;
          let handled = false;
          
          if (k >= '1' && k <= '9') {
            const idx = Number(k) - 1;
            if (idx <= max) {
              cursorRef.current = idx;
              onIndex(idx);
              handled = true;
            }
          } else if (k === 'Enter') {
            cursorRef.current = 0;
            onIndex(0);
            handled = true;
          } else if (k === 'Escape') {
            onBack();
            handled = true;
          } else if (k === 'ArrowRight' || k === 'ArrowDown') {
            const next = Math.min((cursorRef.current < 0 ? 0 : cursorRef.current) + 1, max);
            cursorRef.current = next;
            onIndex(next);
            handled = true;
          } else if (k === 'ArrowLeft' || k === 'ArrowUp') {
            const prev = Math.max((cursorRef.current < 0 ? 0 : cursorRef.current) - 1, 0);
            cursorRef.current = prev;
            onIndex(prev);
            handled = true;
          }
          
          if (handled) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
        window.addEventListener('keydown', handler);
        return () => window.removeEventListener('keydown', handler);
      }, [enabled, onIndex, onBack, count]);
      
      React.useEffect(() => {
        cursorRef.current = -1;
      }, [enabled, count]);
    }
    
    // ============================================================================
    // REUSABLE COMPONENTS
    // ============================================================================
    
    function OptionButton({
      label,
      selected,
      onClick,
      shortcut,
      disabled,
      correct,
      incorrect,
      ...rest    // ‚úÖ rest props
    }) {
      const bg = correct
        ? 'var(--success)'
        : incorrect
        ? 'var(--danger)'
        : selected
        ? 'var(--primary-dark)'
        : 'var(--primary)';
    
      const className = `option-btn ${correct ? 'correct' : ''} ${incorrect ? 'incorrect' : ''}`;
    
      return (
        <button
          type="button"
          className={className}
          role="button"
          aria-keyshortcuts={shortcut || ''}
          style={{ background: bg }}
          onClick={onClick}
          disabled={disabled}
          {...rest}   // ‚úÖ spread the rest props
        >
          {label}
          {correct && ' ‚úì'}
          {incorrect && ' ‚úï'}
          {shortcut && <span className="sr-only"> (Shortcut {shortcut})</span>}
        </button>
      );
    }
    
    function ProgressBar({ current, max, label }) {
      const percent = Math.min(100, Math.max(0, (current / max) * 100));
      return (
        <div style={{margin:'1rem 0'}}>
          {label && <div style={{marginBottom:'0.5rem',fontSize:'0.9rem',color:'var(--ink-light)'}}>{label}</div>}
          <div className="progress-bar">
            <div className="progress-fill" style={{width:`${percent}%`}} />
          </div>
          <div style={{marginTop:'0.25rem',fontSize:'0.85rem',color:'var(--ink-light)',textAlign:'right'}}>
            {current} / {max}
          </div>
        </div>
      );
    }
    
    function AchievementPopup({ achievement, onClose }) {
      React.useEffect(() => {
        audioEngine.playCelebration();
        vibrate([50, 100, 50]);
        speak(`Achievement unlocked: ${achievement.name}`);
        
        // Create confetti
        for(let i=0; i<30; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.background = ['var(--success)','var(--primary)','var(--accent)','var(--warning)'][Math.floor(Math.random()*4)];
            confetti.style.animationDelay = Math.random() * 0.5 + 's';
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 3000);
          }, i*50);
        }
        
        const timer = setTimeout(onClose, 4000);
        return () => clearTimeout(timer);
      }, [achievement, onClose]);
      
      return (
        <div className="achievement-popup">
          <div style={{fontSize:'4rem',marginBottom:'0.5rem'}}>{achievement.icon}</div>
          <h2 style={{marginBottom:'0.5rem'}}>Achievement Unlocked!</h2>
          <h3 style={{color:'var(--accent)',marginBottom:'0.5rem'}}>{achievement.name}</h3>
          <p style={{color:'var(--ink-light)',marginBottom:'0.5rem'}}>{achievement.desc}</p>
          <div className="badge badge-large">+{achievement.xp} XP</div>
        </div>
      );
    }
    
    function Toast({ message, type = 'success', onClose }) {
      React.useEffect(() => {
        const timer = setTimeout(onClose, 3000);
        return () => clearTimeout(timer);
      }, [onClose]);
      
      const className = `toast toast-${type}`;
      
      return (
        <div className={className}>
          <strong>{message}</strong>
        </div>
      );
    }
    
    // ============================================================================
    // BIELER METHOD CONTENT (Enhanced)
    // ============================================================================
    
    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1st‚Äì2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shifting‚Äîmoving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibrato‚Äîfinger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'DeÃÅtacheÃÅ', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'ColleÃÅ', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'MarteleÃÅ', def:'Accented, stopped stroke‚Äîbite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance point‚Äîvertical energy, horizontal timing.' },
      { term:'SautilleÃÅ', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term: 'Nature', def: "Use body's natural alignments‚Äîeconomy, ease, resonance." },
      { term:'Nurture', def:'Stepwise training‚Äîpatterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];
    
    const BIELER_CONCEPT_QA = [
      { q:'Why does "hand frame" matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautilleÃÅ?', a:'Spiccato is placed/rebounded; sautilleÃÅ is natural spring at faster tempi.', wrong:['Spiccato is legato','SautilleÃÅ is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];
    
    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy marteleÃÅ at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist colleÃÅ','Firm staccato','Always play sul ponticello'] },
    ];
    
    // ============================================================================
    // VISUAL FINGERBOARD (Enhanced)
    // ============================================================================
    
    function VisualFingerboard({
      highlight = [],
      onSelect,
      disabled,
      showNotes = false
    }) {
      // Map highlight array to quick lookup
      const hiMap = {};
      for (const h of highlight) {
        hiMap[`${h.s}:${h.p}:${h.f}`] = h.kind || 'correct';
      }
    
      const width = 760;
      const height = 220;
      const leftMargin = 60;
      const rightMargin = 24;
      const topMargin = 40;
      const bottomMargin = 32;
    
      const boardWidth = width - leftMargin - rightMargin;
      const boardHeight = height - topMargin - bottomMargin;
    
      const visualStrings = VISUAL_STRING_ORDER; // E, A, D, G (what we draw)
      const posCount = POSITIONS.length;
      const stringCount = visualStrings.length;
    
      const colWidth = boardWidth / posCount;
      const rowHeight = boardHeight / stringCount;
    
      const stringColors = {
        G: '#b45309', // warm brown / rust
        D: '#16a34a', // green
        A: '#ea580c', // orange
        E: '#2563eb'  // blue
      };
    
      const vibrateSafe = (pattern) => {
        try {
          if (window.navigator && window.navigator.vibrate) {
            window.navigator.vibrate(pattern);
          }
        } catch {}
      };
    
      const act = (cell) => {
        if (!disabled && onSelect) {
          onSelect(cell);
          vibrateSafe([30]);
        }
      };
    
      return (
        <svg
          viewBox={`0 0 ${width} ${height}`}
          width="100%"
          height="auto"
          role="grid"
          aria-label="Interactive violin fingerboard"
          aria-rowcount={stringCount}
          aria-colcount={posCount * FINGERS.length}
        >
          <defs>
            {/* Ebony-style gradient for the main board */}
            <linearGradient id="fingerboardEbony" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stopColor="#1f2430" />
              <stop offset="100%" stopColor="#05070b" />
            </linearGradient>
    
            {/* Soft highlight for correct notes */}
            <linearGradient id="fingerboardHighlight" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stopColor="#fbbf24" stopOpacity="0.95" />
              <stop offset="100%" stopColor="#f97316" stopOpacity="0.95" />
            </linearGradient>
    
            {/* Optional cross-hatch for distractors / alternates */}
            <pattern
              id="fingerboardAltPattern"
              patternUnits="userSpaceOnUse"
              width="8"
              height="8"
            >
              <rect width="8" height="8" fill="#facc15" />
              <path
                d="M0 0 L8 8 M8 0 L0 8"
                stroke="#fefce8"
                strokeWidth="1"
              />
            </pattern>
          </defs>
    
          {/* Nut / scroll side */}
          <text
            x={leftMargin}
            y={18}
            fontSize="10"
            fill="rgba(148, 163, 184, 0.9)"
            textAnchor="start"
          >
            Nut
          </text>
    
          {/* Bridge side */}
          <text
            x={leftMargin + boardWidth}
            y={18}
            fontSize="10"
            fill="rgba(148, 163, 184, 0.9)"
            textAnchor="end"
          >
            Toward bridge
          </text>
    
          {/* Position labels above the board (1st‚Äì7th) */}
          {POSITIONS.map((p, idx) => {
            const xCenter = leftMargin + colWidth * (idx + 0.5);
            return (
              <text
                key={`pos-label-${p}`}
                x={xCenter}
                y={topMargin - 10}
                fontSize="12"
                fontWeight="600"
                fill="rgba(148, 163, 184, 0.95)"
                textAnchor="middle"
              >
                {ordinal(p)}   {/* e.g. 1st, 2nd, 3rd, ... */}
              </text>
            );
          })}
    
          {/* Main ebony fingerboard */}
          <rect
            x={leftMargin}
            y={topMargin}
            width={boardWidth}
            height={boardHeight}
            rx={10}
            fill="url(#fingerboardEbony)"
            stroke="rgba(15, 23, 42, 0.9)"
            strokeWidth="2"
          />
    
          {/* Vertical position bands */}
          {POSITIONS.map((p, idx) => {
            const x = leftMargin + colWidth * idx;
            return (
              <line
                key={`pos-line-${p}`}
                x1={x}
                x2={x}
                y1={topMargin}
                y2={topMargin + boardHeight}
                stroke="rgba(148, 163, 184, 0.28)"
                strokeWidth={idx === 0 ? 1.5 : 1}
              />
            );
          })}
    
          {/* String lanes in visual order: E (top) ‚Üí G (bottom) */}
          {visualStrings.map((s, rowIndex) => {
            const yMid = topMargin + rowHeight * (rowIndex + 0.5);
            const color = stringColors[s] || 'rgba(148, 163, 184, 0.85)';
    
            return (
              <g key={`string-${s}`}>
                {/* tinted lane */}
                <rect
                  x={leftMargin}
                  y={yMid - rowHeight * 0.45}
                  width={boardWidth}
                  height={rowHeight * 0.9}
                  fill="rgba(15, 23, 42, 0.45)"
                />
                {/* actual string line */}
                <line
                  x1={leftMargin + 4}
                  x2={leftMargin + boardWidth - 4}
                  y1={yMid}
                  y2={yMid}
                  stroke={color}
                  strokeWidth="2.2"
                  strokeLinecap="round"
                  strokeOpacity="0.85"
                />
                {/* string label on the left */}
                <text
                  x={leftMargin - 16}
                  y={yMid + 4}
                  fontSize="12"
                  fontWeight="600"
                  fill={color}
                  textAnchor="end"
                >
                  {s}
                </text>
              </g>
            );
          })}
    
          {/* Clickable pads: one per (string, position, finger), aligned with visual rows */}
          {visualStrings.map((s, rowIndex) =>
            POSITIONS.map((p, pIdx) =>
              FINGERS.map((f) => {
                const yMid = topMargin + rowHeight * (rowIndex + 0.5);
                const bandX = leftMargin + colWidth * pIdx;
    
                // Slight ‚Äútoward bridge‚Äù compression in higher positions
                const innerWidth = colWidth * (0.82 - pIdx * 0.03); // stays > 0
                const fingerGap = innerWidth / (FINGERS.length + 1);
    
                const padWidth = Math.min(fingerGap * 0.9, 30);
                const padHeight = rowHeight * 0.46;
    
                const x = bandX + fingerGap * f - padWidth / 2;
                const y = yMid - padHeight / 2;
    
                const key = `${s}:${p}:${f}`;
                const kind = hiMap[key];
                const note = canonicalBase(s, p, f);
    
                const isCorrect = kind === 'correct';
                const isChosen = kind === 'chosen';
                const isDistractor = kind === 'distractor';
    
                let fill = 'rgba(248, 250, 252, 0.05)';
                let stroke = 'rgba(148, 163, 184, 0.4)';
                let strokeWidth = 1;
    
                if (isCorrect) {
                  fill = 'url(#fingerboardHighlight)';
                  stroke = '#92400e';
                  strokeWidth = 1.6;
                } else if (isChosen && !isCorrect) {
                  fill = 'rgba(37, 99, 235, 0.12)';
                  stroke = '#2563eb';
                  strokeWidth = 1.6;
                } else if (isDistractor) {
                  fill = 'url(#fingerboardAltPattern)';
                  stroke = 'rgba(202, 138, 4, 0.9)';
                  strokeWidth = 1.2;
                }
    
                return (
                  <g key={key}>
                    <rect
                      x={x}
                      y={y}
                      width={padWidth}
                      height={padHeight}
                      rx={6}
                      ry={6}
                      fill={fill}
                      stroke={stroke}
                      strokeWidth={strokeWidth}
                      role="gridcell"
                      aria-selected={isCorrect || isChosen}
                      aria-label={`${s} string, ${ordinal(p)} position, finger ${f}, note ${note}`}
                      tabIndex={disabled ? -1 : 0}
                      style={{ cursor: disabled ? 'default' : 'pointer' }}
                      onClick={() => act({ s, p, f })}
                      onKeyDown={(e) => {
                        if (!disabled && (e.key === 'Enter' || e.key === ' ')) {
                          e.preventDefault();
                          e.stopPropagation();
                          act({ s, p, f });
                        }
                      }}
                    />
                    {/* Optional note-name overlay for study mode */}
                    {showNotes && (
                      <text
                        x={x + padWidth / 2}
                        y={y + padHeight / 2 + 4}
                        textAnchor="middle"
                        fontSize="10"
                        fontWeight="600"
                        fill="#e5e7eb"
                        pointerEvents="none"
                      >
                        {note}
                      </text>
                    )}
                    {/* Check / X icons, smaller and centered */}
                    {isCorrect && (
                      <text
                        x={x + padWidth / 2}
                        y={y + padHeight / 2 + 4}
                        textAnchor="middle"
                        fontSize="12"
                        fill="#111827"
                        pointerEvents="none"
                      >
                        ‚úì
                      </text>
                    )}
                    {isChosen && !isCorrect && (
                      <text
                        x={x + padWidth / 2}
                        y={y + padHeight / 2 + 4}
                        textAnchor="middle"
                        fontSize="12"
                        fill="#eff6ff"
                        pointerEvents="none"
                      >
                        ‚úï
                      </text>
                    )}
                  </g>
                );
              })
            )
          )}
        </svg>
      );
    }
    
    // ============================================================================
    // SPEED DRILL (Enhanced with Adaptive Difficulty)
    // ============================================================================
    
    function SpeedDrill({ prefs, onBack }) {
      const [stats, setStats] = React.useState(() => loadJSON(STATS_KEY, {}));
      const cells = React.useMemo(() => filteredCells(prefs), [prefs]);
      const [time, setTime] = React.useState(90);
      const [paused, setPaused] = React.useState(false);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      const [streak, setStreak] = React.useState(0);
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [feedback, setFeedback] = React.useState(null);
      const [showCelebration, setShowCelebration] = React.useState(false);
      
      // Mastery + recommended difficulty for the cells currently in play
      const avgMastery = React.useMemo(
        () => avgMasteryForSelection(prefs),
        [prefs]
      );
      const difficultyTier = React.useMemo(
        () => difficultyTierFromMastery(avgMastery),
        [avgMastery]
      );
      
      const pick = React.useCallback(() => {
        if (!cells.length) {
          setQ(null);
          return;
        }
      
        const bkt = loadBKT();
      
        // Weighted random draw over filtered cells using BKT weights
        const weights = cells.map(c => bktPracticeWeight(bkt, c.s, c.p, c.f));
        const total = weights.reduce((sum, w) => sum + w, 0) || 1;
      
        let r = Math.random() * total;
        let chosen = cells[cells.length - 1];
      
        for (let i = 0; i < cells.length; i++) {
          r -= weights[i];
          if (r <= 0) {
            chosen = cells[i];
            break;
          }
        }
      
        const correct = chosen.canon;
        const pool = [...new Set(cells.map(c => c.canon))].filter(n => n !== correct);
        const opts = shuffle([correct, ...shuffle(pool).slice(0, 3)]);
      
        setQ({ cell: chosen, options: opts });
        setSelected(null);
        setFeedback(null);
      
        try {
          const midi = MIDI_BASE[chosen.s] + POS_SHIFT[chosen.p] + BASE_OFF[chosen.f];
          audioEngine.playNote({ midi });
        } catch {}
      }, [cells]);
      
      React.useEffect(() => {
        pick();
      }, [cells]);
      
      React.useEffect(() => {
        if (paused) return;
        const id = setInterval(() => setTime(t => t <= 1 ? 0 : t - 1), 1000);
        return () => clearInterval(id);
      }, [paused]);
      
      const answer = (opt, idx) => {
        if (selected !== null) return;
        setSelected(idx);
        
        setTimeout(() => {
          const ok = opt === q.cell.canon;
          
          // Update mastery model for this note-frame
          recordBKTObservation(q.cell.s, q.cell.p, q.cell.f, ok);
          
          if (ok) {
            setScore(s => s + 1);
            setStreak(s => {
              const newStreak = s + 1;
              if (newStreak === 5) {
                checkAchievement('perfect_5');
                setShowCelebration(true);
                setTimeout(() => setShowCelebration(false), 2000);
              }
              if (newStreak === 10) {
                checkAchievement('perfect_10');
                setShowCelebration(true);
                setTimeout(() => setShowCelebration(false), 2000);
              }
              return newStreak;
            });
            setFeedback({ type: 'success', message: getRandom(PRAISE_MESSAGES) });
          } else {
            setStreak(0);
            setFeedback({ type: 'error', message: `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct answer: ${q.cell.canon}` });
          }
          
          setAnswered(a => {
            const newAnswered = a + 1;
            if (newAnswered === 10) checkAchievement('speed_10');
            if (newAnswered === 50) checkAchievement('speed_50');
            return newAnswered;
          });
          
          speakSR(ok ? getRandom(PRAISE_MESSAGES) : `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct answer was ${q.cell.canon}`);
          audioEngine.playFeedback(ok);
          vibrate(ok ? [50] : [50, 100, 50]);
          
          setStats(prev => {
            const k = `${q.cell.s}:${q.cell.p}:${q.cell.f}`;
            const st = prev[k] || { correct: 0, total: 0 };
            const next = {
              ...prev,
              [k]: {
                correct: st.correct + (ok ? 1 : 0),
                total: st.total + 1,
                lastPracticed: Date.now()
              }
            };
            saveJSON(STATS_KEY, next);
            setTimeout(() => pick(), ok ? 500 : 1500);
            return next;
          });
          
          addXP(ok ? 8 : 2);
          
          setTimeout(() => setFeedback(null), ok ? 500 : 1500);
        }, 200);
      };
      
      const optionCount =
        q && Array.isArray(q.options) && q.options.length
          ? q.options.length
          : 4;
      
      useAnswerHotkeys(
        !!q && !paused,
        (i) => {
          if (q && q.options[i]) answer(q.options[i], i);
        },
        onBack,
        optionCount
      );
      
      if (time === 0) {
        return (
          <div>
            <div className="card">
              <h2>üéØ Speed Drill Complete!</h2>
              <div className="stat-card" style={{margin:'1.5rem 0'}}>
                <div className="stat-label">Final Score</div>
                <div className="stat-value">{score} / {answered}</div>
                <div className="stat-label">
                  {answered > 0 ? `${Math.round((score/answered)*100)}% Accuracy` : ''}
                </div>
              </div>
              {streak > 0 && (
                <div style={{textAlign:'center',margin:'1rem 0'}}>
                  <div className="badge badge-large">
                    üî• Best Streak: {streak}
                  </div>
                </div>
              )}
              <p style={{textAlign:'center',color:'var(--ink-light)'}}>
                {score === answered ? 'Perfect score! You\'re amazing! üåü' :
                 score > answered * 0.8 ? 'Excellent work! Keep practicing! üéµ' :
                 score > answered * 0.6 ? 'Good job! You\'re improving! üí™' :
                 'Keep practicing! You\'ll get better! üéª'}
              </p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }
      
      if (!cells.length) {
        return (
          <div>
            <div className="card">
              <h2>‚ö†Ô∏è No Practice Items</h2>
              <p>Please enable at least one string and position in Settings.</p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }
      
      return (
        <div>
          <div className="card">
            <div
              style={{
                display:'flex',
                justifyContent:'space-between',
                alignItems:'center',
                marginBottom:'1rem'
              }}
            >
              <div>
                <h2 style={{margin:0}}>‚ö° Speed Drill</h2>
                <p
                  style={{
                    margin:0,
                    marginTop:'0.25rem',
                    fontSize:'0.8rem',
                    color:'var(--ink-light)'
                  }}
                >
                  Recommended difficulty:{' '}
                  <strong>{difficultyTier}</strong>
                  {' ¬∑ '}Avg mastery in this range:{' '}
                  {Math.round(avgMastery * 100)}%
                </p>
              </div>
              <button
                className="btn btn-secondary"
                onClick={() => setPaused(p => !p)}
              >
                {paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'}
              </button>
            </div>
            
            <div className="grid grid-cols-3" style={{marginBottom:'1.5rem'}}>
              <div className="stat-card card-compact">
                <div className="stat-label">Time</div>
                <div className="stat-value" style={{fontSize:'1.8rem'}}>{time}s</div>
              </div>
              <div className="stat-card card-compact">
                <div className="stat-label">Score</div>
                <div className="stat-value" style={{fontSize:'1.8rem'}}>{score}/{answered}</div>
              </div>
              <div className="stat-card card-compact">
                <div className="stat-label">Streak</div>
                <div className="stat-value" style={{fontSize:'1.8rem'}}>
                  {streak > 0 ? `üî• ${streak}` : '-'}
                </div>
              </div>
            </div>
            
            {showCelebration && (
              <div style={{
                textAlign:'center',
                padding:'1rem',
                background:'linear-gradient(135deg, var(--gradient-1), var(--gradient-2))',
                color:'#fff',
                borderRadius:'12px',
                marginBottom:'1rem',
                animation:'celebrate 1s ease'
              }}>
                <h3 style={{margin:0,color:'#fff'}}>üåü Amazing Streak! üåü</h3>
              </div>
            )}
            
            {q && !paused && (
              <div>
                <p style={{fontSize:'1.1rem',fontWeight:600,marginBottom:'1rem'}}>
                  What is the base note at <strong style={{color:'var(--primary)'}}>{ordinal(q.cell.p)} position, {ordinal(q.cell.f)} finger on {q.cell.s}</strong> string?
                </p>
                
                <div role="radiogroup" aria-label="Answer choices">
                  {q.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selected === i}
                      correct={selected === i && opt === q.cell.canon}
                      incorrect={selected === i && opt !== q.cell.canon}
                      onClick={() => answer(opt, i)}
                      disabled={selected !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
                
                {feedback && (
                  <div style={{
                    marginTop:'1rem',
                    padding:'0.75rem',
                    borderRadius:'8px',
                    background: feedback.type === 'success' ? 'var(--success)' : 'var(--warning)',
                    color:'#fff',
                    fontWeight:600,
                    textAlign:'center'
                  }}>
                    {feedback.message}
                  </div>
                )}
              </div>
            )}
            
            {paused && (
              <div style={{textAlign:'center',padding:'2rem',color:'var(--ink-light)'}}>
                <h3>‚è∏Ô∏è Paused</h3>
                <p>Press Resume when you're ready to continue!</p>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // INTERVAL TRAINING (NEW)
    // ============================================================================
    
    function IntervalTraining({ onBack }) {
      const [mode, setMode] = React.useState('listen'); // 'listen' or 'identify'
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      const [feedback, setFeedback] = React.useState(null);
      
      const generateQuestion = React.useCallback(() => {
        const intervalNames = Object.keys(INTERVALS);
        const correctInterval = getRandom(intervalNames);
        const rootMidi = 60 + Math.floor(Math.random() * 12);
        const semitones = INTERVALS[correctInterval];
        
        const wrongIntervals = shuffle(
          intervalNames.filter(i => i !== correctInterval)
        ).slice(0, 3);
        
        const options = shuffle([correctInterval, ...wrongIntervals]);
        
        setQ({ rootMidi, correct: correctInterval, semitones, options });
        setSelected(null);
        setFeedback(null);
      }, []);
      
      React.useEffect(() => {
        generateQuestion();
      }, []);
      
      const playInterval = () => {
        if (q) {
          audioEngine.playInterval({
            rootMidi: q.rootMidi,
            semitones: q.semitones,
            simultaneous: mode === 'listen'
          });
        }
      };
      
      const answer = (opt, idx) => {
        if (selected !== null) return;
        setSelected(idx);
        
        setTimeout(() => {
          const ok = opt === q.correct;
          
          if (ok) {
            setScore(s => s + 1);
            setFeedback({ type: 'success', message: getRandom(PRAISE_MESSAGES) });
          } else {
            setFeedback({ type: 'error', message: `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct: ${q.correct}` });
          }
          
          setAnswered(a => a + 1);
          
          speakSR(ok ? getRandom(PRAISE_MESSAGES) : `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct answer was ${q.correct}`);
          audioEngine.playFeedback(ok);
          vibrate(ok ? [50] : [50, 100, 50]);
          addXP(ok ? 10 : 3);

        // Track interval mastery
        if (ok) {
          const intervalStats = loadJSON(INTERVAL_STATS_KEY, {});
          const key = q.correct;
          const st = intervalStats[key] || { correct: 0, total: 0 };
          st.correct += 1;
          st.total += 1;
          intervalStats[key] = st;
          saveJSON(INTERVAL_STATS_KEY, intervalStats);

          // Check for interval_master achievement
          const allIntervals = Object.keys(INTERVALS);
          const masteredCount = allIntervals.filter(int => {
            const stat = intervalStats[int];
            return stat && stat.total >= 10 && (stat.correct / stat.total) >= 0.8;
          }).length;

          if (masteredCount === allIntervals.length) {
            checkAchievement('interval_master');
          }
        } else {
          // Track failed attempts
          const intervalStats = loadJSON(INTERVAL_STATS_KEY, {});
          const key = q.correct;
          const st = intervalStats[key] || { correct: 0, total: 0 };
          st.total += 1;
          intervalStats[key] = st;
          saveJSON(INTERVAL_STATS_KEY, intervalStats);
        }
          
          setTimeout(() => {
            generateQuestion();
            setFeedback(null);
          }, ok ? 800 : 2000);
        }, 200);
      };
      
      const optionCount =
        q && Array.isArray(q.options) && q.options.length
          ? q.options.length
          : 4;
      
      useAnswerHotkeys(
        !!q,
        (i) => {
          if (q && q.options[i]) answer(q.options[i], i);
        },
        onBack,
        optionCount
      );
      
      return (
        <div>
          <div className="card">
            <h2>üé∂ Interval Training</h2>
            
            <div style={{display:'flex',gap:'0.5rem',margin:'1rem 0'}}>
              <button
                className={`btn ${mode === 'listen' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('listen')}
              >
                Harmonic (Together)
              </button>
              <button
                className={`btn ${mode === 'identify' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('identify')}
              >
                Melodic (Sequential)
              </button>
            </div>
            
            <div className="stat-card" style={{margin:'1rem 0'}}>
              <div className="stat-label">Score</div>
              <div className="stat-value" style={{fontSize:'1.5rem'}}>
                {score} / {answered}
                {answered > 0 && ` (${Math.round((score/answered)*100)}%)`}
              </div>
            </div>
            
            {q && (
              <div>
                <div style={{textAlign:'center',margin:'1.5rem 0'}}>
                  <button
                    className="btn btn-accent btn-large"
                    onClick={playInterval}
                  >
                    üîä Play Interval
                  </button>
                </div>
                
                <p style={{fontWeight:600,textAlign:'center',marginBottom:'1rem'}}>
                  What interval do you hear?
                </p>
                
                <div role="radiogroup" aria-label="Interval choices">
                  {q.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selected === i}
                      correct={selected === i && opt === q.correct}
                      incorrect={selected === i && opt !== q.correct}
                      onClick={() => answer(opt, i)}
                      disabled={selected !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
                
                {feedback && (
                  <div style={{
                    marginTop:'1rem',
                    padding:'0.75rem',
                    borderRadius:'8px',
                    background: feedback.type === 'success' ? 'var(--success)' : 'var(--warning)',
                    color:'#fff',
                    fontWeight:600,
                    textAlign:'center'
                  }}>
                    {feedback.message}
                  </div>
                )}
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // RHYTHM TRAINER (NEW)
    // ============================================================================
    
    function RhythmTrainer({ onBack }) {
      const [bpm, setBpm] = React.useState(80);
      const [playing, setPlaying] = React.useState(false);
      const [currentBeat, setCurrentBeat] = React.useState(0);
      const [pattern, setPattern] = React.useState('Quarter Notes');
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      
      const patterns = Object.keys(RHYTHM_PATTERNS);
      
      const generateQuestion = React.useCallback(() => {
        const correctPattern = getRandom(patterns);
        const wrongPatterns = shuffle(
          patterns.filter(p => p !== correctPattern)
        ).slice(0, 3);
        const options = shuffle([correctPattern, ...wrongPatterns]);
        
        setQ({ correct: correctPattern, options });
        setSelected(null);
      }, []);
      
      React.useEffect(() => {
        generateQuestion();
      }, []);
      
      const playPattern = (patternName) => {
        const beats = RHYTHM_PATTERNS[patternName];
        const beatInterval = (60 / bpm) * 1000;
        
        setPlaying(true);
        setCurrentBeat(0);
        
        let currentTime = 0;
        beats.forEach((duration, i) => {
          setTimeout(() => {
            audioEngine.playNote({ midi: 69, durationMs: duration * beatInterval * 0.8 });
            setCurrentBeat(i);
            if (i === beats.length - 1) {
              setTimeout(() => {
                setPlaying(false);
                setCurrentBeat(0);
              }, duration * beatInterval);
            }
          }, currentTime);
          currentTime += duration * beatInterval;
        });
      };
      
      const answer = (opt, idx) => {
        if (selected !== null) return;
        setSelected(idx);
        
        setTimeout(() => {
          const ok = opt === q.correct;
          
          if (ok) {
            setScore(s => s + 1);
          }
          setAnswered(a => a + 1);
          
          speakSR(ok ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
          audioEngine.playFeedback(ok);
          vibrate(ok ? [50] : [50, 100, 50]);
          addXP(ok ? 10 : 3);

        // Track rhythm mastery
        if (ok) {
          const rhythmStats = loadJSON(RHYTHM_STATS_KEY, {});
          const key = q.correct;
          const st = rhythmStats[key] || { correct: 0, total: 0 };
          st.correct += 1;
          st.total += 1;
          rhythmStats[key] = st;
          saveJSON(RHYTHM_STATS_KEY, rhythmStats);

          // Check for rhythm_master achievement
          const allPatterns = Object.keys(RHYTHM_PATTERNS);
          const masteredCount = allPatterns.filter(pattern => {
            const stat = rhythmStats[pattern];
            return stat && stat.total >= 10 && (stat.correct / stat.total) >= 0.8;
          }).length;

          if (masteredCount === allPatterns.length) {
            checkAchievement('rhythm_master');
          }
        } else {
          const rhythmStats = loadJSON(RHYTHM_STATS_KEY, {});
          const key = q.correct;
          const st = rhythmStats[key] || { correct: 0, total: 0 };
          st.total += 1;
          rhythmStats[key] = st;
          saveJSON(RHYTHM_STATS_KEY, rhythmStats);
        }
          
          setTimeout(() => {
            generateQuestion();
          }, ok ? 800 : 2000);
        }, 200);
      };
      
      const optionCount =
        q && Array.isArray(q.options) && q.options.length
          ? q.options.length
          : 4;
      
      useAnswerHotkeys(
        !!q && !playing,
        (i) => {
          if (q && q.options[i]) answer(q.options[i], i);
        },
        onBack,
        optionCount
      );
      
      return (
        <div>
          <div className="card">
            <h2>ü•Å Rhythm Trainer</h2>
            
            <div style={{margin:'1.5rem 0'}}>
              <label style={{display:'block',marginBottom:'0.5rem',fontWeight:600}}>
                Tempo: {bpm} BPM
              </label>
              <input
                type="range"
                min="40"
                max="200"
                value={bpm}
                onChange={(e) => setBpm(Number(e.target.value))}
                style={{width:'100%'}}
              />
            </div>
            
            <div className="stat-card" style={{margin:'1rem 0'}}>
              <div className="stat-label">Score</div>
              <div className="stat-value" style={{fontSize:'1.5rem'}}>
                {score} / {answered}
                {answered > 0 && ` (${Math.round((score/answered)*100)}%)`}
              </div>
            </div>
            
            {q && (
              <div>
                <div style={{textAlign:'center',margin:'1.5rem 0'}}>
                  <button
                    className="btn btn-accent btn-large"
                    onClick={() => playPattern(q.correct)}
                    disabled={playing}
                  >
                    {playing ? '‚è∏Ô∏è Playing...' : 'üîä Play Rhythm'}
                  </button>
                </div>
                
                {playing && (
                  <div style={{display:'flex',justifyContent:'center',gap:'0.5rem',margin:'1rem 0'}}>
                    {RHYTHM_PATTERNS[q.correct].map((_, i) => (
                      <div
                        key={i}
                        className={`metronome-beat ${i === currentBeat ? 'active' : ''}`}
                        style={{
                          width:'40px',
                          height:'40px',
                          fontSize:'0.8rem'
                        }}
                      >
                        {i + 1}
                      </div>
                    ))}
                  </div>
                )}
                
                <p style={{fontWeight:600,textAlign:'center',marginBottom:'1rem'}}>
                  What rhythm pattern did you hear?
                </p>
                
                <div role="radiogroup" aria-label="Rhythm pattern choices">
                  {q.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selected === i}
                      correct={selected === i && opt === q.correct}
                      incorrect={selected === i && opt !== q.correct}
                      onClick={() => answer(opt, i)}
                      disabled={selected !== null || playing}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // BIELER TECHNIQUE LAB (Enhanced)
    // ============================================================================
    
    function BielerLab({ onBack }) {
      const [mode, setMode] = React.useState('vocab');
      const [vi, setVi] = React.useState(0);
      const [reveal, setReveal] = React.useState(false);
      
      const nextV = () => {
        setReveal(false);
        setVi((vi + 1) % BIELER_VOCAB.length);
      };
      
      const prevV = () => {
        setReveal(false);
        setVi((vi - 1 + BIELER_VOCAB.length) % BIELER_VOCAB.length);
      };
      
      const makeConceptQ = React.useCallback(() => {
        const item = getRandom(BIELER_CONCEPT_QA);
        return {
          prompt: item.q,
          correct: item.a,
          options: shuffle([item.a, ...shuffle(item.wrong).slice(0, 3)])
        };
      }, []);
      
      const makeApplyQ = React.useCallback(() => {
        const item = getRandom(BIELER_APPLY);
        return {
          prompt: item.scenario,
          correct: item.answer,
          options: shuffle([item.answer, ...shuffle(item.wrong).slice(0, 3)])
        };
      }, []);
      
      const [cq, setCq] = React.useState(makeConceptQ);
      const [aq, setAq] = React.useState(makeApplyQ);
      const [selC, setSelC] = React.useState(null);
      const [selA, setSelA] = React.useState(null);
      const [scoreC, setScoreC] = React.useState(0);
      const [answeredC, setAnsweredC] = React.useState(0);
      const [scoreA, setScoreA] = React.useState(0);
      const [answeredA, setAnsweredA] = React.useState(0);
      
      const answerConcept = (opt, idx) => {
        if (selC !== null) return;
        setSelC(idx);
        const ok = opt === cq.correct;
        speakSR(ok ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
        if (ok) setScoreC(s => s + 1);
        setAnsweredC(a => a + 1);
        addXP(ok ? 5 : 2);

        // Track Bieler concept mastery
        if (ok) {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.conceptCorrect = (bielerStats.conceptCorrect || 0) + 1;
          bielerStats.conceptTotal = (bielerStats.conceptTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);
        } else {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.conceptTotal = (bielerStats.conceptTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);
        }
        audioEngine.playFeedback(ok);
        vibrate(ok ? [50] : [50, 100, 50]);
        setTimeout(() => {
          setCq(makeConceptQ());
          setSelC(null);
        }, ok ? 500 : 1200);
      };
      
      const answerApply = (opt, idx) => {
        if (selA !== null) return;
        setSelA(idx);
        const ok = opt === aq.correct;
        speakSR(ok ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
        if (ok) setScoreA(s => s + 1);
        setAnsweredA(a => a + 1);
        addXP(ok ? 6 : 2);

        // Track Bieler application mastery
        if (ok) {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.applyCorrect = (bielerStats.applyCorrect || 0) + 1;
          bielerStats.applyTotal = (bielerStats.applyTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);

          // Check for bieler_scholar achievement
          if ((bielerStats.conceptCorrect || 0) >= 20 && 
              (bielerStats.applyCorrect || 0) >= 10 &&
              (bielerStats.conceptTotal || 0) >= 25) {
            checkAchievement('bieler_scholar');
          }
        } else {
          const bielerStats = loadJSON(BIELER_STATS_KEY, {});
          bielerStats.applyTotal = (bielerStats.applyTotal || 0) + 1;
          saveJSON(BIELER_STATS_KEY, bielerStats);
        }
        audioEngine.playFeedback(ok);
        vibrate(ok ? [50] : [50, 100, 50]);
        setTimeout(() => {
          setAq(makeApplyQ());
          setSelA(null);
        }, ok ? 500 : 1200);
      };
      
      const conceptCount =
        cq && Array.isArray(cq.options) && cq.options.length
          ? cq.options.length
          : 4;
      
      const applyCount =
        aq && Array.isArray(aq.options) && aq.options.length
          ? aq.options.length
          : 4;
      
      const hotkeyCount = mode === 'concept' ? conceptCount : applyCount;
      
      useAnswerHotkeys(
        mode !== 'vocab',
        (i) => {
          if (mode === 'concept' && cq && cq.options[i]) {
            answerConcept(cq.options[i], i);
          }
          if (mode === 'apply' && aq && aq.options[i]) {
            answerApply(aq.options[i], i);
          }
        },
        onBack,
        hotkeyCount
      );
      
      React.useEffect(() => {
        const onKey = (e) => {
          if (e.key === 'Escape') {
            onBack();
          }
          if (mode === 'vocab') {
            if (e.key === 'ArrowRight') nextV();
            if (e.key === 'ArrowLeft') prevV();
            if (e.key === ' ') {
              e.preventDefault();
              setReveal(true);
            }
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [mode, vi, onBack]);
      
      return (
        <div>
          <div className="card">
            <h2>üìö Technique Lab</h2>
            <p style={{color:'var(--ink-light)', marginTop:'-6px', marginBottom:'1rem'}}>
              Master violin technique through progressive study: vocabulary ‚Üí concepts ‚Üí applications
            </p>
            
            <div style={{display:'flex', gap:'0.5rem', flexWrap:'wrap', marginBottom:'1rem'}}>
              <button
                className={`btn ${mode === 'vocab' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('vocab')}
              >
                üìñ Vocabulary
              </button>
              <button
                className={`btn ${mode === 'concept' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('concept')}
              >
                üß† Concepts
              </button>
              <button
                className={`btn ${mode === 'apply' ? 'btn-primary' : 'btn-secondary'}`}
                onClick={() => setMode('apply')}
              >
                üéØ Applications
              </button>
            </div>
            
            {mode === 'vocab' && (
              <div>
                <div className="card" style={{padding:'1.5rem', textAlign:'center', marginBottom:'1rem', background:'var(--primary)', color:'#fff'}}>
                  <div style={{fontWeight:700, fontSize:'1.3rem', marginBottom:'0.75rem'}}>
                    {BIELER_VOCAB[vi].term}
                  </div>
                  {reveal ? (
                    <div style={{marginTop:'0.75rem', fontSize:'1.05rem', lineHeight:'1.6'}}>
                      {BIELER_VOCAB[vi].def}
                    </div>
                  ) : (
                    <div style={{marginTop:'0.75rem', fontStyle:'italic', opacity:0.9}}>
                      Press Reveal to show definition
                    </div>
                  )}
                </div>
                
                <div style={{display:'flex', gap:'0.5rem', justifyContent:'center', flexWrap:'wrap'}}>
                  <button className="btn btn-accent" onClick={() => setReveal(true)}>
                    üëÅÔ∏è Reveal
                  </button>
                  <button className="btn btn-secondary" onClick={prevV}>
                    ‚Üê Previous
                  </button>
                  <button className="btn btn-secondary" onClick={nextV}>
                    Next ‚Üí
                  </button>
                </div>
                
                <ProgressBar
                  current={vi + 1}
                  max={BIELER_VOCAB.length}
                  label={`Card ${vi + 1} of ${BIELER_VOCAB.length}`}
                />
              </div>
            )}
            
            {mode === 'concept' && (
              <div>
                <div className="stat-card" style={{margin:'1rem 0'}}>
                  <div className="stat-label">Score</div>
                  <div className="stat-value" style={{fontSize:'1.5rem'}}>
                    {scoreC} / {answeredC}
                    {answeredC > 0 && ` (${Math.round((scoreC/answeredC)*100)}%)`}
                  </div>
                </div>
                
                <p style={{fontWeight:600, marginBottom:'1rem'}}>{cq.prompt}</p>
                
                <div role="radiogroup" aria-label="Concept answers">
                  {cq.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selC === i}
                      correct={selC === i && opt === cq.correct}
                      incorrect={selC === i && opt !== cq.correct}
                      onClick={() => answerConcept(opt, i)}
                      disabled={selC !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
              </div>
            )}
            
            {mode === 'apply' && (
              <div>
                <div className="stat-card" style={{margin:'1rem 0'}}>
                  <div className="stat-label">Score</div>
                  <div className="stat-value" style={{fontSize:'1.5rem'}}>
                    {scoreA} / {answeredA}
                    {answeredA > 0 && ` (${Math.round((scoreA/answeredA)*100)}%)`}
                  </div>
                </div>
                
                <p><em>Scenario:</em> {aq.prompt}</p>
                <p style={{fontWeight:600, marginTop:'0.5rem', marginBottom:'1rem'}}>
                  Choose the best practice approach:
                </p>
                
                <div role="radiogroup" aria-label="Application answers">
                  {aq.options.map((opt, i) => (
                    <OptionButton
                      key={i}
                      label={opt}
                      selected={selA === i}
                      correct={selA === i && opt === aq.correct}
                      incorrect={selA === i && opt !== aq.correct}
                      onClick={() => answerApply(opt, i)}
                      disabled={selA !== null}
                      shortcut={`${i+1}`}
                    />
                  ))}
                </div>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // FLASHCARDS (Enhanced with SM-2 Algorithm)
    // ============================================================================
    
    function Flashcards({ prefs, onBack }) {
      const buildCards = React.useCallback(() => {
        const cells = filteredCells(prefs);
        const cards = [];
        
        cells.forEach(c => {
          cards.push({
            type: 'cell',
            q: `Note at ${ordinal(c.p)} pos, ${ordinal(c.f)} finger on ${c.s}`,
            a: c.canon,
            easeFactor: 2.5,
            interval: 1,
            repetitions: 0,
            due: Date.now()
          });
        });
        
        const unique = [...new Set(cells.map(c => c.canon))];
        unique.forEach(n => {
          cards.push({
            type: 'note',
            q: `All locations for note ${n}?`,
            a: n,
            easeFactor: 2.5,
            interval: 1,
            repetitions: 0,
            due: Date.now()
          });
        });
        
        return cards;
      }, [prefs]);
      
      const [deck, setDeck] = React.useState(() => {
        const saved = loadJSON(FLASH_KEY, null);
        const savedSig = localStorage.getItem(FLASH_SIG_KEY);
        const curSig = JSON.stringify({
          strings: prefs.strings,
          positions: prefs.positions
        });
        
        if (saved && savedSig === curSig) return saved;
        
        const cards = buildCards();
        saveJSON(FLASH_KEY, cards);
        localStorage.setItem(FLASH_SIG_KEY, curSig);
        return cards;
      });
      
      React.useEffect(() => {
        const curSig = JSON.stringify({
          strings: prefs.strings,
          positions: prefs.positions
        });
        const savedSig = localStorage.getItem(FLASH_SIG_KEY);
        
        if (curSig !== savedSig) {
          const cards = buildCards();
          saveJSON(FLASH_KEY, cards);
          localStorage.setItem(FLASH_SIG_KEY, curSig);
          setDeck(cards);
        }
      }, [prefs, buildCards]);
      
      const [card, setCard] = React.useState(null);
      const [show, setShow] = React.useState(false);
      
      const pick = () => {
        if (!deck.length) {
          setCard(null);
          return;
        }
        
        const now = Date.now();
        const due = deck.filter(c => c.due <= now).sort((a, b) => a.due - b.due);
        const next = due.length ? due[0] : getRandom(deck);
        
        setCard(next);
        setShow(false);
      };
      
      React.useEffect(() => {
        pick();
      }, [deck]);
      
      // SM-2 Algorithm implementation
      const mark = (quality) => {
        // quality: 0-2 (forgot), 3-5 (remembered)
        const remembered = quality >= 3;
        
        setDeck(prev => {
          const upd = prev.map(c => {
            if (c === card) {
              let newEF = c.easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
              newEF = Math.max(1.3, newEF);
              
              let newInterval;
              let newReps;
              
              if (quality < 3) {
                newInterval = 1;
                newReps = 0;
              } else {
                if (c.repetitions === 0) {
                  newInterval = 1;
                } else if (c.repetitions === 1) {
                  newInterval = 6;
                } else {
                  newInterval = Math.round(c.interval * newEF);
                }
                newReps = c.repetitions + 1;
              }
              
              return {
                ...c,
                easeFactor: newEF,
                interval: newInterval,
                repetitions: newReps,
                due: Date.now() + newInterval * 24 * 3600 * 1000
              };
            }
            return c;
          });
          
          saveJSON(FLASH_KEY, upd);
          return upd;
        });
        
        addXP(remembered ? 5 : 2);
        speakSR(remembered ? getRandom(PRAISE_MESSAGES) : getRandom(ENCOURAGEMENT_MESSAGES));
        audioEngine.playFeedback(remembered);
        vibrate(remembered ? [50] : [50, 100, 50]);
        
        pick();
      };
      
      if (!deck.length) {
        return (
          <div>
            <div className="card">
              <h2>‚ö†Ô∏è No Flashcards</h2>
              <p>Please enable at least one string and position in Settings.</p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }
      
      const dueCount = deck.filter(c => c.due <= Date.now()).length;
      
      return (
        <div>
          <div className="card">
            <h2>üóÇÔ∏è Flashcards</h2>
            
            <div className="stat-card" style={{margin:'1rem 0'}}>
              <div className="stat-label">Cards Due for Review</div>
              <div className="stat-value" style={{fontSize:'1.8rem'}}>
                {dueCount} / {deck.length}
              </div>
            </div>
            
            {card && (
              <div>
                <div className="card" style={{
                  padding:'2rem',
                  textAlign:'center',
                  minHeight:'150px',
                  display:'flex',
                  flexDirection:'column',
                  justifyContent:'center',
                  background:'linear-gradient(135deg, var(--primary), var(--primary-dark))',
                  color:'#fff',
                  marginBottom:'1rem'
                }}>
                  <p style={{fontSize:'1.2rem', fontWeight:600, marginBottom:'1rem', color:'#fff'}}>
                    {card.q}
                  </p>
                  
                  {show ? (
                    <div>
                      <p style={{
                        fontWeight:700,
                        fontSize:'2rem',
                        margin:'1rem 0',
                        color:'#fff'
                      }}>
                        {card.a}
                      </p>
                      {card.type === 'note' && (
                        <p style={{fontSize:'0.9rem', opacity:0.9, color:'#fff'}}>
                          (Multiple positions may apply)
                        </p>
                      )}
                    </div>
                  ) : (
                    <button
                      className="btn btn-accent btn-large"
                      onClick={() => setShow(true)}
                    >
                      üëÅÔ∏è Reveal Answer
                    </button>
                  )}
                </div>
                
                {show && (
                  <div>
                    <p style={{textAlign:'center', marginBottom:'0.75rem', fontWeight:600}}>
                      How well did you remember?
                    </p>
                    <div className="grid grid-cols-2" style={{gap:'0.5rem'}}>
                      <button
                        className="btn btn-danger"
                        onClick={() => mark(1)}
                      >
                        üòî Forgot
                      </button>
                      <button
                        className="btn btn-warning"
                        onClick={() => mark(3)}
                      >
                        ü§î Hard
                      </button>
                      <button
                        className="btn btn-primary"
                        onClick={() => mark(4)}
                      >
                        üòä Good
                      </button>
                      <button
                        className="btn btn-success"
                        onClick={() => mark(5)}
                      >
                        üéâ Easy
                      </button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    // ============================================================================
    // PROGRESS & ANALYTICS (NEW)
    // ============================================================================
    
    

    // ============================================================================
    // REFLECTION LAB - Journal & Metacognitive Practice
    // ============================================================================

    function loadReflections() {
      try {
        const raw = localStorage.getItem(REFLECTIONS_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (err) {
        console.warn('Failed to load reflections', err);
        return [];
      }
    }

    function saveReflections(entries) {
      try {
        localStorage.setItem(REFLECTIONS_KEY, JSON.stringify(entries));
      } catch (err) {
        console.warn('Failed to save reflections', err);
      }
    }

    function useReflectionJournal(defaultModule) {
      const [entries, setEntries] = React.useState(() => loadReflections());
      const [filterModule, setFilterModule] = React.useState('all');

      React.useEffect(() => {
        saveReflections(entries);
      }, [entries]);

      const addEntry = React.useCallback(
        ({ module, focus, wins, challenges, nextSteps, mood }) => {
          const now = new Date();
          const payload = {
            id: now.getTime(),
            createdAt: now.toISOString(),
            module: module || defaultModule || 'general',
            focus: (focus || '').trim(),
            wins: (wins || '').trim(),
            challenges: (challenges || '').trim(),
            nextSteps: (nextSteps || '').trim(),
            mood: mood || 'neutral',
          };

          // Ignore totally empty notes
          if (
            !payload.focus &&
            !payload.wins &&
            !payload.challenges &&
            !payload.nextSteps
          ) {
            return;
          }

          setEntries(prev => {
            const next = [payload, ...prev].slice(0, 300);

            const reflectionCount = prev.length + 1;
            if (reflectionCount === 10 && checkAchievement('reflection_10')) {
              // Achievement unlocked - will be caught by App's achievement watcher
            }

            // Reward XP for reflection
            addXP(3);
            speakSR('Reflection saved! +3 XP');

            return next;
          });
        },
        [defaultModule]
      );

      const clearAll = React.useCallback(() => {
        if (!window.confirm('Clear all reflections? This cannot be undone.')) return;
        setEntries([]);
        saveReflections([]);
      }, []);

      const filteredEntries = React.useMemo(() => {
        if (filterModule === 'all') return entries;
        return entries.filter(e => e.module === filterModule);
      }, [entries, filterModule]);

      return {
        entries,
        filteredEntries,
        filterModule,
        setFilterModule,
        addEntry,
        clearAll,
      };
    }

    
    function PracticeReflectionJournal({ currentModule, onBack }) {
            const streak = loadJSON(STREAK_KEY, { current: 0, longest: 0 });
      const xp = loadJSON(XP_KEY, 0);
      const level = levelForXP(xp);

      const moduleOptions = [
        { value: 'general', label: 'General' },
        { value: 'interval', label: 'Interval Training' },
        { value: 'rhythm', label: 'Rhythm Trainer' },
        { value: 'speed', label: 'Speed Drill' },
        { value: 'bieler', label: 'Technique Lab' }
      ];
      
        const getModuleLabel = (value) => {
        const m = moduleOptions.find((mod) => mod.value === value);
        return m ? m.label : 'General';
      };

      const defaultModuleValue =
        currentModule && moduleOptions.some(m => m.value === currentModule)
          ? currentModule
          : 'general';

      const [moduleValue, setModuleValue] = React.useState(defaultModuleValue);
      const [focus, setFocus] = React.useState('');
      const [wins, setWins] = React.useState('');
      const [challenges, setChallenges] = React.useState('');
      const [nextSteps, setNextSteps] = React.useState('');
      const [mood, setMood] = React.useState('neutral');

      const {
        entries,
        filteredEntries,
        filterModule,
        setFilterModule,
        addEntry,
        clearAll
      } = useReflectionJournal(defaultModuleValue);

      const handleTemplate = (template) => {
        if (template === 'interval') {
          setFocus('Intonation and interval recognition');
          setNextSteps(
            '1) Sing target intervals before playing\\n' +
            '2) Slow double-stop checks in problem spots\\n' +
            '3) Link intervals to fingerboard shapes'
          );
          setMood('focused');
        } else if (template === 'rhythm') {
          setFocus('Pulse, subdivision, and bow coordination');
          setNextSteps(
            '1) Clap and count out loud with a metronome\\n' +
            '2) Tap foot only on beats 1 and 3, feel 2 & 4\\n' +
            '3) Bow open strings to the same rhythm'
          );
          setMood('energized');
        } else if (template === 'speed') {
          setFocus('Quick note recognition and accuracy');
          setNextSteps(
            '1) Name notes aloud while playing slow scales\\n' +
            '2) Practice position shifts with anchor notes\\n' +
            '3) Review one fingerboard pattern each day'
          );
          setMood('curious');
        } else if (template === 'bieler') {
          setFocus('Sound quality, bow contact point, and leverage');
          setNextSteps(
            '1) Slow tone work near the bridge with full bow\\n' +
            '2) Experiment with "polishing" vs "dusting" the string\\n' +
            '3) Apply to 2‚Äì3 bars from current piece'
          );
          setMood('thoughtful');
        }
      };

      const handleSubmit = event => {
        event.preventDefault();
        addEntry({
          module: moduleValue,
          focus,
          wins,
          challenges,
          nextSteps,
          mood
        });

        audioEngine.playFeedback(true);
        vibrate([50]);
        speakSR('Reflection saved!');

        // soft reset
        setWins('');
        setChallenges('');
        setNextSteps('');
      };

      const mostRecent = entries[0];

      return (
        <div>
          <div className="card">
            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'1rem'}}>
              <h2 style={{margin:0}}>üìù Reflection Lab</h2>
              <div style={{display:'flex', gap:'0.5rem'}}>
                <div className="badge">
                  üî• Streak: {streak.current}
                </div>
                <div className="badge">
                  üéÆ Level {level}
                </div>
              </div>
            </div>
            <p style={{color:'var(--ink-light)', marginTop:'-0.5rem', marginBottom:'1.5rem'}}>
              Capture what you learned so each session builds on the last.
            </p>

            <div className="grid grid-cols-2" style={{gap:'1.5rem'}}>
              {/* Left: entry form */}
              <div>
                <h3>Log today's session</h3>
                <p style={{fontSize:'0.9rem', color:'var(--ink-light)', marginBottom:'1rem'}}>
                  Use short, honest notes‚Äîfuture-you will thank you tomorrow.
                </p>

                <form onSubmit={handleSubmit} style={{display:'flex', flexDirection:'column', gap:'1rem'}}>
                  <div>
                    <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                      Module
                    </label>
                    <select
                      style={{
                        width:'100%',
                        padding:'0.65rem',
                        borderRadius:'8px',
                        border:'2px solid var(--border)',
                        background:'var(--card)',
                        color:'var(--ink)',
                        fontSize:'0.95rem'
                      }}
                      value={moduleValue}
                      onChange={e => setModuleValue(e.target.value)}
                    >
                      {moduleOptions.map(opt => (
                        <option key={opt.value} value={opt.value}>
                          {opt.label}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                      Main focus
                    </label>
                    <input
                      style={{
                        width:'100%',
                        padding:'0.65rem',
                        borderRadius:'8px',
                        border:'2px solid var(--border)',
                        background:'var(--card)',
                        color:'var(--ink)',
                        fontSize:'0.95rem'
                      }}
                      type="text"
                      placeholder="e.g. clean 6ths in 2nd position"
                      value={focus}
                      onChange={e => setFocus(e.target.value)}
                    />
                  </div>

                  <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:'1rem'}}>
                    <div>
                      <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Biggest win(s)
                      </label>
                      <textarea
                        style={{
                          width:'100%',
                          padding:'0.65rem',
                          borderRadius:'8px',
                          border:'2px solid var(--border)',
                          background:'var(--card)',
                          color:'var(--ink)',
                          fontSize:'0.95rem',
                          fontFamily:'inherit',
                          resize:'vertical'
                        }}
                        rows={3}
                        placeholder="What went well today?"
                        value={wins}
                        onChange={e => setWins(e.target.value)}
                      />
                    </div>
                    <div>
                      <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Challenge(s)
                      </label>
                      <textarea
                        style={{
                          width:'100%',
                          padding:'0.65rem',
                          borderRadius:'8px',
                          border:'2px solid var(--border)',
                          background:'var(--card)',
                          color:'var(--ink)',
                          fontSize:'0.95rem',
                          fontFamily:'inherit',
                          resize:'vertical'
                        }}
                        rows={3}
                        placeholder="What felt hard?"
                        value={challenges}
                        onChange={e => setChallenges(e.target.value)}
                      />
                    </div>
                  </div>

                  <div>
                    <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                      Next tiny step
                    </label>
                    <textarea
                      style={{
                        width:'100%',
                        padding:'0.65rem',
                        borderRadius:'8px',
                        border:'2px solid var(--border)',
                        background:'var(--card)',
                        color:'var(--ink)',
                        fontSize:'0.95rem',
                        fontFamily:'inherit',
                        resize:'vertical'
                      }}
                      rows={3}
                      placeholder="One small thing to improve next time."
                      value={nextSteps}
                      onChange={e => setNextSteps(e.target.value)}
                    />
                  </div>

                  <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:'1rem'}}>
                    <div>
                      <span style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Mood
                      </span>
                      <div style={{display:'flex', flexWrap:'wrap', gap:'0.5rem'}}>
                        {[
                          { value: 'energized', label: '‚ö° Energized' },
                          { value: 'focused', label: 'üéØ Focused' },
                          { value: 'tired', label: 'üò¥ Tired' },
                          { value: 'frustrated', label: 'üòï Frustrated' },
                          { value: 'proud', label: 'üèÜ Proud' }
                        ].map(m => (
                          <button
                            key={m.value}
                            type="button"
                            className="badge"
                            style={{
                              cursor:'pointer',
                              background: mood === m.value ? 'var(--accent)' : 'var(--neutral)',
                              border: mood === m.value ? '2px solid var(--accent-light)' : '2px solid transparent'
                            }}
                            onClick={() => setMood(m.value)}
                          >
                            {m.label}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <span style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                        Quick templates
                      </span>
                      <div style={{display:'flex', flexWrap:'wrap', gap:'0.5rem'}}>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('interval')}
                        >
                          üé∂ Interval
                        </button>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('rhythm')}
                        >
                          ü•Å Rhythm
                        </button>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('speed')}
                        >
                          ‚ö° Speed
                        </button>
                        <button
                          type="button"
                          className="btn btn-secondary"
                          style={{padding:'0.4rem 0.75rem', fontSize:'0.85rem'}}
                          onClick={() => handleTemplate('bieler')}
                        >
                          üìö Technique
                        </button>
                      </div>
                    </div>
                  </div>

                  <div style={{marginTop:'0.5rem'}}>
                    <button type="submit" className="btn btn-primary btn-large" style={{width:'100%'}}>
                      üíæ Save Reflection
                    </button>
                  </div>
                </form>
              </div>

              {/* Right: history and filters */}
              <div>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'1rem'}}>
                  <h3 style={{margin:0}}>Past Reflections</h3>
                  <button
                    type="button"
                    className="btn btn-secondary"
                    style={{padding:'0.5rem 1rem', fontSize:'0.85rem'}}
                    onClick={clearAll}
                  >
                    üóëÔ∏è Clear all
                  </button>
                </div>
                <p style={{fontSize:'0.9rem', color:'var(--ink-light)', marginBottom:'1rem'}}>
                  Scan your recent notes to remember what you're building on today.
                </p>

                <div style={{marginBottom:'1rem'}}>
                  <label style={{display:'block', fontWeight:600, marginBottom:'0.5rem'}}>
                    Filter by module
                  </label>
                  <select
                    style={{
                      width:'100%',
                      padding:'0.65rem',
                      borderRadius:'8px',
                      border:'2px solid var(--border)',
                      background:'var(--card)',
                      color:'var(--ink)',
                      fontSize:'0.95rem'
                    }}
                    value={filterModule}
                    onChange={e => setFilterModule(e.target.value)}
                  >
                    <option value="all">All modules</option>
                    {moduleOptions.map(opt => (
                      <option key={opt.value} value={opt.value}>
                        {opt.label}
                      </option>
                    ))}
                  </select>
                </div>

                <div style={{maxHeight:'500px', overflowY:'auto'}}>
                  {filteredEntries.length === 0 && (
                    <p style={{
                      textAlign:'center',
                      color:'var(--ink-light)',
                      padding:'2rem 1rem',
                      fontStyle:'italic'
                    }}>
                      No reflections yet. After your next practice session, jot down one win and one next step.
                    </p>
                  )}

                  {filteredEntries.map(entry => {
                    const date = new Date(entry.createdAt);
                    return (
                      <div
                        key={entry.id}
                        style={{
                          padding:'1rem',
                          marginBottom:'0.75rem',
                          border:'1px solid var(--border)',
                          borderRadius:'8px',
                          background:'var(--card)'
                        }}
                      >
                        <div style={{
                          display:'flex',
                          gap:'0.75rem',
                          alignItems:'center',
                          marginBottom:'0.5rem',
                          fontSize:'0.85rem',
                          color:'var(--ink-light)'
                        }}>
                          <span style={{fontWeight:600}}>
                            {date.toLocaleDateString()} ¬∑ {date.toLocaleTimeString([], {
                              hour: '2-digit',
                              minute: '2-digit'
                            })}
                          </span>
                          <span className="badge" style={{fontSize:'0.75rem'}}>
                            {getModuleLabel(entry.module)}
                          </span>
                          {entry.mood && (
                            <span style={{fontSize:'1.2rem'}}>
                              {entry.mood === 'energized' && '‚ö°'}
                              {entry.mood === 'focused' && 'üéØ'}
                              {entry.mood === 'tired' && 'üò¥'}
                              {entry.mood === 'frustrated' && 'üòï'}
                              {entry.mood === 'proud' && 'üèÜ'}
                            </span>
                          )}
                        </div>
                        {entry.focus && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--primary)'}}>Focus:</strong> {entry.focus}
                          </p>
                        )}
                        {entry.wins && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--success)'}}>Wins:</strong> {entry.wins}
                          </p>
                        )}
                        {entry.challenges && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--warning)'}}>Challenges:</strong> {entry.challenges}
                          </p>
                        )}
                        {entry.nextSteps && (
                          <p style={{margin:'0.5rem 0', fontSize:'0.9rem'}}>
                            <strong style={{color:'var(--accent)'}}>Next step:</strong> {entry.nextSteps}
                          </p>
                        )}
                      </div>
                    );
                  })}

                  {mostRecent && (
                    <div style={{
                      background:'linear-gradient(135deg, var(--primary-light), var(--primary))',
                      color:'#fff',
                      padding:'1rem',
                      borderRadius:'12px',
                      marginTop:'1rem'
                    }}>
                      <h3 style={{marginTop:0, color:'#fff'}}>Most recent theme</h3>
                      <p style={{marginBottom:'0.5rem'}}>
                      <strong>
                        {getModuleLabel(mostRecent.module)}:
                      </strong>{' '}
                        {mostRecent.focus || 'No focus recorded.'}
                      </p>
                      {mostRecent.nextSteps && (
                        <p style={{marginBottom:0, fontSize:'0.9rem', opacity:0.95}}>
                          {mostRecent.nextSteps}
                        </p>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    // ============================================================================
    // DAILY QUEST - Interleaved Practice Mode (NEW)
    // ============================================================================
    const QUEST_KEY = 'vmq.v7.dailyQuest';
    const QUEST_DATE_KEY = 'vmq.v7.questDate';
    
    const QUEST_XP_PER_UNIT = {
      speedDrill: 5,
      interval: 7,
      rhythm: 7,
      bieler: 10,
    };
    
    const QUEST_TASK_KEYS = ['speedDrill', 'interval', 'rhythm', 'bieler'];
    
    const makeDefaultQuest = () => ({
      speedDrill: { required: 5, completed: 0 },
      interval:   { required: 3, completed: 0 },
      rhythm:     { required: 2, completed: 0 },
      bieler:     { required: 1, completed: 0 },
      bonusAwarded: false,
    });
    
    function DailyQuest({ prefs, onBack, onStartModule }) {
      // Load or create today's quest
      const [quest, setQuest] = React.useState(() => {
        const today = new Date().toDateString();
        const last = localStorage.getItem(QUEST_DATE_KEY);
    
        if (last === today) {
          const stored = loadJSON(QUEST_KEY, null);
          if (stored && typeof stored === 'object') {
            return stored;
          }
        }
    
        const fresh = makeDefaultQuest();
        saveJSON(QUEST_KEY, fresh);
        localStorage.setItem(QUEST_DATE_KEY, today);
        return fresh;
      });
    
      const { requiredTotal, completedTotal } = React.useMemo(() => {
        let requiredTotal = 0;
        let completedTotal = 0;
    
        QUEST_TASK_KEYS.forEach((key) => {
          const t = quest[key];
          if (!t) return;
          requiredTotal += t.required || 0;
          completedTotal += t.completed || 0;
        });
    
        return { requiredTotal, completedTotal };
      }, [quest]);
    
      const allDone = requiredTotal > 0 && completedTotal >= requiredTotal && !quest.bonusAwarded;
    
      const handleMarkUnitDone = (key) => {
        setQuest((prev) => {
          const task = prev[key];
          if (!task || task.completed >= task.required) return prev;
    
          const prevTotals = QUEST_TASK_KEYS.reduce(
            (acc, k) => {
              const t = prev[k];
              if (!t) return acc;
              acc.required += t.required || 0;
              acc.completed += t.completed || 0;
              return acc;
            },
            { required: 0, completed: 0 }
          );
    
          const updated = {
            ...prev,
            [key]: { ...task, completed: task.completed + 1 }
          };
    
          const xp = Object.prototype.hasOwnProperty.call(QUEST_XP_PER_UNIT, key)
            ? QUEST_XP_PER_UNIT[key]
            : 5;
    
          addXP(xp);
          saveJSON(QUEST_KEY, updated);
    
          const newCompleted = prevTotals.completed + 1;
          const questJustFinished =
            prevTotals.required > 0 &&
            prevTotals.completed < prevTotals.required &&
            newCompleted >= prevTotals.required;
    
          if (questJustFinished && !prev.bonusAwarded) {
            const withBonus = {
              ...updated,
              bonusAwarded: true
            };
            addXP(25);
            saveJSON(QUEST_KEY, withBonus);
            return withBonus;
          }
    
          return updated;
        });
      };
    
      const startTask = (key) => {
        const moduleMap = {
          speedDrill: 'speed',
          interval: 'interval',
          rhythm: 'rhythm',
          bieler: 'bieler'
        };
        
        const labelMap = {
          speedDrill: 'Speed Drill',
          interval: 'Interval Trainer',
          rhythm: 'Rhythm Trainer',
          bieler: 'Bieler Technique Lab',
        };
    
        const moduleKey = moduleMap[key];
        const label = labelMap[key] || 'practice';
    
        if (navigator.vibrate) {
          navigator.vibrate([10, 40, 10]);
        }
    
        speakSR(
          `Starting ${label}. When you finish your practice, come back to Daily Quest and mark one task done.`
        );
    
        if (typeof onStartModule === 'function' && moduleKey) {
          onStartModule(moduleKey);
        }
      };
    
      const tasksMeta = [
        {
          key: 'speedDrill',
          icon: '‚ö°',
          title: 'Speed Drill',
          subtitle: 'Complete 5 speed drill questions',
        },
        {
          key: 'interval',
          icon: 'üé∂',
          title: 'Interval Training',
          subtitle: 'Complete 3 interval recognition tasks',
        },
        {
          key: 'rhythm',
          icon: 'ü•Å',
          title: 'Rhythm Trainer',
          subtitle: 'Complete 2 rhythm patterns',
        },
        {
          key: 'bieler',
          icon: 'üìö',
          title: 'Technique Lab',
          subtitle: 'Complete 1 Bieler Technique micro-session',
        },
      ];
    
      const renderTaskCard = (meta) => {
        const t = quest[meta.key] || { required: 0, completed: 0 };
        const done = t.required > 0 && t.completed >= t.required;
    
        return (
          <div className="card card-compact" key={meta.key}>
            <h3>
              {meta.icon} {meta.title}
            </h3>
            <p style={{color:'var(--ink-light)'}}>{meta.subtitle}</p>
            <p style={{ fontWeight: 600, margin:'0.5rem 0' }}>
              Progress: {t.completed} / {t.required}
            </p>
            <ProgressBar
              current={t.completed}
              max={t.required || 1}
              label={`${t.completed} / ${t.required}`}
            />
            <div style={{ marginTop: '0.75rem', display:'flex', gap:'0.5rem', flexWrap:'wrap' }}>
              <button
                className="btn btn-primary"
                onClick={() => startTask(meta.key)}
              >
                Practice Now
              </button>
              <button
                className="btn btn-secondary"
                onClick={() => handleMarkUnitDone(meta.key)}
                disabled={done}
              >
                ‚úì Mark 1 Done
              </button>
            </div>
          </div>
        );
      };
    
      return (
        <div>
          <div className="card">
            <h2>üìÖ Daily Quest</h2>
            <p style={{color:'var(--ink-light)'}}>Complete today's interleaved practice for bonus XP!</p>
            <p style={{ fontWeight: 600, margin:'1rem 0' }}>
              Overall Progress: {completedTotal} / {requiredTotal} tasks complete
            </p>
            <ProgressBar 
              current={completedTotal} 
              max={requiredTotal} 
              label={`${completedTotal} / ${requiredTotal} tasks`}
            />
            {quest.bonusAwarded && (
              <div style={{ 
                marginTop: '1rem', 
                padding:'1rem',
                background:'var(--success)', 
                color:'#fff',
                borderRadius:'12px',
                fontWeight:600,
                textAlign:'center'
              }}>
                üéâ Quest Complete! Bonus XP awarded!
              </div>
            )}
          </div>
    
          <div className="grid" style={{gap:'1rem', marginTop:'1rem'}}>
            {tasksMeta.map(renderTaskCard)}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack} style={{marginTop:'1rem'}}>
            Back to Menu
          </button>
        </div>
      );
    }
    
    // ============================================================================
    // FINGERBOARD QUIZ - Interactive Board Mode (NEW)
    // ============================================================================

    function FingerboardQuiz({ prefs, onBack }) {
      const cells = React.useMemo(() => filteredCells(prefs), [prefs]);
      const [score, setScore] = React.useState(0);
      const [answered, setAnswered] = React.useState(0);
      const [q, setQ] = React.useState(null);
      const [selected, setSelected] = React.useState(null);
      const [feedback, setFeedback] = React.useState(null);

      const generateQuestion = React.useCallback(() => {
        if (!cells.length) {
          setQ(null);
          return;
        }
      
        const bkt = loadBKT();
      
        // Weighted selection of target using BKT mastery
        const weights = cells.map(c => bktPracticeWeight(bkt, c.s, c.p, c.f));
        const total = weights.reduce((sum, w) => sum + w, 0) || 1;
      
        let r = Math.random() * total;
        let chosen = cells[cells.length - 1];
      
        for (let i = 0; i < cells.length; i++) {
          r -= weights[i];
          if (r <= 0) {
            chosen = cells[i];
            break;
          }
        }
      
        const target = chosen;
        const highlights = [];
      
        // Add 3 distractors (still random, but could also be mastery-aware later)
        const distractors = shuffle(
          cells.filter(c => c.canon !== target.canon)
        ).slice(0, 3);
      
        distractors.forEach(d => {
          highlights.push({ s: d.s, p: d.p, f: d.f, kind: 'distractor' });
        });
      
        setQ({ target, highlights });
        setSelected(null);
        setFeedback(null);
      }, [cells]);

      React.useEffect(() => {
        generateQuestion();
      }, [generateQuestion]);

      const handleSelect = (cell) => {
        if (selected) return;

        const cellKey = `${cell.s}:${cell.p}:${cell.f}`;
        const targetKey = `${q.target.s}:${q.target.p}:${q.target.f}`;
        const ok = cellKey === targetKey;
        
        // Update BKT mastery for this frame
        recordBKTObservation(q.target.s, q.target.p, q.target.f, ok);

        setSelected(cell);
        setAnswered(a => a + 1);

        if (ok) {
          setScore(s => s + 1);
          setFeedback({ type: 'success', message: getRandom(PRAISE_MESSAGES) });
          audioEngine.playFeedback(true);
          vibrate([50]);
          addXP(10);
        } else {
          setFeedback({ 
            type: 'error', 
            message: `${getRandom(ENCOURAGEMENT_MESSAGES)} Correct: ${q.target.s} string, ${ordinal(q.target.p)} pos, finger ${q.target.f}`
          });
          audioEngine.playFeedback(false);
          vibrate([50, 100, 50]);
          addXP(2);
        }

        updateStat(targetKey, ok);

        setTimeout(() => {
          generateQuestion();
        }, ok ? 1000 : 2000);
      };

      if (!cells.length) {
        return (
          <div>
            <div className="card">
              <h2>No Practice Items</h2>
              <p>Please enable at least one string and position in Settings.</p>
            </div>
            <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
          </div>
        );
      }

      if (!q) return null;

      const highlightedCells = [
        ...q.highlights,
        selected ? { 
          s: selected.s, 
          p: selected.p, 
          f: selected.f, 
          kind: `${selected.s}:${selected.p}:${selected.f}` === `${q.target.s}:${q.target.p}:${q.target.f}` ? 'correct' : 'chosen'
        } : null
      ].filter(Boolean);

      return (
        <div>
          <div className="card">
            <h2>üéØ Fingerboard Quiz</h2>

            <div className="stat-card" style={{ margin: '1rem 0' }}>
              <div className="stat-label">Score</div>
              <div className="stat-value" style={{ fontSize: '1.5rem' }}>
                {score} / {answered} {answered > 0 && `(${Math.round((score / answered) * 100)}%)`}
              </div>
            </div>

            <p style={{ fontSize: '1.2rem', fontWeight: 600, textAlign: 'center', marginBottom: '1.5rem' }}>
              Find: <strong style={{ color: 'var(--primary)' }}>{q.target.canon}</strong> on 
              <strong style={{ color: 'var(--primary)' }}> {q.target.s} string</strong>, 
              <strong style={{ color: 'var(--primary)' }}> {ordinal(q.target.p)} position</strong>
            </p>

            <VisualFingerboard
              highlight={highlightedCells}
              onSelect={handleSelect}
              disabled={!!selected}
              showNotes={false}
            />

            {feedback && (
              <div style={{
                marginTop: '1rem',
                padding: '0.75rem',
                borderRadius: '8px',
                background: feedback.type === 'success' ? 'var(--success)' : 'var(--warning)',
                color: '#fff',
                fontWeight: 600,
                textAlign: 'center'
              }}>
                {feedback.message}
              </div>
            )}
          </div>

          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }

    function ProgressScreen({ onBack }) {
      const stats = loadJSON(STATS_KEY, {});
      const xp = loadJSON(XP_KEY, 0);
      const level = levelForXP(xp);
      const nextXP = nextLevelXP(level);
      const currentLevelXP = level > 1 ? nextLevelXP(level - 1) : 0;
      const progressInLevel = xp - currentLevelXP;
      const xpNeeded = nextXP - currentLevelXP;
      const percentToNext = (progressInLevel / xpNeeded) * 100;
      
      const achievements = loadJSON(ACHIEVEMENTS_KEY, []);
      const unlockedAchievements = ACHIEVEMENTS.filter(a => achievements.includes(a.id));
      
      const streak = loadJSON(STREAK_KEY, { current: 0, longest: 0 });
      
      // Calculate accuracy by position and string
      const positionStats = {};
      const stringStats = {};
      
      Object.entries(stats).forEach(([key, st]) => {
        const [s, p, f] = key.split(':');
        const acc = st.total > 0 ? (st.correct / st.total) * 100 : 0;
        
        if (!positionStats[p]) positionStats[p] = { correct: 0, total: 0 };
        positionStats[p].correct += st.correct;
        positionStats[p].total += st.total;
        
        if (!stringStats[s]) stringStats[s] = { correct: 0, total: 0 };
        stringStats[s].correct += st.correct;
        stringStats[s].total += st.total;
      });
      
      // üî• BKT-based mastery grid, string √ó position
      const positionHeat = buildPositionHeat(); // 0‚Äì1 P(know) per [position][string]
      
      const getHeatColor = (acc) => {
        if (acc >= 90) return 'var(--success)';
        if (acc >= 75) return 'var(--primary)';
        if (acc >= 60) return 'var(--warning)';
        return 'var(--danger)';
      };
      
      return (
        <div>
          <div className="card">
            <h2>üìä Your Progress</h2>
            
            <div className="grid grid-cols-3" style={{marginBottom:'1.5rem'}}>
              <div className="stat-card">
                <div className="stat-label">Level</div>
                <div className="stat-value">{level}</div>
              </div>
              <div className="stat-card">
                <div className="stat-label">Total XP</div>
                <div className="stat-value">{xp.toLocaleString()}</div>
              </div>
              <div className="stat-card">
                <div className="stat-label">Streak</div>
                <div className="stat-value">
                  {streak.current > 0 && <span className="streak-fire">üî•</span>}
                  {streak.current}
                </div>
              </div>
            </div>
            
            <ProgressBar
              current={progressInLevel}
              max={xpNeeded}
              label={`Level ${level} Progress`}
            />
            
            <div style={{marginTop:'2rem'}}>
              <h3>üèÜ Achievements ({unlockedAchievements.length} / {ACHIEVEMENTS.length})</h3>
              <div style={{display:'flex', flexWrap:'wrap', gap:'0.5rem', marginTop:'0.75rem'}}>
                {ACHIEVEMENTS.map(ach => {
                  const unlocked = achievements.includes(ach.id);
                  return (
                    <div
                      key={ach.id}
                      className="badge"
                      style={{
                        opacity: unlocked ? 1 : 0.3,
                        background: unlocked ? 'var(--accent)' : 'var(--neutral)'
                      }}
                      title={`${ach.name}: ${ach.desc}`}
                    >
                      {ach.icon} {ach.name}
                    </div>
                  );
                })}
              </div>
            </div>
            
            <div style={{ marginTop: '2rem' }}>
              <h3>üß† Mastery Map (BKT)</h3>
              <p style={{ marginTop: '0.25rem', color: 'var(--ink-light)', fontSize: '0.9rem' }}>
                Average mastery per string and position (0‚Äì100%). Darker green = stronger, red = needs attention.
              </p>
              <div
                style={{
                  marginTop: '0.75rem',
                  overflowX: 'auto',
                }}
              >
                <div
                  className="grid"
                  style={{
                    gridTemplateColumns: `repeat(${POSITIONS.length + 1}, minmax(70px, 1fr))`,
                    gap: '0.25rem',
                    alignItems: 'stretch',
                  }}
                >
                  {/* Header row: empty corner + position labels */}
                  <div style={{ fontWeight: 600, fontSize: '0.85rem' }}></div>
                  {POSITIONS.map(p => (
                    <div
                      key={p}
                      style={{
                        textAlign: 'center',
                        fontWeight: 600,
                        fontSize: '0.85rem',
                        padding: '0.25rem 0',
                      }}
                    >
                      {positionLabelShort(p)}
                    </div>
                  ))}

                  {/* Rows per string */}
                  {VISUAL_STRING_ORDER.map(s => (
                    <React.Fragment key={s}>
                      <div
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          fontWeight: 600,
                          fontSize: '0.9rem',
                        }}
                      >
                        {s} string
                      </div>
                      {POSITIONS.map(p => {
                        const row = positionHeat[p] || {};
                        const v = typeof row[s] === 'number' ? row[s] : 0;   // 0‚Äì1
                        const pct = Math.round(v * 100);
                        const bg = getHeatColor(pct);
                  
                        return (
                          <div
                            key={`${s}-${p}`}
                            className="heat-cell"
                            style={{
                              background: bg,
                              textAlign: 'center',
                              fontSize: '0.8rem',
                              lineHeight: 1.2,
                            }}
                            title={`${s} string, ${positionLabelShort(p)}: ${pct}% mastery`}
                          >
                            {pct}%
                          </div>
                        );
                      })}
                    </React.Fragment>
                  ))}
                </div>
              </div>
            </div>
            
            <div style={{marginTop:'2rem'}}>
              <h3>üìà Accuracy by Position</h3>
              <div className="grid" style={{gridTemplateColumns:'repeat(auto-fit, minmax(100px, 1fr))', gap:'0.5rem', marginTop:'0.75rem'}}>
                {POSITIONS.map(p => {
                  const st = positionStats[p] || { correct: 0, total: 0 };
                  const acc = st.total > 0 ? (st.correct / st.total) * 100 : 0;
                  return (
                    <div
                      key={p}
                       className="heat-cell"
                       title={`${positionLabelShort(p)} Position: ${Math.round(acc)}% (${st.correct}/${st.total})`}
                    >
                       {positionLabelShort(p)}<br />{Math.round(acc)}%
                    </div>
                  );
                })}
              </div>
            </div>
            
            <div style={{marginTop:'2rem'}}>
              <h3>üéª Accuracy by String</h3>
              <div
                className="grid"
                style={{
                  gridTemplateColumns:'repeat(auto-fit, minmax(100px, 1fr))',
                  gap:'0.5rem',
                  marginTop:'0.75rem'
                }}
              >
                {VISUAL_STRING_ORDER.map(s => {
                  const st  = stringStats[s] || { correct: 0, total: 0 };
                  const acc = st.total > 0 ? (st.correct / st.total) * 100 : 0;
                  return (
                    <div
                      key={s}
                      className="heat-cell"
                      style={{background: getHeatColor(acc)}}
                      title={`${s} String: ${Math.round(acc)}% (${st.correct}/${st.total})`}
                    >
                      {s} String<br/>{Math.round(acc)}%
                    </div>
                  );
                })}
              </div>
            </div>
            
            {streak.longest > 0 && (
              <div style={{marginTop:'2rem', textAlign:'center'}}>
                <div className="badge badge-large">
                  üèÜ Longest Streak: {streak.longest} {streak.longest === 1 ? 'day' : 'days'}
                </div>
              </div>
            )}
          </div>
          
          <button className="btn btn-secondary" onClick={onBack}>Back to Menu</button>
        </div>
      );
    }
    
    /*** Position Reference ‚Äì Violin Note Chart by Position
     *
     * Shows a table of notes for each string and finger in the selected position.
     * Layout can be viewed as Strings √ó Fingers or Fingers √ó Strings, and colors
     * can either follow the string tints or the pitch class. Uses the same
     * canonical pitch logic as the trainers so everything stays consistent.
     */
    function PositionReference({ position, onBack }) {
      // If a position prop is provided and valid, use it as the initial position.
      // Otherwise, default to the first entry in POSITIONS.
      const initialPos =
        typeof position === 'number' && POSITIONS.includes(position)
          ? position
          : POSITIONS[0];
    
      const [pos, setPos] = React.useState(initialPos);
      const [layoutCols, setLayoutCols] = React.useState('strings'); // 'strings' | 'fingers'
      const [colorMode, setColorMode]   = React.useState('strings'); // 'strings' | 'notes'
    
      const next = () =>
        setPos(p => (p === POSITIONS[POSITIONS.length - 1] ? POSITIONS[0] : p + 1));
      const prev = () =>
        setPos(p => (p === POSITIONS[0] ? POSITIONS[POSITIONS.length - 1] : p - 1));
    
      // Pitch-class helper for a given string / position / finger
      const pcAt = (s, p, f) =>
        ((OPEN_PC[s] + POS_SHIFT[p] + BASE_OFF[f]) % 12 + 12) % 12;
    
      const ENH = {
        0:  'C',
        1:  'C‚ôØ/D‚ô≠',
        2:  'D',
        3:  'D‚ôØ/E‚ô≠',
        4:  'E',
        5:  'F',
        6:  'F‚ôØ/G‚ô≠',
        7:  'G',
        8:  'G‚ôØ/A‚ô≠',
        9:  'A',
        10: 'A‚ôØ/B‚ô≠',
        11: 'B'
      };
    
      const labelFor = pc => ENH[pc] || NOTE_NAME[pc];
    
      // Color schemes
      const stringTint = {
        E: 'rgba(58,91,160,0.15)',
        A: 'rgba(230,159,0,0.15)',
        D: 'rgba(0,158,115,0.15)',
        G: 'rgba(213,94,0,0.15)'
      };
    
      const noteHue = pc => `hsla(${(pc * 30) % 360}, 65%, 70%, 0.28)`;
      const bgForCell = (s, pc) =>
        colorMode === 'strings' ? stringTint[s] : noteHue(pc);
    
      const cols = layoutCols === 'strings' ? STRINGS : FINGERS;
      const rows = layoutCols === 'strings' ? FINGERS : STRINGS;
    
      // Header labels / aria helpers (using global ordinal helpers)
    
      const colHead = c =>
        layoutCols === 'strings' ? c : `${ordinal(c)} finger`;
      
      const rowHeadVisible = r =>
        layoutCols === 'strings' ? ordinalShort(r) : r;
      
      const rowHeadAria = r =>
        layoutCols === 'strings'
          ? `${ordinal(r)} finger`
          : `${r} string`;
    
      const cellSF = (row, col) =>
        layoutCols === 'strings'
          ? { s: col, f: row }
          : { s: row, f: col };
    
      const CELL_STYLE = {
        height: 56,
        minHeight: 56,
        border: '1px solid var(--border)',
        borderRadius: 10,
        padding: '10px 12px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        textAlign: 'center',
        fontWeight: 600,
        lineHeight: 1.1,
        whiteSpace: 'nowrap'
      };
    
      const HEAD_COL_W = 'clamp(4ch, 9.5vw, 7ch)';
    
      return (
        <div>
          <div className="card">
            <h2>Positions Charts</h2>
    
            {/* Layout & color controls */}
            <div
              className="grid"
              style={{
                gridTemplateColumns: '1fr 1fr',
                gap: '1rem',
                marginBottom: '0.25rem'
              }}
            >
              <div role="radiogroup" aria-label="Layout (columns)">
                <div style={{ fontWeight: 600, marginBottom: 6 }}>Layout</div>
                <OptionButton
                  label="Strings"
                  selected={layoutCols === 'strings'}
                  onClick={() => setLayoutCols('strings')}
                />
                <OptionButton
                  label="Fingers"
                  selected={layoutCols === 'fingers'}
                  onClick={() => setLayoutCols('fingers')}
                />
              </div>
    
              <div role="radiogroup" aria-label="Color mode">
                <div style={{ fontWeight: 600, marginBottom: 6 }}>Colors</div>
                <OptionButton
                  label="Strings"
                  selected={colorMode === 'strings'}
                  onClick={() => setColorMode('strings')}
                />
                <OptionButton
                  label="Notes"
                  selected={colorMode === 'notes'}
                  onClick={() => setColorMode('notes')}
                />
              </div>
            </div>
    
            {/* Position chip */}
            <div
              style={{
                display: 'flex',
                justifyContent: 'center',
                margin: '10px 0 6px'
              }}
            >
              <span
                aria-label={`Notes of ${positionLabelShort(pos)} position`}
                style={{
                  display: 'inline-flex',
                  alignItems: 'center',
                  padding: '0.35rem 0.75rem',
                  borderRadius: 9999,
                  border: '1px solid var(--border)',
                  fontWeight: 700,
                  letterSpacing: '.01em',
                  color: 'var(--ink)',
                  background: 'var(--card)',
                  boxShadow: '0 1px 0 rgba(0,0,0,0.02)'
                }}
              >
                {positionLabelShort(pos)} position
              </span>
            </div>
    
            {/* Note table */}
            <table
              style={{
                width: '100%',
                borderCollapse: 'separate',
                borderSpacing: '8px',
                tableLayout: 'fixed'
              }}
            >
              <thead>
                <tr>
                  <th scope="col" style={{ width: HEAD_COL_W }} />
                  {cols.map(c => (
                    <th
                      scope="col"
                      key={String(c)}
                      style={{ textAlign: 'center', fontWeight: 700 }}
                    >
                      {colHead(c)}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {rows.map(r => (
                  <tr key={String(r)}>
                    <th
                      scope="row"
                      aria-label={rowHeadAria(r)}
                      style={{
                        width: HEAD_COL_W,
                        textAlign: 'right',
                        paddingRight: 8,
                        whiteSpace: 'nowrap',
                        fontWeight: 600
                      }}
                    >
                      {rowHeadVisible(r)}
                    </th>
                    {cols.map(c => {
                      const { s, f } = cellSF(r, c);
                      const pc = pcAt(s, pos, f);
                      return (
                        <td key={`${s}-${f}`} style={{ padding: 0 }}>
                          <div
                            style={{
                              ...CELL_STYLE,
                              background: bgForCell(s, pc)
                            }}
                            title={`${s} string ‚Ä¢ ${ordinal(f)} finger`}
                          >
                            {labelFor(pc)}
                          </div>
                        </td>
                      );
                    })}
                  </tr>
                ))}
              </tbody>
            </table>
    
            {/* Position selector */}
            <div
              className="position-nav"
              role="radiogroup"
              aria-label="Select position"
            >
              {POSITIONS.map((n, idx) => (
                <React.Fragment key={n}>
                  {/* Force a clean visual break between 1st‚Äì5th and 6th‚Äì10th */}
                  {idx === 5 && (
                    <span
                      aria-hidden="true"
                      style={{ flexBasis: '100%', height: 0 }}
                    />
                  )}
                  <OptionButton
                    label={positionLabelShort(n)}
                    selected={pos === n}
                    onClick={() => setPos(n)}
                  />
                </React.Fragment>
              ))}
            </div>
    
            {/* Previous / Next helpers */}
            <div
              style={{
                display: 'flex',
                gap: '.5rem',
                justifyContent: 'center',
                marginTop: '.75rem'
              }}
            >
              <button className="btn btn-secondary" type="button" onClick={prev}>
                ‚Üê Previous
              </button>
              <button className="btn btn-secondary" type="button" onClick={next}>
                Next ‚Üí
              </button>
            </div>
          </div>
    
          <button className="btn btn-secondary" onClick={onBack}>
            Back
          </button>
        </div>
      );
    }

    // ============================================================================
    // ============================================================================
    // SETTINGS SCREEN (Enhanced, with hard position gating)
    // ============================================================================
    
    function Settings({ prefs, setPrefs, onBack }) {
      // Local editable copy of prefs
      const [localPrefs, setLocalPrefs] = React.useState(() => ({ ...prefs }));
    
      // Sound: if prefs.soundEnabled is known, derive mute from that; otherwise fall back to engine.
      const initialMuted =
        typeof prefs.soundEnabled === 'boolean'
          ? !prefs.soundEnabled
          : audioEngine.mute;
      const [muted, setMuted] = React.useState(initialMuted);
    
      // Theme: read current DOM state (window.__setTheme will update it on save)
      const [dark, setDark] = React.useState(
        document.documentElement.classList.contains('dark')
      );
    
      // --- BKT-based mastery & position gating ---------------------------------
    
      // Mastery matrix per string √ó position (0‚Äì1)
      const positionHeat = buildPositionHeat();
    
      // Average mastery over 1st‚Äì5th position (0‚Äì1)
      const baselineMastery = corePositionsMastery(positionHeat);
    
      // Advanced positions (6‚Äì10) unlocked once baselineMastery ‚â• threshold
      const advancedUnlocked = baselineMastery >= POSITION_UNLOCK_THRESHOLD;
    
      const isPositionLocked = p =>
        ADVANCED_POSITIONS.includes(p) && !advancedUnlocked;
    
      // --- Toggle helpers -------------------------------------------------------
    
      const toggleString = s => {
        setLocalPrefs(prev => ({
          ...prev,
          strings: { ...prev.strings, [s]: !prev.strings[s] }
        }));
      };
    
      const togglePosition = p => {
        if (isPositionLocked(p)) return; // guard against clicks on locked chips
        setLocalPrefs(prev => ({
          ...prev,
          positions: { ...prev.positions, [p]: !prev.positions[p] }
        }));
      };
    
      const toggleHaptic = () => {
        setLocalPrefs(prev => ({
          ...prev,
          hapticEnabled: !prev.hapticEnabled
        }));
      };
    
      // --- Save / reset logic ---------------------------------------------------
    
      const save = () => {
        // Keep prefs.soundEnabled, audioEngine.mute, and UI checkbox aligned
        const nextPrefs = {
          ...localPrefs,
          soundEnabled: !muted
        };
    
        setPrefs(nextPrefs);
        saveJSON(PREFS_KEY, nextPrefs);
    
        audioEngine.setMute(muted);
        window.__setTheme(dark);
    
        // Achievement: "all_positions" ‚Äì only award if user has enabled AND practiced all positions
        const allEnabled = POSITIONS.every(p => nextPrefs.positions[p]);
        if (allEnabled) {
          const stats = loadJSON(STATS_KEY, {});
          const practicedAll = POSITIONS.every(p =>
            Object.keys(stats).some(key => {
              // stats keys are like "G:1:1" (string:position:finger)
              const parts = key.split(':');
              const pos = Number(parts[1]);
              return pos === p;
            })
          );
          if (practicedAll) {
            checkAchievement('all_positions');
          }
        }
    
        onBack();
      };
    
      const resetProgress = () => {
        if (
          confirm(
            'Are you sure you want to reset ALL progress? This cannot be undone!'
          )
        ) {
          localStorage.removeItem(XP_KEY);
          localStorage.removeItem(STATS_KEY);
          localStorage.removeItem(ACHIEVEMENTS_KEY);
          localStorage.removeItem(STREAK_KEY);
          localStorage.removeItem(FLASH_KEY);
          alert('Progress reset! Reloading...');
          window.location.reload();
        }
      };
    
      // --- Render ---------------------------------------------------------------
    
      return (
        <div className="card">
          <h2>‚öôÔ∏è Settings</h2>
    
          {/* Practice Strings */}
          <section style={{ marginTop: '1.5rem' }}>
            <h3>üéª Practice strings</h3>
            <p className="muted" style={{ marginTop: 4 }}>
              Only the strings selected here will appear in drills and quizzes.
            </p>
            <div
              className="chip-row"
              style={{ marginTop: '0.75rem', flexWrap: 'wrap', gap: '0.5rem' }}
            >
              {STRINGS.map(s => (
                <OptionButton
                  key={s}
                  label={`${s} string`}
                  selected={!!localPrefs.strings[s]}
                  onClick={() => toggleString(s)}
                />
              ))}
            </div>
          </section>
    
          {/* Practice Positions */}
          <section style={{ marginTop: '1.5rem' }}>
            <h3>üìç Practice positions</h3>
            <p className="muted" style={{ marginTop: 4 }}>
              Positions 1‚Äì5 are your foundation. Positions 6‚Äì10 unlock once your
              average mastery in 1st‚Äì5th position reaches about{' '}
              {Math.round(POSITION_UNLOCK_THRESHOLD * 100)}%.
            </p>
            <p className="muted" style={{ marginTop: 4 }}>
              Current core mastery:{' '}
              <strong>{Math.round(baselineMastery * 100)}%</strong>
            </p>
    
            <div
              className="chip-row"
              style={{ marginTop: '0.75rem', flexWrap: 'wrap', gap: '0.5rem' }}
            >
              {POSITIONS.map(p => {
                const locked = isPositionLocked(p);
                const active = !!localPrefs.positions[p];
    
                let label = positionLabelShort(p);
                if (locked) label += ' üîí';
    
                return (
                  <OptionButton
                    key={p}
                    label={label}
                    selected={active && !locked}
                    disabled={locked}
                    onClick={() => togglePosition(p)}
                  />
                );
              })}
            </div>
          </section>
    
          {/* Appearance & Sound */}
          <section style={{ marginTop: '1.5rem' }}>
            <h3>üé® Appearance & sound</h3>
            <div
              className="chip-row"
              style={{ marginTop: '0.75rem', flexWrap: 'wrap', gap: '0.5rem' }}
            >
              <OptionButton
                label={dark ? 'Dark mode' : 'Light mode'}
                selected={dark}
                onClick={() => setDark(d => !d)}
              />
              <OptionButton
                label={muted ? 'Sound: Off' : 'Sound: On'}
                selected={!muted}
                onClick={() => setMuted(m => !m)}
              />
              <OptionButton
                label={
                  localPrefs.hapticEnabled ? 'Haptics: On' : 'Haptics: Off'
                }
                selected={!!localPrefs.hapticEnabled}
                onClick={toggleHaptic}
              />
            </div>
          </section>
    
          {/* Danger Zone */}
          <section style={{ marginTop: '1.5rem' }}>
            <h3>‚ö†Ô∏è Danger zone</h3>
            <button
              type="button"
              className="btn btn-danger"
              onClick={resetProgress}
              style={{ marginTop: '0.75rem' }}
            >
              üóëÔ∏è Reset all progress
            </button>
          </section>
    
          {/* Footer Actions */}
          <div
            style={{
              marginTop: '2rem',
              display: 'flex',
              gap: '0.5rem',
              justifyContent: 'flex-end'
            }}
          >
            <button
              type="button"
              className="btn btn-secondary"
              onClick={onBack}
            >
              Cancel
            </button>
            <button
              type="button"
              className="btn btn-primary"
              onClick={save}
            >
              üíæ Save settings
            </button>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // TUTORIAL / ONBOARDING (NEW)
    // ============================================================================
    
    function Tutorial({ onComplete }) {
      const [step, setStep] = React.useState(0);
      
      const steps = [
        {
          title: 'Welcome to Violin Mastery Quest! üéª',
          content: 'This app will help you master the violin fingerboard through fun, adaptive practice. Let\'s take a quick tour!',
          icon: 'üëã'
        },
        {
          title: 'Earn XP & Level Up üìà',
          content: 'Every correct answer earns you experience points (XP). Level up to unlock achievements and track your progress!',
          icon: '‚≠ê'
        },
        {
          title: 'Build Your Streak üî•',
          content: 'Practice daily to build your streak! The longer your streak, the more achievements you\'ll unlock.',
          icon: 'üìÖ'
        },
        {
          title: 'Multiple Learning Modes üéØ',
          content: 'Speed Drill for quick practice, Flashcards for spaced repetition, Interval Training for ear development, and more!',
          icon: 'üéÆ'
        },
        {
          title: 'Adaptive Learning üß†',
          content: 'The app tracks your weak spots and gives you more practice on challenging notes and positions.',
          icon: 'üìä'
        },
        {
          title: 'You\'re Ready! üöÄ',
          content: 'Start with Speed Drill or explore the other modes. Remember: consistent practice is the key to mastery!',
          icon: 'üéâ'
        }
      ];
      
      const currentStep = steps[step];
      
      const next = () => {
        if (step < steps.length - 1) {
          setStep(step + 1);
        } else {
          saveJSON(TUTORIAL_KEY, true);
          onComplete();
        }
      };
      
      const skip = () => {
        saveJSON(TUTORIAL_KEY, true);
        onComplete();
      };
      
      return (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'rgba(0,0,0,0.85)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 9999,
          padding: '1rem'
        }}>
          <div className="card" style={{
            maxWidth: '500px',
            textAlign: 'center',
            animation: 'slideIn 0.4s ease'
          }}>
            <div style={{fontSize: '4rem', marginBottom: '1rem'}}>
              {currentStep.icon}
            </div>
            
            <h2 style={{marginBottom: '1rem'}}>{currentStep.title}</h2>
            
            <p style={{
              fontSize: '1.1rem',
              color: 'var(--ink-light)',
              marginBottom: '2rem',
              lineHeight: '1.6'
            }}>
              {currentStep.content}
            </p>
            
            <div style={{marginBottom: '1rem'}}>
              <ProgressBar
                current={step + 1}
                max={steps.length}
                label={`Step ${step + 1} of ${steps.length}`}
              />
            </div>
            
            <div style={{display: 'flex', gap: '0.5rem', justifyContent: 'center'}}>
              <button className="btn btn-secondary" onClick={skip}>
                Skip Tutorial
              </button>
              <button className="btn btn-primary btn-large" onClick={next}>
                {step < steps.length - 1 ? 'Next ‚Üí' : 'Get Started! üéª'}
              </button>
            </div>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // MAIN APP COMPONENT
    // ============================================================================
    
    function App() {
      const [prefs, setPrefs] = React.useState(() => loadJSON(PREFS_KEY, defaultPrefs));
      const [screen, setScreen] = React.useState('menu');
      const [xp, setXP] = React.useState(() => loadJSON(XP_KEY, 0));
      const [showTutorial, setShowTutorial] = React.useState(() => !loadJSON(TUTORIAL_KEY, false));
      const [achievementToShow, setAchievementToShow] = React.useState(null);
      const [toast, setToast] = React.useState(null);
      
      const level = levelForXP(xp);
      const nextXP = nextLevelXP(level);
      const currentLevelXP = level > 1 ? nextLevelXP(level - 1) : 0;
      const progressInLevel = xp - currentLevelXP;
      const xpNeeded = nextXP - currentLevelXP;
      const percentToNext = (progressInLevel / xpNeeded) * 100;
      
      const streak = React.useMemo(() => updateStreak(), []);
      
      // Refresh XP display
      React.useEffect(() => {
        const interval = setInterval(() => {
          const newXP = loadJSON(XP_KEY, 0);
          if (newXP !== xp) {
            setXP(newXP);
            
            const newLevel = levelForXP(newXP);
            if (newLevel > level) {
              setToast({ message: `üéâ Level ${newLevel} Reached!`, type: 'success' });
              audioEngine.playCelebration();
              vibrate([50, 100, 50, 100, 50]);
              speak(`Congratulations! You reached level ${newLevel}!`);
              
              if (newLevel >= 5 && checkAchievement('level_5')) {
                setTimeout(() => {
                  const ach = ACHIEVEMENTS.find(a => a.id === 'level_5');
                  setAchievementToShow(ach);
                }, 1000);
              }
              if (newLevel >= 10 && checkAchievement('level_10')) {
                setTimeout(() => {
                  const ach = ACHIEVEMENTS.find(a => a.id === 'level_10');
                  setAchievementToShow(ach);
                }, 1000);
              }
            }
          }
        }, 1000);
        
        return () => clearInterval(interval);
      }, [xp, level]);
      
      // Check for first note achievement
      React.useEffect(() => {
        checkAchievement('first_note');
      }, []);
      
      const menuItems = [
        { id: 'quest', label: 'Daily Quest', icon: 'üìÖ', desc: 'Interleaved practice for bonus XP' },
        { id: 'speed', label: 'Speed Drill', icon: '‚ö°', desc: 'Timed note identification practice' },
        { id: 'fingerboard', label: 'Fingerboard Quiz', icon: 'üéØ', desc: 'Click notes on the interactive board' },
        { id: 'flash', label: 'Flashcards', icon: 'üóÇÔ∏è', desc: 'Spaced repetition learning' },
        { id: 'interval', label: 'Interval Training', icon: 'üé∂', desc: 'Develop your musical ear' },
        { id: 'rhythm', label: 'Rhythm Trainer', icon: 'ü•Å', desc: 'Master rhythm patterns' },
        { id: 'bieler', label: 'Technique Lab', icon: 'üìö', desc: 'Violin technique concepts' },
        { id: 'positionRef', label: 'Positions Charts', icon: 'üìñ', desc: 'Reference every note by position on all four strings.' },
        { id: 'reflection', label: 'Reflection Lab', icon: 'üìù', desc: 'Journal your practice insights' },
        { id: 'progress', label: 'Progress', icon: 'üìä', desc: 'View your stats & achievements' },
        { id: 'settings', label: 'Settings', icon: '‚öôÔ∏è', desc: 'Customize your experience' }
      ];
      
      if (showTutorial) {
        return <Tutorial onComplete={() => setShowTutorial(false)} />;
      }
      
      return (
        <div className="container">
          {achievementToShow && (
            <AchievementPopup
              achievement={achievementToShow}
              onClose={() => setAchievementToShow(null)}
            />
          )}
          
          {toast && (
            <Toast
              message={toast.message}
              type={toast.type}
              onClose={() => setToast(null)}
            />
          )}
          
          {screen === 'menu' && (
            <>
              <div className="card" style={{textAlign:'center', marginTop:'1rem'}}>
                <h1>üéª Violin Mastery Quest</h1>
                <p style={{color:'var(--ink-light)', fontSize:'1.1rem', marginTop:'0.5rem'}}>
                  An adaptive learning experience
                </p>
                
                <div className="grid grid-cols-3" style={{marginTop:'1.5rem'}}>
                  <div className="stat-card card-compact">
                    <div className="stat-label">Level</div>
                    <div className="stat-value" style={{fontSize:'1.5rem'}}>{level}</div>
                  </div>
                  <div className="stat-card card-compact">
                    <div className="stat-label">XP</div>
                    <div className="stat-value" style={{fontSize:'1.5rem'}}>{xp.toLocaleString()}</div>
                  </div>
                  <div className="stat-card card-compact">
                    <div className="stat-label">Streak</div>
                    <div className="stat-value" style={{fontSize:'1.5rem'}}>
                      {streak.current > 0 && <span className="streak-fire">üî•</span>}
                      {streak.current}
                    </div>
                  </div>
                </div>
                
                <ProgressBar
                  current={progressInLevel}
                  max={xpNeeded}
                  label={`${progressInLevel} / ${xpNeeded} XP to Level ${level + 1}`}
                />
              </div>
              
              <div className="card">
                <h2>üéÆ Practice Modes</h2>
                <div className="grid grid-cols-2" style={{marginTop:'1rem'}}>
                  {menuItems.map(item => (
                    <button
                      key={item.id}
                      className="card card-compact"
                      onClick={() => setScreen(item.id)}
                      style={{
                        cursor: 'pointer',
                        border: '2px solid var(--border)',
                        textAlign: 'left',
                        transition: 'all 0.2s ease',
                        background: 'var(--card)'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.borderColor = 'var(--primary)';
                        e.currentTarget.style.transform = 'translateY(-4px)';
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.borderColor = 'var(--border)';
                        e.currentTarget.style.transform = 'translateY(0)';
                      }}
                    >
                      <div style={{fontSize:'2rem', marginBottom:'0.5rem'}}>{item.icon}</div>
                      <h3 style={{margin:'0 0 0.25rem 0', color:'var(--ink)'}}>{item.label}</h3>
                      <p style={{margin:0, fontSize:'0.9rem', color:'var(--ink-light)'}}>
                        {item.desc}
                      </p>
                    </button>
                  ))}
                </div>
              </div>
              
              <div style={{textAlign:'center', padding:'1rem', color:'var(--ink-light)'}}>
                <small>
                  üí° Tip: Practice daily to maintain your streak!
                  {streak.current > 0 && ` You're on day ${streak.current}!`}
                </small>
              </div>
            </>
          )}
          
          {screen === 'speed' && (
            <SpeedDrill prefs={prefs} onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'flash' && (
            <Flashcards prefs={prefs} onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'interval' && (
            <IntervalTraining onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'rhythm' && (
            <RhythmTrainer onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'bieler' && (
            <BielerLab onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'reflection' && (
            <PracticeReflectionJournal
              currentModule={screen}
              onBack={() => setScreen('menu')}
            />
          )}

          {screen === 'fingerboard' && (
            <FingerboardQuiz prefs={prefs} onBack={() => setScreen('menu')} />
          )}

          {screen === 'quest' && (
            <DailyQuest
              prefs={prefs}
              onBack={() => setScreen('menu')}
              onStartModule={(moduleKey) => setScreen(moduleKey)}
            />
          )}
          
          {screen === 'positionRef' && (
            <PositionReference onBack={() => setScreen('menu')} />
          )}
          
          {screen === 'progress' && (
            <ProgressScreen onBack={() => setScreen('menu')} />
          )}
      
          {screen === 'settings' && (
            <Settings
              prefs={prefs}
              setPrefs={setPrefs}
              onBack={() => setScreen('menu')}
            />
          )}
        </div>
      );
    }
    
      // ============================================================================
      // RENDER with Enhanced Error Handling and Loading Management
      // ============================================================================
      
      const container = document.getElementById('root');
      const loader = document.getElementById('app-loader');

      if (!container) {
        console.error('Violin Mastery Quest: #root container not found.');
        if (loader) {
          loader.innerHTML = '<div style="color:white;padding:2rem;text-align:center;"><h2>Error</h2><p>#root container not found.</p></div>';
        }
        return;
      }

      if (typeof ReactDOM.createRoot !== 'function') {
        console.error('Violin Mastery Quest: ReactDOM.createRoot not available.');
        container.innerHTML = '<p style="padding:1rem;color:#b91c1c;">Error: This app requires React 18.</p>';
        if (loader) setTimeout(() => loader.classList.add('hidden'), 500);
        return;
      }

      const root = ReactDOM.createRoot(container);
      root.render(<App />);
      
      // Hide loader after successful render
      setTimeout(() => {
        if (loader) {
          loader.classList.add('hidden');
          setTimeout(() => loader.remove(), 500);
        }
      }, 100);
      
      console.log('‚úì Violin Mastery Quest initialized successfully');
      
    } catch (err) {
      console.error('Fatal error:', err);
      const loader = document.getElementById('app-loader');
      if (loader) {
        loader.innerHTML = 
          '<div style="color:white;padding:2rem;text-align:center;">' +
          '<h2>Error</h2>' +
          '<p>' + err.message + '</p>' +
          '<button onclick="location.reload()" style="margin-top:1rem;padding:0.75rem 1.5rem;background:white;color:#764ba2;border:none;border-radius:8px;font-weight:600;cursor:pointer;">Refresh</button>' +
          '</div>';
      }
    }
  }
  
  // Start initialization
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
  } else {
    initializeApp();
  }
  
})();
</script>

<!-- Backup timeout script -->
<script>
setTimeout(() => {
  const loader = document.getElementById('app-loader');
  if (loader && !loader.classList.contains('hidden')) {
    console.warn('Timeout: Force hiding loader');
    loader.classList.add('hidden');
  }
}, 10000);
</script>
</body>
</html>