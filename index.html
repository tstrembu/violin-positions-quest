<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Positions Quest</title>

  <!-- Viewport & Theme -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#6d28d9" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="VPQ" />

  <!-- PWA manifest & icons (GitHub Pages path) -->
  <link rel="manifest" href="/violin-positions-quest/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/violin-positions-quest/icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/violin-positions-quest/icons/icon-192.png" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- Base styles -->
  <style>
    :root {
      --bg: #f3f4f6;
      --card: #ffffff;
      --ink-900: #111827;
      --ink-800: #1f2937;
      --ink-700: #374151;
      --ink-600: #4b5563;
      --ink-500: #6b7280;
      --shadow: 0 10px 20px rgba(0,0,0,0.08);
      --accent: #6d28d9; /* theme accent */
    }
    body.dark {
      --bg: #0b1020;
      --card: #0f172a;
      --ink-900: #e5e7eb;
      --ink-800: #e2e8f0;
      --ink-700: #cbd5e1;
      --ink-600: #94a3b8;
      --ink-500: #64748b;
      --shadow: 0 12px 24px rgba(0,0,0,0.35);
    }
    html, body { height:100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink-900);
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji';
    }
    .card { background: var(--card); box-shadow: var(--shadow); }
    .muted { color: var(--ink-600); }
    .ink700 { color: var(--ink-700); }
    .ink800 { color: var(--ink-800); }
    .linkish { text-decoration: underline; cursor: pointer; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { width:min(680px, 92vw); }
    .pill { border-radius: 9999px; padding: 4px 10px; display:inline-block; font-size:12px; }
    .badge { background:var(--accent); color:white; border-radius:9999px; padding:.25rem .6rem; font-weight:700; font-size:12px; }
    .help-dot { width: 22px; height: 22px; border-radius: 9999px; display:inline-flex; align-items:center; justify-content:center; background:#11182717; color:var(--accent); font-weight:700; }
    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; z-index: 9998; }
    .btn {
      display:inline-flex; align-items:center; justify-content:center;
      padding: .75rem 1.25rem; border-radius: 9999px; color:white; font-weight:700;
      transition: transform .08s ease;
    }
    .btn:active { transform: scale(.98); }
    .btn-purple { background:var(--accent); }
    .btn-blue { background:#2563eb; }
    .btn-green { background:#059669; }
    .btn-gray { background:#4b5563; }
    .btn-rose { background:#e11d48; }
    .btn-amber { background:#d97706; }
    .grid-cards { display:grid; gap: 24px; grid-template-columns: repeat(1, minmax(0,1fr)); }
    @media(min-width:640px){ .grid-cards{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media(min-width:1024px){ .grid-cards{ grid-template-columns: repeat(3, minmax(0,1fr)); } }

    /* micro-animations for answers */
    @keyframes pulseCorrect { from{transform:scale(1)} 50%{transform:scale(1.03)} to{transform:scale(1)} }
    @keyframes pulseWrong   { from{transform:scale(1)} 50%{transform:scale(0.97)} to{transform:scale(1)} }
    .btn-hit.ok   { animation:pulseCorrect .25s ease; box-shadow:0 0 0 3px rgba(16,185,129,.25); }
    .btn-hit.miss { animation:pulseWrong   .25s ease; box-shadow:0 0 0 3px rgba(239,68,68,.25); }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }

    /* A11y live region */
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}
    *, *::before, *::after { box-sizing: border-box; }

    /* ---- Fingerboard heatmap layout (fixed overlap) ---- */
    :root{
      --posw: clamp(160px, 45%, 220px);
    }
    .fb-strip{
      display:flex;
      gap:12px;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      padding-bottom:6px;
      scroll-snap-type:x mandatory;
    }
    .fb-pos{
      flex: 0 0 var(--posw);
      min-width: var(--posw);
      scroll-snap-align: start;
      overflow:hidden;
    }
    .fb-grid{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:6px;
    }
    .fb-tile{
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      line-height: 1.1;
      aspect-ratio: 1 / 1.15;
      padding: 6px 4px;
      min-width: 0;
    }
    .fb-band{
      position: absolute;
      left: 6px; right: 6px; bottom: 6px;
      height: 10px; border-radius: 6px;
    }
    @media (min-width: 1024px){
      .fb-strip{
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 12px;
        overflow: visible;
      }
      .fb-pos{ flex: initial; min-width: 0; }
    }
    @supports not (aspect-ratio: 1){
      .fb-tile { height: 72px; }
    }
    @media (min-width: 768px) and (max-width: 1023px){
      .fb-strip{ flex-wrap: wrap; }
      .fb-pos{ flex: 1 1 calc(50% - 12px); min-width: 0; }
    }

    /* Avatar (simple layered SVG) */
    .avatar { width:56px; height:56px; border-radius:12px; overflow:hidden; border:2px solid rgba(0,0,0,.08); }
    .avatar-wrap { display:flex; align-items:center; gap:10px; }
    .avatar-label { font-size:12px; color:var(--ink-600); }

    /* Add this tiny style so locked options read correctly */
    .pill:disabled { opacity:.5; cursor:not-allowed; }

    /* XP bar */
    .xpbar { height:10px; border-radius:9999px; background:rgba(0,0,0,.1); overflow:hidden; }
    .xpbar-fill { height:100%; background:var(--accent); }
    
    /* Cross-browser polish (safe for Safari/Chrome/Firefox/Edge) */
    html, body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    button, [role="button"] { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    /* Already present: -webkit-overflow-scrolling: touch on scrollers + an aspect-ratio fallback */
  </style>

  <!-- Tailwind (utility helpers only) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode:'class', theme:{ extend:{ fontFamily:{ inter:['Inter','ui-sans-serif','system-ui'] } } } };
  </script>

  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <!-- A11y live region -->
  <div id="sr" aria-live="polite" class="sr-only"></div>

  <!-- App -->
  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect, useMemo, useRef } = React;

    /* =========================================================
       Storage keys
    ========================================================== */
    const THEME_KEY = 'vpq.theme.v1';                   // light | dark
    const THEME_ACCENT_KEY = 'vpq.themeAccent.v1';      // symphony | rockstar | fantasy | lofi
    const BEST_KEY = 'positionsQuest.speed.best';
    const STATS_KEY = 'positionsQuest.speed.stats';
    const PREFS_KEY = 'positionsQuest.prefs';
    const PRESETS_KEY = 'positionsQuest.filterPresets.v1';
    const SESSIONLOG_KEY = 'positionsQuest.sessions.v1';
    const SCORE_KEY = 'positions.scoreboard.v1';
    const BADGES_KEY = 'positions.badges.v1';
    const STREAK_KEY = 'positions.streak.v1';
    const COSMETICS_KEY = 'positions.cosmetics.v1';
    const SM2_KEY = 'sm2.v1';

    const SEYBOLD_KEY = 'seybold.hub.v1';
    const TEMPO_STATS_KEY = 'positionsQuest.tempo.stats.v1';
    const TEMPO_BEST_KEY  = 'positionsQuest.tempo.best.v1';

    // NEW stats keys for added modes
    const HEIGHT_STATS_KEY  = 'positionsQuest.height.stats.v1';
    const LOCATOR_STATS_KEY = 'positionsQuest.locator.stats.v1';
    const SHIFT_STATS_KEY   = 'positionsQuest.shift.stats.v1';
    const HARM_STATS_KEY    = 'positionsQuest.harmonics.stats.v1';

    /* =========================================================
       Theme
    ========================================================== */
    const getTheme = () => (localStorage.getItem(THEME_KEY) || 'light');
    const setTheme = (t) => { localStorage.setItem(THEME_KEY, t); document.body.classList.toggle('dark', t === 'dark'); };
    (function bootTheme(){ setTheme(getTheme()); })();

    const THEMES = {
      symphony: { '--accent':'#6d28d9' },
      rockstar: { '--accent':'#e11d48' },
      fantasy:  { '--accent':'#22d3ee' },
      lofi:     { '--accent':'#10b981' }
    };
    const getAccent = () => localStorage.getItem(THEME_ACCENT_KEY) || 'symphony';
    const applyAccent = (name) => {
      const t = THEMES[name] || THEMES.symphony;
      Object.entries(t).forEach(([k,v])=>document.documentElement.style.setProperty(k, v));
      localStorage.setItem(THEME_ACCENT_KEY, name);
    };
    applyAccent(getAccent());

    /* =========================================================
       Utilities
    ========================================================== */
    const shuffle = (arr) => { const a = [...arr]; for (let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };
    const getRandomItem = (arr) => arr[Math.floor(Math.random()*arr.length)];
    const nowISO = () => new Date().toISOString();

    // ASCII accidental normalizer for display
    const NORM = {'A♭':'Ab','B♭':'Bb','E♭':'Eb','D♭':'Db','G♭':'Gb','C♭':'Cb','C♯':'C#','D♯':'D#','F♯':'F#','G♯':'G#','A♯':'A#'};
    const norm = n => NORM[n] || n;

    // Label helpers
    const ordinal = n => { const x = Number(n);
      const suf = (x%10===1 && x%100!==11) ? 'st'
               : (x%10===2 && x%100!==12) ? 'nd'
               : (x%10===3 && x%100!==13) ? 'rd' : 'th';
      return `${x}${suf}`;
    };
    const posLabel    = p => `${ordinal(p)} Position`;
    const fingerLabel = f => `${ordinal(f)} Finger`;
    const stringLabel = s => `${s} string`;
    const fullLoc     = (s,p,f,withString=true) =>
      withString ? `${posLabel(p)}, ${fingerLabel(f)} on the ${stringLabel(s)}`
                 : `${posLabel(p)}, ${fingerLabel(f)}`;

    /* =========================================================
       Core enums (MUST be defined before use)
    ========================================================== */
    const STRINGS   = ['G','D','A','E'];
    const POSITIONS = [1,2,3,4,5];
    const FINGERS   = [1,2,3,4];

    /* =========================================================
       Fingerboard Data (Positions 1–5, no open strings)
    ========================================================== */
    const NOTES_DATA = {
      G: {
        1: { 1: ['A♭','A'], 2: ['B♭','B'], 3: ['C','C#'], 4: ['D'] },
        2: { 1: ['B♭','B'], 2: ['B','C'],   3: ['C','C#'], 4: ['E♭','E'] },
        3: { 1: ['C','C#'], 2: ['C#','D'],  3: ['E♭','E'], 4: ['F','F#'] },
        4: { 1: ['D','D#'], 2: ['D#','E'],  3: ['E','F'],  4: ['F#','G'] },
        5: { 1: ['E♭','E'], 2: ['F','F#'],  3: ['G','G#'], 4: ['A'] },
      },
      D: {
        1: { 1: ['E♭','E'], 2: ['F','F#'], 3: ['G','G#'], 4: ['A'] },
        2: { 1: ['F','F#'], 2: ['F#','G'], 3: ['A','B♭'], 4: ['B♭','B'] },
        3: { 1: ['G','G#'], 2: ['G#','A'], 3: ['A','B♭'], 4: ['C','C#'] },
        4: { 1: ['A','A#'], 2: ['A#','B'], 3: ['B','C'],  4: ['C#','D'] },
        5: { 1: ['B♭','B'], 2: ['C','C#'], 3: ['D','D#'], 4: ['E'] },
      },
      A: {
        1: { 1: ['B♭','B'], 2: ['C','C#'], 3: ['D','D#'], 4: ['E'] },
        2: { 1: ['C','C#'], 2: ['C#','D'], 3: ['D','D#'], 4: ['F','F#'] },
        3: { 1: ['D','D#'], 2: ['D#','E'], 3: ['F','F#'], 4: ['G','G#'] },
        4: { 1: ['E','F'],  2: ['F','F#'], 3: ['F#','G'], 4: ['G#','A'] },
        5: { 1: ['F','F#'], 2: ['G','G#'], 3: ['A'],      4: ['B♭','B'] },
      },
      E: {
        1: { 1: ['F','F#'], 2: ['G','G#'], 3: ['A','A#'], 4: ['B'] },
        2: { 1: ['G','G#'], 2: ['G#','A'], 3: ['B','C'],  4: ['C','C#'] },
        3: { 1: ['A','A#'], 2: ['A#','B'], 3: ['C','C#'], 4: ['D','D#'] },
        4: { 1: ['B','C'],  2: ['C','C#'], 3: ['C#','D'], 4: ['D#','E'] },
        5: { 1: ['C','C#'], 2: ['D','D#'], 3: ['D#','E'], 4: ['F','F#'] },
      },
    };

    /* =========================================================
       Canonical teacher map (blue dots + allowed L/H variants)
       - Baseline is defined on the A string, then transposed.
       - Conventions:
           1: allow Low-1 (no High-1)
           2: allow Low-2 and High-2
           3: allow High-3 (no Low-3 in closed hand)
           4: allow Low-4; High-4 = extension (optional)
    ========================================================= */
    
    // Simple pitch helpers (12-TET; prefer sharps by default)
    const SEMI = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const FLAT = { 'A#':'Bb','C#':'Db','D#':'Eb','F#':'Gb','G#':'Ab' };
    const toFlat = n => FLAT[n] || n;
    const idx = n => SEMI.indexOf(n.replace('Bb','A#').replace('Db','C#').replace('Eb','D#').replace('Gb','F#').replace('Ab','G#'));
    const up = (note, s) => SEMI[(idx(note) + ((s%12)+12)%12) % 12];
    
    // Where each string sits relative to A (in semitones)
    // Semitone offset from A: E = +7, D = -7, G = -14
    const REL = { A: 0, E: +7, D: -7, G: -14 };
    
    // Baseline on A string (blue dots) for positions 1–5
    // 1st pos: 1=B, 2=C#, 3=D, 4=E    (then shift the whole hand upward)
    const A_BASE = {
      1:{ 1:'B', 2:'C#', 3:'D', 4:'E' },
      2:{ 1:'C#',2:'D',  3:'E', 4:'F#' },
      3:{ 1:'D', 2:'E',  3:'F#',4:'G' },
      4:{ 1:'E', 2:'F#', 3:'G', 4:'A' },
      5:{ 1:'F#',2:'G',  3:'A', 4:'B' },
    };
    
    // Allowed deltas relative to baseline per finger
    // (null means “don’t allow that variant in closed hand”.)
    const VAR = {
      1: { low:-1, base:0, high:null,    extHigh:null, extLow:null },
      2: { low:-1, base:0, high:+1,      extHigh:null, extLow:null },
      3: { low:null, base:0, high:+1,    extHigh:null, extLow:null },
      4: { low:-1,  base:0, high:null,   extHigh:+2,   extLow:null }, // high-4 is an extension (F on A1)
    };
    
    // Build the full canonical map for all strings & positions.
    const buildCanonical = () => {
      const out = { G:{}, D:{}, A:{}, E:{} };
      const strings = ['G','D','A','E'];
      for (const s of strings){
        const shift = REL[s];
        for (const p of [1,2,3,4,5]){
          out[s][p] = {};
          for (const f of [1,2,3,4]){
            const baseOnA = A_BASE[p][f];                  // e.g., 'D'
            const baseHere = up(baseOnA, shift);           // transpose to s
            const v = VAR[f];
            const cell = { base: baseHere };
            if (v.low      != null) cell.low      = up(baseHere, v.low);
            if (v.high     != null) cell.high     = up(baseHere, v.high);
            if (v.extHigh  != null) cell.extHigh  = up(baseHere, v.extHigh);
            if (v.extLow   != null) cell.extLow   = up(baseHere, v.extLow);
            out[s][p][f] = cell;
          }
        }
      }
      return out;
    };
    const CANON = buildCanonical();
    
    // Helper: set of allowed spellings for a cell (testing mode can drop extensions)
    const allowedFor = (s,p,f,{includeExtensions=false, preferFlats=false}={}) => {
      const c = CANON[s]?.[p]?.[f];
      if (!c) return [];
      const vals = [c.low, c.base, c.high, includeExtensions?c.extHigh:null, includeExtensions?c.extLow:null].filter(Boolean);
      return preferFlats ? vals.map(toFlat) : vals;
    };
    
    // Helper: role label (low/base/high/ext) for a given note in a cell
    const roleOf = (s,p,f,note) => {
      const n = note; const c = CANON[s]?.[p]?.[f]; if (!c) return 'natural';
      if (n===c.base) return 'base';
      if (n===c.low)  return 'low';
      if (n===c.high) return 'high';
      if (n===c.extHigh || n===c.extLow) return 'extension';
      return 'outside';
    };
    // Low/High helper
    const fingerHeight = (note, options) => {
      if (!Array.isArray(options)) return 'natural';
      if (options.length <= 1) return 'natural';
      const [low, high] = [options[0], options[options.length-1]];
      if (note === low) return 'low';
      if (note === high) return 'high';
      return 'natural';
    };

    // Simple harmonics set per string
    const HARMONICS = {
      G: { '1/2':['G','octave'], '1/3':['D','oct+5th'], '1/4':['G','2 oct'] },
      D: { '1/2':['D','octave'], '1/3':['A','oct+5th'], '1/4':['D','2 oct'] },
      A: { '1/2':['A','octave'], '1/3':['E','oct+5th'], '1/4':['A','2 oct'] },
      E: { '1/2':['E','octave'], '1/3':['B','oct+5th'], '1/4':['E','2 oct'] },
    };

    // Unique note list
    const ALL_NOTES_UNIQUE = (() => {
      const set = new Set();
      STRINGS.forEach(s => POSITIONS.forEach(p => FINGERS.forEach(f => {
        const cell = NOTES_DATA[s]?.[p]?.[f];
        if (Array.isArray(cell)) cell.forEach(n => set.add(n));
      })));
      return [...set];
    })();

    // Distractors avoiding enharmonic duplicates
    const getRandomDistractors = (correct, count = 3) => {
      const target = norm(correct);
      const pool = ALL_NOTES_UNIQUE.filter(n => norm(n) !== target);
      const picks = []; const seen = new Set([target]);
      while (picks.length < Math.min(count, pool.length)) {
        const n = getRandomItem(pool);
        const k = norm(n);
        if (!seen.has(k)) { seen.add(k); picks.push(n); }
      }
      return picks;
    };

    /* =========================================================
       Prefs & persistence
    ========================================================== */
    const defaultFilters = {
      strings: Object.fromEntries(STRINGS.map(s => [s, true])),
      positions: Object.fromEntries(POSITIONS.map(p => [p, true])),
      fingers: Object.fromEntries(FINGERS.map(f => [f, true])),
    };
    const loadPrefs = () => {
      try {
        const p = JSON.parse(localStorage.getItem(PREFS_KEY));
        return {
          sound: true, confetti: true, adaptive: true, coach: true, coachRetry: true,
          callouts: true, roundLen: 120, goalEnabled: false, goalTarget: 10,
          stringOrder: p?.stringOrder || 'score',                // NEW: 'score' or 'player'
          filters: { ...defaultFilters, ...(p?.filters || {}) }, ...(p || {})
        };
      } catch {
        return {
          sound:true, confetti:true, adaptive:true, coach:true, coachRetry:true,
          callouts:true, roundLen:120, goalEnabled:false, goalTarget:10,
          stringOrder:'score',                                    // NEW default
          filters: defaultFilters
        };
      }
    };
    const savePrefs = (obj) => { try { localStorage.setItem(PREFS_KEY, JSON.stringify(obj)); } catch {} };
    const loadBest = () => { try { return JSON.parse(localStorage.getItem(BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveBest = (obj) => { try { localStorage.setItem(BEST_KEY, JSON.stringify(obj)); } catch {} };
    const loadStats = () => { try { return JSON.parse(localStorage.getItem(STATS_KEY)) || {}; } catch { return {}; } };
    const saveStats = (obj) => { try { localStorage.setItem(STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoStats = () => { try { return JSON.parse(localStorage.getItem(TEMPO_STATS_KEY)) || {}; } catch { return {}; } };
    const saveTempoStats = (obj) => { try { localStorage.setItem(TEMPO_STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoBest = () => { try { return JSON.parse(localStorage.getItem(TEMPO_BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveTempoBest = (obj) => { try { localStorage.setItem(TEMPO_BEST_KEY, JSON.stringify(obj)); } catch {} };
    const loadJSON = (k, fallback={}) => { try { return JSON.parse(localStorage.getItem(k)) || fallback; } catch { return fallback; } };
    const saveJSON = (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };

    /* =========================================================
       Audio & call-outs
    ========================================================== */
    /* =========================================================
   Speech call-outs (safe no-op if disabled or unsupported)
    ========================================================= */
    const useCallouts = (enabled) => {
      const synthRef = React.useRef(null);
      const unlockedRef = React.useRef(false);
    
      // Feature detect once
      React.useEffect(() => {
        synthRef.current = (typeof window !== 'undefined' && 'speechSynthesis' in window)
          ? window.speechSynthesis
          : null;
      }, []);
    
      // iOS/Safari often require a user gesture before audio/tts can play
      React.useEffect(() => {
        const unlock = () => { unlockedRef.current = true; };
        window.addEventListener('pointerdown', unlock, { once: true });
        window.addEventListener('keydown', unlock, { once: true });
        return () => {
          window.removeEventListener('pointerdown', unlock);
          window.removeEventListener('keydown', unlock);
        };
      }, []);
    
      const speak = (text) => {
        if (!enabled || !synthRef.current || !unlockedRef.current || !text) return;
        try {
          const u = new SpeechSynthesisUtterance(String(text));
          // pick an English-ish voice if available
          const voices = synthRef.current.getVoices?.() || [];
          const v = voices.find(v => /en/i.test(v.lang)) || voices[0];
          if (v) u.voice = v;
          u.rate = 1.0; u.pitch = 1.0;
          synthRef.current.cancel(); // stop any previous utterance
          synthRef.current.speak(u);
        } catch { /* no-op */ }
      };
    
      return { speak };
    };
    const useBeeps = (enabled) => {
      const ctxRef = useRef(null);
      const ensureCtx = () => {
        if (!enabled) return null;
        if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
        // Safari/iOS sometimes suspends until a user gesture—resume politely
        if (ctxRef.current?.state === 'suspended') { ctxRef.current.resume().catch(()=>{}); }
        return ctxRef.current;
      };
      const beep = (freq = 880, dur = 0.08, type = 'sine') => {
        const ctx = ensureCtx(); if (!ctx) return;
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = type; o.frequency.value = freq; g.gain.value = 0.08; o.connect(g); g.connect(ctx.destination);
        o.start(); setTimeout(()=>o.stop(), dur*1000);
      };
      return { good: () => beep(1046, 0.09, 'triangle'), bad: () => beep(196, 0.12, 'sawtooth') };
    };

    /* =========================================================
       Evidence-based & visuals helpers
    ========================================================== */
    const wilsonLowerBound = (correct, total, z = 1.96) => {
      if (!total) return 0;
      const p = correct / total;
      const denom = 1 + (z*z)/total;
      const centre = p + (z*z)/(2*total);
      const adj = z * Math.sqrt((p*(1-p) + (z*z)/(4*total)) / total);
      return Math.max(0, (centre - adj) / denom);
    };
    const bandFromLB = (lb) => { if (lb < 0.65) return 'red'; if (lb < 0.85) return 'yellow'; return 'green'; };
    const SWATCH = { red:[239,68,68], yellow:[245,158,11], green:[16,185,129], gray:[120,120,120] };
    const rgba = (rgb, a) => `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
    const stabilityAlpha = (n) => { if (!n) return 0.18; const t = Math.min(1, Math.log10(n + 1) / Math.log10(50)); return 0.35 + 0.65 * t; };
    const evidenceStyle = (st) => {
      const correct = st?.correct || 0, total = st?.total || 0;
      if (!total) { return { bandColor: rgba(SWATCH.gray, 0.45), bg:'transparent', text:'#4b5563', lb:0, acc:0, total }; }
      const lb = wilsonLowerBound(correct, total);
      const band = bandFromLB(lb);
      const alpha = stabilityAlpha(total);
      return { bandColor: rgba(SWATCH[band], alpha), bg:'transparent', text:'#111827', lb, acc: correct/total, total, band };
    };

    /* =========================================================
       XP, Streaks, Levels, Badges (Gamification Core)
    ========================================================== */
    const BASE_XP = 10;
    const streakMultiplier = (streak) => Math.min(2.0, 1 + Math.floor(streak/5)*0.2);
    const xpForEvent = ({type='normal', streak=0}) => {
      const base = (type==='review'?5 : type==='retry'?1 : BASE_XP);
      return Math.round(base * streakMultiplier(streak));
    };
    const levelForXP = (xp)=> Math.floor(Math.pow(xp/120, 0.75))+1;  // fast early levels
    const nextLevelXP = (lvl)=> Math.round(120*Math.pow(lvl, 1.33));

    const loadScoreboard = () => loadJSON(SCORE_KEY, { xp:0, level:1, next: nextLevelXP(1) });
    const saveScoreboard = (obj) => saveJSON(SCORE_KEY, obj);
    const loadStreak = () => loadJSON(STREAK_KEY, { current:0, best:0, lastTimestamp:0 });
    const saveStreak = (obj) => saveJSON(STREAK_KEY, obj);

    const BADGES = [
      {slug:'first-100', name:'First 100', test: s => s.totalCorrect >= 100},
      {slug:'perfect-20', name:'Perfect 20', test: s => s.bestStreak >= 20},
      {slug:'d-string-ace', name:'Master of D String', test: s => {
        const keys = Object.keys(s.byCell || {}).filter(k=>k.startsWith('D:'));
        if (!keys.length) return false;
        return keys.every(k=> { const t=s.byCell[k]; return (t.total||0)>=10 && (t.correct||0)/(t.total||1) >= 0.9; });
      }},
      {slug:'streak-50', name:'Combo 50', test: s => s.bestStreak >= 50},
    ];
    const loadBadges = () => loadJSON(BADGES_KEY, { earned:{} });
    const saveBadges = (b) => saveJSON(BADGES_KEY, b);

    const summarizeStats = (stats) => {
      let total=0, correct=0; const byCell={};
      Object.entries(stats||{}).forEach(([k,v])=>{
        const c=v.correct||0, t=v.total||0; total+=t; correct+=c; byCell[k]={correct:c,total:t};
      });
      const bestStreak = Math.max(loadBest().bestStreak||0, (loadStreak().best||0));
      return { totalAttempts: total, totalCorrect: correct, byCell, bestStreak };
    };

    const checkAwardBadges = () => {
      const summary = summarizeStats(loadStats());
      const bag = loadBadges();
      let changed = false;
      BADGES.forEach(b=>{
        if (!bag.earned[b.slug] && b.test(summary)) { bag.earned[b.slug] = nowISO(); changed = true; }
      });
      if (changed) saveBadges(bag);
      return bag;
    };

    /* =========================================================
       SM-2 Spaced Repetition (Speed Ladder)
    ========================================================== */
    function scheduleSM2(item, quality) { // 0..5
      const MIN_EASE = 1.3;
      if (quality < 3) { item.reps = 0; item.interval = 1; item.lapses=(item.lapses||0)+1; }
      else {
        item.reps = (item.reps||0) + 1;
        if (item.reps === 1) item.interval = 1;
        else if (item.reps === 2) item.interval = 6;
        else item.interval = Math.round(item.interval * (item.ease||2.5));
      }
      item.ease = Math.max(MIN_EASE, (item.ease||2.5) + (0.1 - (5 - quality)*(0.08 + (5 - quality)*0.02)));
      item.due = Date.now() + item.interval * 86400000;
      return item;
    }
    const sm2Update = (key, quality) => {
      const sm2 = loadJSON(SM2_KEY, {});
      const item = sm2[key] || { ease:2.5, interval:0, due:Date.now(), reps:0, lapses:0 };
      sm2[key] = scheduleSM2(item, quality);
      saveJSON(SM2_KEY, sm2);
    };
    const sm2DueKeys = () => {
      const sm2 = loadJSON(SM2_KEY, {});
      const now = Date.now();
      return Object.entries(sm2).filter(([k,v]) => (v?.due||0) <= now).map(([k])=>k);
    };

    /* =========================================================
       Tiny UI atoms
    ========================================================== */
    const Modal = ({ open, onClose, title, children }) => !open ? null : (
      <div className="modal-backdrop" onClick={onClose}>
        <div className="modal card rounded-xl p-5" role="dialog" aria-modal="true" onClick={e=>e.stopPropagation()}>
          <div className="flex items-center justify-between mb-2">
            <div className="text-lg font-bold">{title}</div>
            <button className="btn btn-gray" onClick={onClose}>Close</button>
          </div>
          <div className="muted text-sm leading-relaxed">{children}</div>
        </div>
      </div>
    );

    const CardButton = ({ title, description, onClick, onHelp }) => (
      <div className="card rounded-xl p-5">
        <div className="flex items-start justify-between">
          <div>
            <div className="text-xl font-bold ink800">{title}</div>
            <div className="muted text-sm mt-1">{description}</div>
          </div>
          <button className="help-dot" title="How to play" onClick={onHelp}>?</button>
        </div>
        <div className="mt-4">
          <button className="btn btn-purple" onClick={onClick}>Open</button>
        </div>
      </div>
    );

    const Toast = ({ open, text, action, onAction }) => !open ? null : (
      <div className="toast">
        <div className="card rounded-full px-4 py-2 flex items-center gap-3">
          <span className="ink800">{text}</span>
          {action && <button className="btn btn-amber" onClick={onAction}>{action}</button>}
        </div>
      </div>
    );

    /* =========================================================
       Help text (one-paragraph per card)
    ========================================================== */
    const HELP = {
      speed: "Speed Ladder: you’ll see a prompt like “G string — 2nd Position, 3rd Finger”. Choose the note that fits. Use keys 1–4 to answer fast. The coach re-surfaces weaknesses and (optionally) retries misses. Aim for accuracy first, then speed.",
      cards: "Flashcards: two decks—(A) direct fingerboard hits (what note is at a given string/position/finger?) and (B) locations by note. Press Space to reveal, N/P or arrows to navigate.",
      bingo: "Positions Bingo: a 5×5 practice board with violin tasks. Mark squares as you complete them. The center is FREE. Press R to reshuffle the board.",
      dice: "Dice of Destiny: press Roll for a focused practice challenge. The dice avoids repeats until the set cycles. Copy your challenge to notes if you like.",
      tempoTrainer: "Tempo Trainer: flashcards for Italian tempo terms with optional speech call-outs. Reveal the meaning, then say the feel out loud.",
      tempoTester: "Tempo Tester: timed multiple choice. Press 1–4 to answer. At the end, review your misses and retry just those items. A heat map tracks per-term accuracy.",
      bielerLab: "Bieler Method Lab: progressive study of Ida Bieler’s approach. First build vocabulary, then test conceptual understanding, then apply ideas to musical scenarios and bow/left-hand technique.",
      height: "Finger Height Drill: Low vs High fingers. Prompt: note + standardized string/position/finger wording. Answer Low or High (L/H) to build intonation patterns.",
      locator: "Note Locator: Given a pitch (e.g., Bb), pick a valid location (Nth Position, Nth Finger on a given string). Reinforces multiple locations for the same note.",
      shift: "Shift Coach: Stay on one string. Given start & target notes, choose the most efficient new position/finger (requires a shift).",
      harmonics: "Harmonics Lab: Learn natural harmonic nodes (1/2, 1/3, 1/4) per string with flashcards and quick checks. Great for tone and intonation reference."
    };

    /* =========================================================
       Fingerboard Visual Hint (SVG) — ordered + cell note label
       Works in Safari/Chrome/Firefox/Edge
    ========================================================= */
    // FingerboardHint (final)
    const X_FOR_POS = (p)=> 60 + (p-1)*120;
    const FINGER_OFFSET = {1:15, 2:40, 3:65, 4:90};
    
    const FingerboardHint = ({ active, order='score', labelMode='none', showGuides=true }) => {
      // 'score': E–A–D–G (top→bottom) · 'player': G–D–A–E (top→bottom)
      const rows = order === 'score' ? ['E','A','D','G'] : ['G','D','A','E'];
      const laneY = rows.reduce((acc, s, i) => (acc[s] = 70 + i*60, acc), {});
      const topY = laneY[rows[0]], botY = laneY[rows[rows.length-1]];
      const posLabelY = topY - 26;
    
      const nodeXY = (s,p,f)=>({ x: X_FOR_POS(p)+FINGER_OFFSET[f], y: laneY[s] });
      const isOn = (s,p,f)=> active && active.s===s && active.p===p && active.f===f;
    
      // Labeling policy:
      //  - 'none'   → nothing
      //  - 'range'  → "F–F#"
      //  - 'lh'     → "F–F# (L/H)"
      //  - 'canon'  → canonical base note for that cell
      const cellLabel = (s,p,f) => {
        if (labelMode === 'none') return null;
        const cell = validCell(s,p,f);
        if (!cell || !cell.length) return null;
    
        if (labelMode === 'canon') {
          const base = CANON[s]?.[p]?.[f]?.base;
          return base ? norm(base) : null;
        }
    
        if (labelMode === 'range' || labelMode === 'lh') {
          if (cell.length === 1) return norm(cell[0]);
          const first = norm(cell[0]), last = norm(cell[cell.length-1]);
          return labelMode === 'lh' ? `${first}–${last} (L/H)` : `${first}–${last}`;
        }
        return null;
      };
    
      return (
        <svg width="100%" height="320" viewBox="0 0 700 320" className="mt-4">
          {/* Nut / Bridge landmarks */}
          <text x="50" y={posLabelY-10} fontSize="10" fill="currentColor">Nut</text>
          <text x="650" y={posLabelY-10} fontSize="10" fill="currentColor" textAnchor="end">Bridge</text>
    
          {/* Position labels + dashed guides */}
          {[1,2,3,4,5].map(p => {
            const x = X_FOR_POS(p)+52;
            return (
              <g key={`pos${p}`}>
                <text x={x} y={posLabelY} fontSize="12" fill="currentColor">{p}</text>
                {showGuides && (
                  <line x1={x-37} x2={x-37} y1={posLabelY+16} y2={botY+4}
                        stroke="rgba(0,0,0,.25)" strokeDasharray="4,6" />
                )}
              </g>
            );
          })}
    
          {/* String lanes */}
          {rows.map(s => (
            <g key={s}>
              <text x="10" y={laneY[s]+4} fontSize="12" fill="currentColor">
                {s} {s==='E'?'(high)':s==='G'?'(low)':''}
              </text>
              <line x1="50" x2="670" y1={laneY[s]} y2={laneY[s]} stroke="rgba(0,0,0,.28)" />
              {[1,2,3,4,5].map(p =>
                [1,2,3,4].map(f => {
                  const {x,y}=nodeXY(s,p,f);
                  const on = isOn(s,p,f);
                  const label = on ? cellLabel(s,p,f) : null;
                  return (
                    <g key={`${s}:${p}:${f}`}>
                      <circle cx={x} cy={y} r={on?12:10}
                        fill={on?'var(--accent)':'rgba(255,255,255,.08)'}
                        stroke={on?'white':'rgba(0,0,0,.28)'} strokeWidth={on?2:1}
                        style={on?{filter:'drop-shadow(0 0 8px var(--accent))'}:null}
                      />
                      {label && (
                        <text x={x} y={y-18} fontSize="11" fill="currentColor" textAnchor="middle"
                              style={{fontWeight:600, paintOrder:'stroke', WebkitTextStroke:'4px'}}>
                          {label}
                        </text>
                      )}
                    </g>
                  );
                })
              )}
            </g>
          ))}
        </svg>
      );
    };

    /* =========================================================
       Heatmaps
    ========================================================== */
    const tileColor = (total, acc) => {
      if (!total) return 'rgba(120,120,120,0.18)';
      const hue = 140 * acc, sat = 85, light = 45 + 10 * acc;
      return `hsla(${hue}, ${sat}%, ${light}%, 1)`;
    };

    const AccuracyHeatmap = ({ stats, order='score' }) => {
      const rows = order === 'score' ? ['E','A','D','G'] : ['G','D','A','E'];
      return (
        <div className="card rounded-xl p-4">
          <div className="text-lg font-semibold mb-2">Fingerboard Accuracy</div>
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
            {rows.map(s => (
              <div key={s} className="rounded-lg border overflow-hidden">
                <div className="px-3 py-2 font-semibold" style={{ background: 'rgba(0,0,0,.04)', whiteSpace:'nowrap' }}>
                  {s} string
                </div>
                <div className="p-2">
                  <div className="fb-strip">
                    {POSITIONS.map(p => (
                      <div key={p} className="fb-pos rounded-md border">
                        <div className="fb-grid p-2">
                          {FINGERS.map(f => {
                            const isReal = !!validCell(s, p, f);
                            const k = `${s}:${p}:${f}`;
                            const st = isReal ? (stats[k] || { correct:0, total:0 }) : null;
                            const style = evidenceStyle(st);
                            return (
                              <div
                                key={f}
                                className="fb-tile"
                                title={isReal ? `${fullLoc(s,p,f)} — ${st.correct||0}/${st.total||0} (acc ${st.total?Math.round((st.correct/st.total)*100):0}%; LB ${st.total?Math.round(style.lb*100):0}%)` : 'Not a valid finger/position'}
                                aria-label={isReal ? `${fullLoc(s,p,f)}. ${st.total||0} attempts, ${st.correct||0} correct. Lower bound ${Math.round(style.lb*100)} percent` : 'Invalid cell'}
                                style={{
                                  border: isReal ? '1px solid rgba(0,0,0,0.08)' : '1px dashed rgba(0,0,0,0.20)',
                                  background: 'transparent',
                                  color: isReal ? style.text : '#9ca3af'
                                }}
                              >
                                <div style={{ fontWeight:600 }}>F{f}</div>
                                <div className="text-xs">
                                  {isReal && st.total ? `${Math.round((st.correct/st.total)*100)}%` : '—'}
                                </div>
                                <div className="fb-band" style={{ background: isReal ? style.bandColor : 'rgba(0,0,0,0.08)' }} />
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            ))}
          </div>
    
          <p className="text-xs muted mt-2">
            Legend — <b>Gray:</b> unseen · <span style={{color:'#ef4444',fontWeight:600}}>Red:</span> needs work (<i>LB</i>&lt;65%)
            · <span style={{color:'#f59e0b',fontWeight:600}}>Yellow:</span> developing (65–85%)
            · <span style={{color:'#10b981',fontWeight:600}}>Green:</span> strong (≥85%). Bands use the 95% Wilson lower confidence bound; opacity increases with attempts.
          </p>
        </div>
      );
    };

    const TempoHeatmap = ({ stats, terms }) => (
      <div className="card rounded-xl p-4">
        <div className="text-lg font-semibold mb-2">Tempo Heatmap</div>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
          {terms.map(t => {
            const st = stats[t.it] || { correct:0, total:0 };
            const acc = st.total ? st.correct/st.total : 0;
            const bg = tileColor(st.total, acc);
            return (
              <div key={t.it} className="rounded border p-3" style={{background:bg}} title={`${t.it} — ${st.correct}/${st.total} (${Math.round(acc*100)}%)`}>
                <div className="font-semibold">{t.it}</div>
                <div className="text-xs">{st.total ? `${Math.round(acc*100)}%` : '—'}</div>
              </div>
            );
          })}
        </div>
      </div>
    );

    /* =========================================================
       Tempo data
    ========================================================== */
    const TEMPOS = [
      { it:'Prestissimo', en:'super fast' },
      { it:'Presto',      en:'very fast' },
      { it:'Allegro',     en:'fast/happy' },
      { it:'Allegretto',  en:'medium moving/motion, brisk' },
      { it:'Andante',     en:'walking tempo/speed' },
      { it:'Andantino',   en:'little walking (near Andante)' },
      { it:'Adagio',      en:'slow (majestic), at ease' },
      { it:'Largo',       en:'slow-largeness, broad' },
      { it:'Lento',       en:'very slow' },
    ];

    /* =========================================================
       Bieler Method data
    ========================================================== */
    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1st–2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shifting—moving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibrato—finger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'Détaché', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'Collé', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'Martelé', def:'Accented, stopped stroke—bite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance point—vertical energy, horizontal timing.' },
      { term:'Sautillé', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term:'Nature', def:'Use body’s natural alignments—economy, ease, resonance.' },
      { term:'Nurture', def:'Stepwise training—patterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];

    const BIELER_CONCEPT_QA = [
      { q:'Why does “hand frame” matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautillé?', a:'Spiccato is placed/rebounded; sautillé is natural spring at faster tempi.', wrong:['Spiccato is legato','Sautillé is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];

    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy martelé at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist collé','Firm staccato','Always play sul ponticello'] },
    ];

    /* =========================================================
       Confetti
    ========================================================== */
    const ConfettiBurst = ({ seed }) => {
      const [pieces, setPieces] = useState([]);
      useEffect(() => {
        if (!seed) return;
        const EMOJI = ['✨','🎉','🎊','⭐','💥','🌟'];
        const n = 24;
        const arr = Array.from({ length: n }, (_, i) => ({
          id: i, left: Math.random()*100, rot: (Math.random()*40)-20, delay: Math.random()*100, emoji: EMOJI[Math.floor(Math.random()*EMOJI.length)]
        }));
        setPieces(arr);
        const t = setTimeout(()=>setPieces([]), 900);
        return () => clearTimeout(t);
      }, [seed]);
      if (!pieces.length) return null;
      return (
        <div className="pointer-events-none fixed inset-0 overflow-hidden z-50">
          {pieces.map(p => (
            <span key={p.id} style={{position:'absolute', left:`${p.left}vw`, top:'-10px', transform:`rotate(${p.rot}deg)`, animation:'fall 0.9s ease-in forwards', animationDelay:`${p.delay}ms`, fontSize:'20px' }}>
              {p.emoji}
            </span>
          ))}
          <style>{`@keyframes fall{to{transform:translateY(110vh); opacity:.65;}}`}</style>
        </div>
      );
    };

    /* =========================================================
       Shared helpers for fingerboard
    ========================================================== */
    const validCell = (s,p,f) => Array.isArray(NOTES_DATA[s]?.[p]?.[f]) ? NOTES_DATA[s][p][f] : null;
    const allActualCombos = () => {
      const arr = [];
      for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
        const cell = validCell(s,p,f);
        if (cell) arr.push({ s, p, f, valid: cell });
      }
      return arr;
    };
    const allLocationsForNote = (note) => {
      const spots=[];
      for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
        const cell = validCell(s,p,f);
        if (cell && cell.includes(note)) spots.push({s,p,f});
      }
      return spots;
    };
    const groupLocationsByString = (note) => {
      const by = new Map(STRINGS.map(s=>[s,[]]));
      for (const loc of allLocationsForNote(note)) by.get(loc.s).push(loc);
      const lines = [];
      for (const s of STRINGS){
        const arr = by.get(s).sort((a,b)=>Number(a.p)-Number(b.p)||Number(a.f)-Number(b.f));
        if (arr.length) lines.push(`${s}: ${arr.map(({p,f})=>`${posLabel(p)} (${fingerLabel(f)})`).join(', ')}`);
      }
      return lines.join('  |  ');
    };

    /* =========================================================
       Games
    ========================================================= */
    
    /* ---------- Tempo Trainer (flashcards) ---------- */
    const TempoTrainer = ({ onBack, prefs }) => {
      const [i, setI] = useState(0);
      const [show, setShow] = useState(false);
      const { speak } = useCallouts(prefs.callouts);
    
      useEffect(() => { speak(TEMPOS[i].it); }, [i, speak]);
    
      const next = () => { setShow(false); setI(x => (x + 1) % TEMPOS.length); };
      const prev = () => { setShow(false); setI(x => (x - 1 + TEMPOS.length) % TEMPOS.length); };
    
      useEffect(() => {
        const onKey = (e) => {
          const k = e.key.toLowerCase();
          if (k === ' ') { e.preventDefault(); setShow(true); }
          if (k === 'arrowright' || k === 'n') next();
          if (k === 'arrowleft'  || k === 'p') prev();
          if (k === 'escape') onBack();
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [onBack]);
    
      const card = TEMPOS[i];
    
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-4">Tempo Trainer (Flashcards)</h2>
            <div className="rounded-xl border-2 p-6 text-center">
              <div className="text-xl font-bold">{card.it}</div>
              {show ? (
                <div className="mt-2">
                  <div className="text-green-700 font-semibold">{card.en}</div>
                  <div className="text-xs muted mt-1">Say the feel out loud, then tap Next.</div>
                </div>
              ) : (
                <div className="muted italic">Press Space or tap “Reveal”.</div>
              )}
            </div>
            <div className="flex gap-2 mt-6 justify-center">
              <button className="btn btn-blue" onClick={() => setShow(true)}>Reveal</button>
              <button className="btn btn-gray" onClick={prev}>Previous</button>
              <button className="btn btn-purple" onClick={next}>Next</button>
            </div>
            <div className="text-xs muted mt-3 text-center">Shortcuts: Space, ←/→ or P/N</div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Tempo Tester (MCQ + heatmap + XP) ---------- */
    const TempoTester = ({ onBack, prefs }) => {
      const [best, setBest] = useState(loadTempoBest());
      const [stats, setStats] = useState(loadTempoStats());
      const [timer, setTimer] = useState(prefs.roundLen || 60);
      const [finished, setFinished] = useState(false);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [streak, setStreak] = useState(0);
      const [confettiSeed, setConfettiSeed] = useState(0);
      const [events, setEvents] = useState([]);
      const [q, setQ] = useState(null);
      const { speak } = useCallouts(prefs.callouts);
      const beeps = useBeeps(prefs.sound);
      const optionsRef = useRef([]);
      const hitIdxRef = useRef(-1);
    
      const pickQ = (forced=null) => {
        const correct = forced || getRandomItem(TEMPOS);
        const distractors = shuffle(TEMPOS.filter(t=>t.it!==correct.it)).slice(0,3);
        const options = shuffle([correct.en, ...distractors.map(d=>d.en)]);
        setQ({ it: correct.it, correct: correct.en, options, ts: performance.now() });
        optionsRef.current = options;
        speak(correct.it);
      };
    
      const pushSession = (mode, correct, total) => {
        const log = loadJSON(SESSIONLOG_KEY, []);
        log.push({ mode, date: nowISO(), correct, total });
        saveJSON(SESSIONLOG_KEY, log);
      };
    
      useEffect(()=>{ setTimer(prefs.roundLen || 60); }, [prefs.roundLen]);
      useEffect(()=>{ pickQ(); },[]);
      useEffect(()=>{
        if (finished) return;
        const id = setInterval(()=>setTimer(t=>{
          if (t<=1){
            clearInterval(id); setFinished(true);
            const nb = { bestScore:Math.max(best.bestScore, score), bestStreak:Math.max(best.bestStreak, streak) };
            setBest(nb); saveTempoBest(nb);
            pushSession('tempo', score, answered);
            return 0;
          }
          return t-1;
        }), 1000);
        return ()=>clearInterval(id);
      }, [finished, score, streak, best, answered]);
    
      const bump = (it, ok) => {
        const st = stats[it] || { correct:0, total:0 };
        const next = { ...stats, [it]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveTempoStats(next);
      };
    
      const addXP = (ok) => {
        if (!ok) return;
        const sb = loadScoreboard();
        const add = xpForEvent({type:'tempo', streak});
        const xp = sb.xp + add;
        const level = levelForXP(xp), next = nextLevelXP(level);
        saveScoreboard({ xp, level, next });
      };
    
      const handleAnswer = (choice, idx) => {
        if (finished || !q) return;
        const ok = (choice === q.correct);
        bump(q.it, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setEvents(e => [{ t: Date.now(), it:q.it, chosen:choice, correct:q.correct, ok }, ...e]);
        setAnswered(a=>a+1);
        hitIdxRef.current = idx;
        if (ok){ beeps.good(); setScore(s=>s+1); setStreak(x=>x+1); addXP(true); if (prefs.confetti) setConfettiSeed(x=>x+1); setTimeout(()=>pickQ(), 360); }
        else { beeps.bad(); setStreak(0); setTimeout(()=>pickQ(), 760); }
        setTimeout(()=>{ hitIdxRef.current = -1; }, 280);
      };
    
      useEffect(()=>{
        const onKey=(e)=>{ if(finished) return; const k=e.key.toLowerCase(); if(['1','2','3','4'].includes(k)){ const idx=Number(k)-1; const ch=optionsRef.current?.[idx]; if(ch) handleAnswer(ch, idx); } if(k==='escape') onBack(); };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [finished, q, onBack]);
    
      const endReviewList = useMemo(()=>{
        const misses = [...events].filter(e=>!e.ok).reverse();
        const unique = []; const seen = new Set();
        for (const m of misses){ if(!seen.has(m.it)){ unique.push(m); seen.add(m.it); } }
        return unique;
      }, [events]);
    
      const startReview = () => {
        if (!endReviewList.length) return;
        setFinished(false); setScore(0); setAnswered(0); setStreak(0); setEvents([]);
        pickQ(endReviewList[0] && { it:endReviewList[0].it, en:endReviewList[0].correct });
      };
    
      const reset = () => {
        setFinished(false); setScore(0); setAnswered(0); setStreak(0); setEvents([]); setConfettiSeed(0);
        setTimer(prefs.roundLen || 60); pickQ();
      };
    
      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-2">Tempo Tester (Multiple Choice)</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> · Score: <b>{score}</b> / {answered} · Best: <b>{best.bestScore}</b> · Best streak: <b>{best.bestStreak}</b></div>
            {!finished && q && (
              <>
                <div className="text-center mb-5">
                  <div className="text-xl font-bold">What does <b>{q.it}</b> mean?</div>
                  <div className="text-xs muted mt-1">Press 1–4 to answer fast.</div>
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {q.options.map((opt,i)=>(
                    <button key={i} className={`btn btn-blue ${i===hitIdxRef.current ? 'btn-hit ' + (opt===q.correct?'ok':'miss') : ''}`} title={`Press ${i+1}`} onClick={()=>handleAnswer(opt,i)}>
                      <span className="pill" style={{ background: 'rgba(0,0,0,.15)' }}>{i+1}</span>&nbsp; {opt}
                    </button>
                  ))}
                </div>
              </>
            )}
            {finished && (
              <div className="text-center">
                <div className="text-xl font-semibold">Round over! Final score: {score} / {answered}</div>
                <div className="mt-3">
                  <button className="btn btn-purple mr-2" onClick={reset}>Play Again</button>
                  <button className="btn btn-green" disabled={!endReviewList.length} onClick={startReview}>
                    Review Misses {endReviewList.length ? `(${endReviewList.length})` : ''}
                  </button>
                </div>
              </div>
            )}
          </div>
    
          <div className="w-full mt-6" style={{maxWidth:900}}>
            <TempoHeatmap stats={stats} terms={TEMPOS} />
          </div>
    
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Finger Height Drill (Low/High) ---------- */
    const HeightDrill = ({ onBack, prefs }) => {
      const [q, setQ] = useState(null);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [timer, setTimer] = useState(prefs.roundLen || 60);
      const [stats, setStats] = useState(loadJSON(HEIGHT_STATS_KEY, {}));
      const [confettiSeed, setConfettiSeed] = useState(0);
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);
    
      const combos = useMemo(()=> allActualCombos().filter(c => c.valid.length >= 2),[]);
      // Choose only the extremes in the cell so the question is always Low/High
      const pick = () => {
        const c = getRandomItem(combos);
        const lowNote  = c.valid[0];                          // convention: first is “low”
        const highNote = c.valid[c.valid.length - 1];         // last is “high”
        const flip = Math.random() < 0.5;
        const note  = flip ? lowNote : highNote;
        const label = flip ? 'low' : 'high';
        speak(fullLoc(c.s, c.p, c.f));
        setQ({ ...c, note, label });
      };
      useEffect(()=>{ pick(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => (t <= 1 ? 0 : t-1)), 1000);
        return ()=>clearInterval(id);
      },[]);
    
      const bump = (key, ok) => {
        const st = stats[key] || { low:{correct:0,total:0}, high:{correct:0,total:0}, natural:{correct:0,total:0} };
        const next = { ...stats, [key]: {
          low: { correct: st.low.correct + (ok && q.label==='low'?1:0), total: st.low.total + (q.label==='low'?1:0) },
          high:{ correct: st.high.correct+ (ok && q.label==='high'?1:0), total: st.high.total + (q.label==='high'?1:0) },
          natural:{ correct: st.natural.correct+ (ok && q.label==='natural'?1:0), total: st.natural.total + (q.label==='natural'?1:0) },
        } };
        setStats(next); saveJSON(HEIGHT_STATS_KEY, next);
      };
    
      const answer = (choice) => {
        if (!q || timer===0) return;
        const ok = (choice.toLowerCase() === q.label);
        const key = `${q.s}:${q.p}:${q.f}`;
        bump(key, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setAnswered(a=>a+1);
        if (ok) { beeps.good(); setScore(s=>s+1); if (prefs.confetti) setConfettiSeed(x=>x+1); setTimeout(pick, 350); }
        else { beeps.bad(); setTimeout(pick, 700); }
      };
    
      useEffect(()=>{
        const onKey=(e)=>{ const k=e.key.toLowerCase(); if(k==='l') answer('low'); if(k==='h') answer('high'); if(k==='escape') onBack(); };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [onBack, q, timer]);
    
      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:760}}>
            <h2 className="text-2xl font-bold mb-2">Finger Height Drill (Low / High)</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> · Score: <b>{score}</b> / {answered} · Shortcuts: L / H</div>
            {q && (
              <>
                <div className="text-center mb-3">
                  <div className="text-xl font-bold">To play <b>{norm(q.note)}</b> at <b>{fullLoc(q.s, q.p, q.f)}</b> — is the finger <b>Low</b> or <b>High</b>?</div>
                </div>
                <FingerboardHint
                  active={{ s: q.s, p: q.p, f: q.f }}
                  order={prefs.stringOrder}
                  labelMode="lh"   // or "none" if you prefer no text
                />
                <div className="flex gap-3 justify-center mt-3">
                  <button className="btn btn-blue" onClick={()=>answer('low')}>Low</button>
                  <button className="btn btn-purple" onClick={()=>answer('high')}>High</button>
                </div>
                <div className="text-xs muted mt-4 text-center">Tip: “Low” is the first (flat) value in a cell like [F, F#]; “High” is the sharp.</div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Note Locator (find valid location for a given pitch) ---------- */
    const NoteLocator = ({ onBack, prefs }) => {
      const [q,setQ] = useState(null);
      const [timer,setTimer] = useState(prefs.roundLen || 90);
      const [score,setScore] = useState(0);
      const [answered,setAnswered] = useState(0);
      const [stats, setStats] = useState(loadJSON(LOCATOR_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);
    
      const labelLoc = o => `${fullLoc(o.s, o.p, o.f)}`;
    
      const makeQ = () => {
        const note = getRandomItem(ALL_NOTES_UNIQUE);
        const correctLocs = allLocationsForNote(note);
        if (!correctLocs.length) return makeQ();
        const correct = getRandomItem(correctLocs);
        const wrongPool = allActualCombos().filter(c => {
          const cell = validCell(c.s, c.p, c.f) || [];
          return !cell.includes(note);
        });
        const nearby = wrongPool.filter(c => c.s===correct.s || c.p===correct.p || c.f===correct.f);
        const fillers = nearby.length >= 3 ? nearby : wrongPool;
        const opts = shuffle([{...correct, ok:true}, ...shuffle(fillers)
          .filter(c => !(c.s===correct.s && c.p===correct.p && c.f===correct.f))
          .slice(0,3).map(c => ({...c, ok:false}))]);
        speak(note);
        setQ({ note, opts });
      };
    
      useEffect(()=>{ makeQ(); },[]);
      useEffect(()=>{
        const id = setInterval(()=>setTimer(t => t<=1 ? 0 : t-1), 1000);
        return ()=>clearInterval(id);
      },[]);
    
      const bump = (note, ok) => {
        const st = stats[note] || { correct:0, total:0 };
        const next = { ...stats, [note]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(LOCATOR_STATS_KEY, next);
      };
    
      const answer = (o) => {
        const ok = !!o.ok;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        bump(q.note, ok);
        setAnswered(a=>a+1);
        if (ok) setScore(s=>s+1);
        setTimeout(makeQ, ok?350:700);
      };
    
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:800}}>
            <h2 className="text-2xl font-bold mb-2">Note Locator</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> · Score: <b>{score}</b> / {answered}</div>
            {q && (
              <>
                <div className="text-xl font-bold text-center">Where can you play <b>{norm(q.note)}</b>?</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-4">
                  {q.opts.map((o,i)=>(
                    <button key={i} className="btn btn-blue" onClick={()=>answer(o)}>
                      <span className="pill" style={{background:'rgba(0,0,0,.15)'}}>{i+1}</span>&nbsp; {labelLoc(o)}
                    </button>
                  ))}
                </div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Shift Coach (stay on one string; choose landing pos/finger) ---------- */
    const ShiftCoach = ({ onBack, prefs }) => {
      const [q,setQ] = React.useState(null);
      const [score,setScore] = React.useState(0);
      const [answered,setAnswered] = React.useState(0);
      const [timer,setTimer] = React.useState(prefs.roundLen || 90);
      const [stats, setStats] = React.useState(loadJSON(SHIFT_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);
    
      const locationsForNoteOnString = (note, s) => allLocationsForNote(note).filter(l => l.s === s);
      const samePosExists = (A, B) => A.some(a => B.some(b => a.p===b.p));
      const pathCost = (a, b) => Math.abs(Number(a.p) - Number(b.p));
      const bestPair = (A, B) => {
        let best = null;
        for (const a of A) for (const b of B) {
          const cost = pathCost(a,b);
          if (!best || cost < best.cost) best = {a,b,cost};
        }
        return best;
      };
    
      const makePrompt = () => {
        const s = getRandomItem(STRINGS);
        const n1 = getRandomItem(ALL_NOTES_UNIQUE);
        const n2 = getRandomItem(ALL_NOTES_UNIQUE);
        const A = locationsForNoteOnString(n1, s);
        const B = locationsForNoteOnString(n2, s);
        if (!A.length || !B.length) return makePrompt();
        if (samePosExists(A,B)) return makePrompt();
        const best = bestPair(A,B);
        const start = best.a;
        const correctEnd = best.b;
        const pool = allActualCombos()
          .filter(c => c.s === s)
          .filter(c => !(validCell(c.s, c.p, c.f) || []).includes(n2));
        const opts = [{...correctEnd, ok:true}];
        for (const cand of shuffle(pool)) {
          if (opts.length >= 4) break;
          if (!opts.some(o => o.p===cand.p && o.f===cand.f)) opts.push({...cand, ok:false});
        }
        setQ({ string:s, startNote:n1, targetNote:n2, start, opts: shuffle(opts) });
      };
    
      React.useEffect(()=>{ makePrompt(); },[]);
      React.useEffect(()=>{
        const id = setInterval(()=>setTimer(t => t<=1 ? 0 : t-1), 1000);
        return ()=>clearInterval(id);
      },[]);
    
      const bump = (key, ok) => {
        const st = stats[key] || { correct:0, total:0 };
        const next = { ...stats, [key]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(SHIFT_STATS_KEY, next);
      };
    
      const answer = (o) => {
        const ok = !!o.ok;
        const key = `${q.string}:${q.startNote}->${q.targetNote}`;
        bump(key, ok);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        setAnswered(a=>a+1);
        if (ok) setScore(s=>s+1);
        setTimeout(makePrompt, ok?350:700);
      };
    
      const labelLoc = o => `${fullLoc(q.string, o.p, o.f, false)}`;
    
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:860}}>
            <h2 className="text-2xl font-bold mb-2">Shift Coach</h2>
            <div className="muted text-sm mb-4">
              Stay on one string. Time: <b>{timer}s</b> · Score: <b>{score}</b> / {answered}
            </div>
            {q && (
              <>
                <div className="rounded-md p-4" style={{background:'rgba(0,0,0,.05)'}} aria-live="polite">
                  <div className="font-semibold mb-1">String: <b>{q.string}</b></div>
                  <div className="text-sm">
                    Start at <b>{norm(q.startNote)}</b> → <span className="muted">{fullLoc(q.string, q.start.p, q.start.f, false)}</span>
                  </div>
                  <div className="text-sm">Target note: <b>{norm(q.targetNote)}</b></div>
                </div>
    
                <FingerboardHint
                  active={{ s: q.string, p: q.start.p, f: q.start.f }}
                  order={prefs.stringOrder}
                  labelMode="none"
                />
    
                <div className="text-center text-sm muted mt-2 mb-4">
                  Which <b>position + finger</b> is the best landing spot for the target?
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {q.opts.map((o,i)=>(
                    <button key={i} className="btn btn-blue" onClick={()=>answer(o)}>
                      <span className="pill" style={{background:'rgba(0,0,0,.15)'}}>{i+1}</span>&nbsp; {labelLoc(o)}
                    </button>
                  ))}
                </div>
              </>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* ---------- Harmonics Lab (flashcards + quick quiz) ---------- */
    const HarmonicsLab = ({ onBack, prefs }) => {
      const [mode, setMode] = useState('flash'); // flash | quiz
      const [i, setI] = useState(0);
      const [show, setShow] = useState(false);
      const [stats, setStats] = useState(loadJSON(HARM_STATS_KEY, {}));
      const beeps = useBeeps(prefs.sound);
    
      const deck = useMemo(()=>{
        const cards = [];
        for (const s of STRINGS) {
          for (const ratio of Object.keys(HARMONICS[s])) {
            const [pitch, label] = HARMONICS[s][ratio];
            cards.push({ s, ratio, label, pitch });
          }
        }
        return cards;
      },[]);
    
      const next = () => { setShow(false); setI(x => (x + 1) % deck.length); };
      const prev = () => { setShow(false); setI(x => (x - 1 + deck.length) % deck.length); };
    
      const [q, setQ] = useState(null);
      const makeQ = () => {
        const s = getRandomItem(STRINGS);
        const target = getRandomItem(Object.entries(HARMONICS[s]));
        const correctRatio = target[0];
        const noteName = target[1][0];
        const display = `${s} string — play the ${noteName} harmonic`;
        const ratios = Object.keys(HARMONICS[s]);
        const distracts = shuffle(ratios.filter(r=>r!==correctRatio)).slice(0,3);
        const options = shuffle([correctRatio, ...distracts]).map(r => ({r, ok: r===correctRatio}));
        setQ({ s, note: noteName, display, options });
      };
    
      useEffect(()=>{ if(mode==='quiz') makeQ(); }, [mode]);
    
      const bump = (key, ok) => {
        const st = stats[key] || { correct:0, total:0 };
        const next = { ...stats, [key]: { correct: st.correct + (ok?1:0), total: st.total + 1 } };
        setStats(next); saveJSON(HARM_STATS_KEY, next);
      };
    
      const answer = (opt) => {
        const ok = !!opt.ok;
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        beeps[ok?'good':'bad']();
        const key = `${q.s}:${q.note}`;
        bump(key, ok);
        setTimeout(makeQ, ok?350:700);
      };
    
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:820}}>
            <div className="flex items-center justify-between">
              <h2 className="text-2xl font-bold">Harmonics Lab</h2>
              <div className="flex gap-2">
                <button className={`btn ${mode==='flash'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('flash')}>Flashcards</button>
                <button className={`btn ${mode==='quiz'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('quiz')}>Quick Quiz</button>
              </div>
            </div>
    
            {mode==='flash' && (
              <div className="mt-4">
                <div className="rounded-xl border-2 p-6 text-center">
                  <div className="text-xl font-bold">{deck[i].s} string — Node {deck[i].ratio}</div>
                  {show ? (
                    <div className="mt-2 ink700">
                      <div><b>Pitch:</b> {deck[i].pitch}</div>
                      <div><b>Type:</b> {deck[i].label}</div>
                      <div className="text-xs muted mt-1">Light touch above the node; release pressure for a clear chime.</div>
                    </div>
                  ) : <div className="muted italic">Press Reveal to show details.</div>}
                </div>
                <div className="flex gap-2 mt-4 justify-center">
                  <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
                  <button className="btn btn-gray" onClick={prev}>Previous</button>
                  <button className="btn btn-purple" onClick={next}>Next</button>
                </div>
                <div className="text-xs muted mt-2 text-center">Card {i+1} / {deck.length}</div>
              </div>
            )}
    
            {mode==='quiz' && (
              <div className="mt-4">
                {!q ? <div className="muted">Loading…</div> : (
                  <>
                    <div className="text-lg font-semibold mb-2">Which node ratio produces this harmonic?</div>
                    <div className="rounded-md p-4 mb-3" style={{background:'rgba(0,0,0,.05)'}}>
                      {q.display}
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                      {q.options.map((o,idx)=>(
                        <button key={idx} className="btn btn-blue" onClick={()=>answer(o)}>{o.r}</button>
                      ))}
                    </div>
                  </>
                )}
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Speed Ladder (core fingerboard quiz + SM-2 + XP) ---------- */
    const SpeedLadderGame = ({ onBack, prefs, stats, setStats }) => {
      const allCombos = useMemo(()=>allActualCombos(), []);
      const beeps = useBeeps(prefs.sound);
      const { speak } = useCallouts(prefs.callouts);
      const [question, setQuestion] = useState(null);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [timer, setTimer] = useState(prefs.roundLen || 120);
      const [finished, setFinished] = useState(false);
      const [streak, setStreak] = useState(0);
      const [bestStreak, setBestStreak] = useState(loadBest().bestStreak);
      const [bestScore, setBestScore] = useState(loadBest().bestScore);
      const [confettiSeed, setConfettiSeed] = useState(0);
      const optionsRef = useRef([]);
      const lastMissRef = useRef(null);
      const hitIdxRef = useRef(-1);
      const [microHint, setMicroHint] = useState('');
    
      // SM-2: include some due items
      const dueKeys = sm2DueKeys(); // ['G:2:3:C#', ...]
      const dueCombos = useMemo(()=>{
        const map = new Map(allCombos.map(c=>[`${c.s}:${c.p}:${c.f}`, c]));
        const arr = [];
        for (const k of dueKeys) {
          const [s,p,f,maybeNote] = k.split(':');
          const base = map.get(`${s}:${p}:${f}`);
          if (base) arr.push({ ...base, sm2Key:k, preferredNote: maybeNote });
        }
        return arr;
      }, [allCombos, dueKeys.join('|')]);
    
      const candidates = useMemo(()=>{
        const f = prefs.filters||{};
        const okS = f.strings||{}; const okP = f.positions||{}; const okF = f.fingers||{};
        const sel = allCombos.filter(c => (okS[c.s]!==false) && (okP[c.p]!==false) && (okF[c.f]!==false));
        return sel.length ? sel : allCombos;
      }, [allCombos, prefs.filters]);
    
      const weightedPick = () => {
        if (!prefs.adaptive) return getRandomItem(candidates);
        const entries = candidates.map(c=>{
          const k = `${c.s}:${c.p}:${c.f}`; const st = stats[k]; const total = st?.total ?? 0; const correct = st?.correct ?? 0;
          const acc = total > 0 ? correct/total : 0; const unseenBoost = total===0 ? .6 : 0;
          let weight = .1 + (1-acc) + unseenBoost;
          if (prefs.coach) weight *= 1 + (1-acc);
          return { combo:c, weight: Math.max(.05, weight) };
        });
        if (prefs.coach && prefs.coachRetry && lastMissRef.current){
          const miss = lastMissRef.current;
          const idx = entries.findIndex(e=> e.combo.s===miss.s && e.combo.p===miss.p && e.combo.f===miss.f);
          if (idx>=0) entries[idx].weight*=2.2;
        }
        // Interleave SM-2 due ~40% when available
        if (dueCombos.length && Math.random()<0.4) return getRandomItem(dueCombos);
        const sum = entries.reduce((a,e)=>a+e.weight,0)||1; let r = Math.random()*sum;
        for (const e of entries){ if((r-=e.weight)<=0) return e.combo; }
        return entries[entries.length-1].combo;
      };

      const newQuestion = () => {
        const c = weightedPick();  // pick the next (possibly SM-2 due) combo
        const canonNotes = allowedFor(c.s, c.p, c.f, { includeExtensions: false });
        // Dev-only: verify NOTES_DATA matches the canonical allowed notes
        const auditCanonAgainstNotesData = () => {
          const problems = [];
          for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
            const cell = NOTES_DATA[s]?.[p]?.[f] || [];
            const allow = new Set(allowedFor(s,p,f,{includeExtensions:true}).map(norm));
            for (const n of cell) if (!allow.has(norm(n))) problems.push({ s,p,f,n });
          }
          if (problems.length) console.table(problems);
          else console.log('Canonical audit: all good ✅');
        };
        const correct = getRandomItem(canonNotes);
        const opts = shuffle([correct, ...getRandomDistractors(correct, 3)]);
        optionsRef.current = opts;
        setMicroHint('');
        setQuestion({
          ...c,
          correct,
          options: opts,
          ts: performance.now(),
          sm2Key: `${c.s}:${c.p}:${c.f}:${norm(correct)}`
        });
        speak(fullLoc(c.s, c.p, c.f));
      };
    
      useEffect(()=>{ newQuestion(); }, []);
      useEffect(()=>{
        if (finished) return;
        const id = setInterval(()=>setTimer(t=>{
          if(t<=1){
            clearInterval(id); setFinished(true);
            const bs = Math.max(bestScore, score); const bk = Math.max(bestStreak, streak);
            setBestScore(bs); setBestStreak(bk); saveBest({ bestScore:bs, bestStreak:bk });
            // log session
            const log = loadJSON(SESSIONLOG_KEY, []);
            log.push({ mode:'speed', date: nowISO(), correct: score, total: answered });
            saveJSON(SESSIONLOG_KEY, log);
            checkAwardBadges();
            return 0;
          }
          return t-1;
        }), 1000);
        return ()=>clearInterval(id);
      }, [finished, score, streak, bestScore, bestStreak, answered]);
    
      const addXP = (type, ok) => {
        if (!ok) return;
        const sb = loadScoreboard();
        const add = xpForEvent({type, streak});
        const xp = sb.xp + add;
        const level = levelForXP(xp), next = nextLevelXP(level);
        saveScoreboard({ xp, level, next });
      };
    
      const handleAnswer = (note, idx) => {
        if (finished || !question) return;
        const key = `${question.s}:${question.p}:${question.f}`;
        const prev = stats[key] || { correct:0, total:0 };
        const ok = (note===question.correct);
        const updated = { ...stats, [key]: { correct: prev.correct + (ok?1:0), total: prev.total + 1 } };
        setStats(updated); saveStats(updated);
        document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again';
        setAnswered(a=>a+1);
        hitIdxRef.current = idx;
    
        if (!ok) {
          const label = fingerHeight(question.correct, question.valid);
          setMicroHint(`${norm(question.correct)} = ${label==='natural'?'natural':label} ${fingerLabel(question.f)} in ${posLabel(question.p)} (${question.s})`);
        } else setMicroHint('');
    
        // SM-2
        const speedMs = performance.now() - (question.ts||performance.now());
        const quality = ok ? (speedMs<2000?5:4) : 2;
        sm2Update(question.sm2Key, quality);
    
        if (ok){
          lastMissRef.current=null; beeps.good(); setScore(s=>s+1); setStreak(x=>x+1); addXP('speed', true); if (prefs.confetti) setConfettiSeed(x=>x+1);
          setTimeout(()=>newQuestion(), prefs.coach ? 380 : 550);
        } else {
          lastMissRef.current={ s:question.s, p:question.p, f:question.f, valid:question.valid };
          beeps.bad(); setStreak(0);
          setTimeout(()=>{
            if (prefs.coach && prefs.coachRetry){
              const miss=lastMissRef.current;
              if(miss){
                const c = getRandomItem(miss.valid);
                const opts = shuffle([c, ...getRandomDistractors(c, 3)]);
                optionsRef.current=opts; setQuestion({ ...miss, correct:c, options:opts, ts:performance.now(), sm2Key:`${miss.s}:${miss.p}:${miss.f}:${norm(c)}` }); return;
              }
            }
            newQuestion();
          }, 900);
        }
        setTimeout(()=>{ hitIdxRef.current = -1; }, 280);
      };
    
      useEffect(()=>{
        const onKey=(e)=>{ if(finished) return; const k=e.key.toLowerCase(); if(['1','2','3','4'].includes(k)){ const idx=Number(k)-1; const raw=optionsRef.current?.[idx]; if(raw) handleAnswer(raw, idx); } if(k==='escape') onBack(); };
        window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
      }, [finished, question, onBack]);
    
      const reset = () => { setScore(0); setAnswered(0); setTimer(prefs.roundLen||120); setFinished(false); setStreak(0); setConfettiSeed(0); newQuestion(); };
    
      return (
        <div className="relative p-4 min-h-screen flex flex-col items-center">
          <ConfettiBurst seed={confettiSeed} />
          <div className="card rounded-xl p-8" style={{maxWidth:740, width:'100%'}}>
            <h2 className="text-2xl font-bold mb-2">Speed Ladder</h2>
            <div className="muted text-sm mb-4">Time: <b>{timer}s</b> · Score: <b>{score}</b> / {answered} · Best: <b>{bestScore}</b> · Best streak: <b>{bestStreak}</b></div>
            {!finished && question && (
              <>
                <div className="text-center mb-4">
                  <div className="text-xl font-bold">
                    What note can you play at <b>{fullLoc(question.s, question.p, question.f)}</b>?
                  </div>
                  <div className="text-xs muted mt-1">Press 1–4 to answer fast.</div>
                </div>
                <FingerboardHint
                  active={{s:question.s, p:question.p, f:question.f}}
                  order={prefs.stringOrder}
                  labelMode="none"
                />
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-4">
                  {question.options.map((note, i)=>(
                    <button key={i} className={`btn btn-blue ${i===hitIdxRef.current ? 'btn-hit ' + (note===question.correct?'ok':'miss') : ''}`} title={`Press ${i+1}`} onClick={()=>handleAnswer(note,i)}>
                      <span className="pill" style={{ background: 'rgba(0,0,0,.15)' }}>{i+1}</span>&nbsp; {norm(note)}
                    </button>
                  ))}
                </div>
                {!!microHint && <div className="text-xs mt-3 text-center" style={{color:'#ef4444'}}>{microHint}</div>}
              </>
            )}
            {finished && (
              <div className="text-center">
                <div className="text-xl font-semibold">Round over! Final score: {score} / {answered}</div>
                <button className="btn btn-purple mt-3" onClick={reset}>Play Again</button>
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Flashcards (two decks) ---------- */
    const Flashcards = ({ onBack }) => {
      const [mode, setMode] = useState('A');
      const [i, setI] = useState(0);
      const [show,setShow] = useState(false);
      const deckA = useMemo(()=>{
        const cards=[]; for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
          const cell = validCell(s,p,f);
          if (cell) cards.push({q:`What note(s) at ${fullLoc(s, p, f)}?`, a: cell.map(norm).join(' or ')});
        }
        return cards;
      },[]);
      const uniq = useMemo(()=>[...new Set(ALL_NOTES_UNIQUE)].sort(),[]);
      const deckB = useMemo(()=>uniq.map(n=>({q:`Where can you play ${norm(n)} (Pos 1–5)?`, a:groupLocationsByString(n)})),[uniq]);
      const deck = mode==='A'?deckA:deckB;
      const next=()=>{ setShow(false); setI(x => (x + 1) % deck.length); };
      const prev=()=>{ setShow(false); setI(x => (x - 1 + deck.length) % deck.length); };
      useEffect(()=>{ const onKey=(e)=>{ const k=e.key.toLowerCase(); if(k===' '){e.preventDefault();setShow(true);} if(k==='n'||k==='arrowright') next(); if(k==='p'||k==='arrowleft') prev(); if(k==='escape') onBack(); }; window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); }, [onBack]);
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:760}}>
            <h2 className="text-2xl font-bold mb-4">Flashcards</h2>
            <div className="flex gap-2 mb-3">
              <button className={`btn ${mode==='A'?'btn-purple':'btn-gray'}`} onClick={()=>{setMode('A'); setI(0); setShow(false);}}>Deck A</button>
              <button className={`btn ${mode==='B'?'btn-purple':'btn-gray'}`} onClick={()=>{setMode('B'); setI(0); setShow(false);}}>Deck B</button>
            </div>
            <div className="rounded-xl border-2 p-6 text-center">
              <div className="text-lg font-bold">{deck[i].q}</div>
              {show ? <div className="mt-2 ink700 whitespace-pre-wrap">{deck[i].a}</div> : <div className="muted italic">Press Space or tap “Reveal”.</div>}
            </div>
            <div className="flex gap-2 mt-6 justify-center">
              <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
              <button className="btn btn-gray" onClick={prev}>Previous</button>
              <button className="btn btn-purple" onClick={next}>Next</button>
            </div>
            <div className="text-xs muted mt-3 text-center">Card {i+1} / {deck.length} · Shortcuts: Space, ←/→ or P/N</div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Positions Bingo ---------- */
    const BingoBoard = ({ onBack }) => {
      const base = [
        "Say & play A-string Pos 2 F1–F4 aloud","Upbeat start ×8 bars","Bridge-lane forte ×4 bars","Name all B notes Pos 1–5","Sight-read in Pos 2",
        "G-string Pos 1 quiz","C major in Pos 3 aloud","Find 3 ways to play D","E-string Pos 4 quiz","Slur → up-bow staccato",
        "Name all Cs Pos 1–5","D major in Pos 5 aloud","Echo dynamics on repeat","Perfect fifth resonance check (stopped notes)","A-string Pos 3 quiz",
        "List all F#s Pos 1–5","Gigue pickup (up-bow)","Martelé ×8 bars","Map staff lines → fingers","D-string Pos 4 quiz",
        "Contact-point ladders","Slow spiccato ×8 bars","Tempo flashcards ×20","Record 30s and review"
      ];
      const makeBoard=()=>{ const grid = shuffle(base).slice(0,24); grid.splice(12,0,'FREE'); return grid; };
      const [tiles,setTiles]=useState(makeBoard);
      const [on,setOn]=useState(()=>{ const o={}; tiles.forEach(t=>o[t]= (t==='FREE')); return o; });
      const toggle=(t)=>{ if(t==='FREE') return; setOn(s=>({...s,[t]:!s[t]})); };
      const reset=()=>{ const nx=makeBoard(); setTiles(nx); const o={}; nx.forEach(t=>o[t]=(t==='FREE')); setOn(o); };
      const checked = Object.values(on).filter(Boolean).length;
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-6 w-full" style={{maxWidth:960}}>
            <div className="flex items-center justify-between mb-2">
              <div className="text-2xl font-bold">Positions Bingo</div>
              <button className="btn btn-purple" onClick={reset}>New Board</button>
            </div>
            <div className="muted text-sm mb-2">Checked: {checked}/25 · Center is FREE</div>
            <div className="grid grid-cols-5 gap-2">
              {tiles.map((t,i)=>(
                <button key={i} onClick={()=>toggle(t)}
                  className={`rounded-lg border-2 p-2 h-24 text-xs ${on[t]?'bg-green-500 text-white border-green-700':'bg-gray-200 text-gray-800 border-gray-300'}`}>
                  {t}
                </button>
              ))}
            </div>
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    
    /* ---------- Dice of Destiny ---------- */
    const DiceOfDestinyGame = ({ onBack }) => {
      const poolFull = [
        'Say & play A-string Pos 2 F1–F4 aloud','Upbeat start ×8 bars','Bridge-lane forte ×4 bars','Name all B notes Pos 1–5',
        'Sight-read in Pos 2','G-string Pos 1 quiz','C major in Pos 3 aloud','Find 3 ways to play D','E-string Pos 4 quiz',
        'Slur → up-bow staccato','Name all Cs Pos 1–5','D major in Pos 5 aloud','Echo dynamics on repeat','Perfect fifth resonance check (stopped notes)',
        'A-string Pos 3 quiz','List all F#s Pos 1–5','Gigue pickup (up-bow)','Martelé ×8 bars','Map staff lines → fingers','D-string Pos 4 quiz',
      ];
      const [pool,setPool]=useState(poolFull);
      const [cur,setCur]=useState('');
      const [busy,setBusy]=useState(false);
      const [history,setHistory]=useState([]);
      const roll=()=>{ setBusy(true); setCur('…'); setTimeout(()=>{ const p = pool.length ? pool : poolFull; const pick = getRandomItem(p); setCur(pick); setHistory(h=>[pick,...h].slice(0,6)); setPool(p.filter(x=>x!==pick)); setBusy(false); }, 560); };
      useEffect(()=>{ const onKey=(e)=>{ if(e.key==='Escape') onBack(); if(e.key.toLowerCase()==='r') roll(); }; window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); },[onBack]);
      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-8 w-full" style={{maxWidth:720}}>
            <h2 className="text-2xl font-bold mb-4">Dice of Destiny</h2>
            <button disabled={busy} className="btn btn-green text-xl" onClick={roll}>{busy?'…':'Roll Dice'}</button>
            <div className="rounded-lg p-4 mt-6" style={{ background: 'rgba(0,0,0,.07)' }}>
              <div className="text-sm muted">Your Destiny:</div>
              <div className="text-xl font-bold mt-2">{cur || 'Press Roll to begin!'}</div>
            </div>
            {!!history.length && <div className="mt-4">
              <div className="font-semibold text-sm mb-1">Recent rolls</div>
              <ul className="text-sm">{history.map((h,i)=><li key={i}>• {h}</li>)}</ul>
            </div>}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };
    /* =========================================================
       Bieler Method Lab
    ========================================================== */
    const BielerLab = ({ onBack }) => {
      const [mode,setMode]=useState('vocab');
      const [i,setI]=useState(0); const [show,setShow]=useState(false);
      const next=()=>{ setShow(false); setI((i+1)%BIELER_VOCAB.length); };
      const prev=()=>{ setShow(false); setI((i-1+BIELER_VOCAB.length)%BIELER_VOCAB.length); };

      const makeConceptQ = () => {
        const item = getRandomItem(BIELER_CONCEPT_QA);
        const options = shuffle([item.a, ...shuffle(item.wrong).slice(0,3)]);
        return { prompt:item.q, correct:item.a, options };
      };
      const makeApplyQ = () => {
        const item = getRandomItem(BIELER_APPLY);
        const options = shuffle([item.answer, ...shuffle(item.wrong).slice(0,3)]);
        return { prompt:item.scenario, correct:item.answer, options };
      };
      const [cq,setCq]=useState(makeConceptQ());
      const [aq,setAq]=useState(makeApplyQ());
      const [scoreC,setScoreC]=useState(0), [answeredC,setAnsweredC]=useState(0);
      const [scoreA,setScoreA]=useState(0), [answeredA,setAnsweredA]=useState(0);

      const answerConcept = (opt)=>{ const ok = opt===cq.correct; document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again'; setScoreC(s=>s+(ok?1:0)); setAnsweredC(a=>a+1); setTimeout(()=>setCq(makeConceptQ()), ok?350:700); };
      const answerApply   = (opt)=>{ const ok = opt===aq.correct; document.getElementById('sr').textContent = ok ? 'Correct' : 'Try again'; setScoreA(s=>s+(ok?1:0)); setAnsweredA(a=>a+1); setTimeout(()=>setAq(makeApplyQ()), ok?350:700); };

      useEffect(()=>{ const onKey=(e)=>{ if(e.key==='Escape') onBack(); if(e.key==='ArrowRight'||e.key.toLowerCase()==='n') next(); if(e.key==='ArrowLeft'||e.key.toLowerCase()==='p') prev(); }; window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); },[]);

      return (
        <div className="p-4 min-h-screen flex flex-col items-center">
          <div className="card rounded-xl p-6 w-full" style={{maxWidth:980}}>
            <div className="flex items-center justify-between">
              <h2 className="text-2xl font-bold">Bieler Method Lab</h2>
              <div className="flex gap-2">
                <button className={`btn ${mode==='vocab'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('vocab')}>Vocabulary</button>
                <button className={`btn ${mode==='concept'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('concept')}>Concept Check</button>
                <button className={`btn ${mode==='apply'?'btn-purple':'btn-gray'}`} onClick={()=>setMode('apply')}>Applications</button>
              </div>
            </div>

            {mode==='vocab' && (
              <div className="mt-4">
                <div className="rounded-xl border-2 p-6 text-center">
                  <div className="text-xl font-bold">{BIELER_VOCAB[i].term}</div>
                  {show ? <div className="mt-2 ink700">{BIELER_VOCAB[i].def}</div> : <div className="muted italic">Press Reveal to show definition.</div>}
                </div>
                <div className="flex gap-2 mt-4 justify-center">
                  <button className="btn btn-blue" onClick={()=>setShow(true)}>Reveal</button>
                  <button className="btn btn-gray" onClick={prev}>Previous</button>
                  <button className="btn btn-purple" onClick={next}>Next</button>
                </div>
                <div className="text-xs muted mt-2 text-center">Card {i+1} / {BIELER_VOCAB.length}</div>
              </div>
            )}

            {mode==='concept' && (
              <div className="mt-4">
                <div className="muted text-sm mb-2">Score: {scoreC} / {answeredC}</div>
                <div className="text-lg font-semibold mb-2">{cq.prompt}</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  {cq.options.map((o,idx)=><button key={idx} className="btn btn-blue" onClick={()=>answerConcept(o)}>{o}</button>)}
                </div>
              </div>
            )}

            {mode==='apply' && (
              <div className="mt-4">
                <div className="muted text-sm mb-2">Score: {scoreA} / {answeredA}</div>
                <div className="text-lg font-semibold mb-2">Choose the best practice approach:</div>
                <div className="ink700 mb-3"><i>Scenario: </i>{aq.prompt}</div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  {aq.options.map((o,idx)=><button key={idx} className="btn btn-blue" onClick={()=>answerApply(o)}>{o}</button>)}
                </div>
              </div>
            )}
          </div>
          <button className="btn btn-gray mt-6" onClick={onBack}>Back</button>
        </div>
      );
    };

    /* =========================================================
       Filters & Panels
    ========================================================== */
    const FiltersPanel = ({ prefs, setPrefs, stats, onResetStats, onExportCSV }) => {
      const f = prefs.filters;
      const save = (n) => { setPrefs(n); savePrefs(n); };
      const toggle=(group,key)=>{
        setPrefs(p=>{ const next={...p, filters:{...p.filters, [group]:{...p.filters[group],[key]:!p.filters[group][key]}}}; savePrefs(next); return next; });
      };
      const setAll=(group,val)=>{
        setPrefs(p=>{ const obj=Object.fromEntries(Object.keys(p.filters[group]).map(k=>[k,val])); const next={...p, filters:{...p.filters, [group]:obj}}; savePrefs(next); return next; });
      };
      return (
        <div className="card rounded-xl p-4">
          <div className="flex flex-wrap items-center gap-3 justify-between">
            <div className="text-sm">Round:
              <select className="ml-2 border rounded p-1 text-sm" value={prefs.roundLen}
                      onChange={e=>save({ ...prefs, roundLen:Number(e.target.value) })}>
                {[30,60,90,120,180].map(x=><option key={x} value={x}>{x}s</option>)}
              </select>
            </div>
    
            {/* NEW: View selector (string order) */}
            <div className="flex items-center gap-3">
              <label className="text-sm">
                View:&nbsp;
                <select
                  className="border rounded p-1 text-sm"
                  value={prefs.stringOrder}
                  onChange={e=>save({ ...prefs, stringOrder: e.target.value })}
                  title="String order for diagrams"
                >
                  <option value="score">Score view: E–A–D–G (top→bottom)</option>
                  <option value="player">Player view: G–D–A–E (top→bottom)</option>
                </select>
              </label>
            </div>
    
            <div className="flex flex-wrap gap-3 items-center">
              <label className="text-sm"><input type="checkbox" checked={prefs.adaptive}   onChange={e=>save({ ...prefs, adaptive:e.target.checked })}/> Adaptive</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.coach}      onChange={e=>save({ ...prefs, coach:e.target.checked })}/> Coach</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.coachRetry} onChange={e=>save({ ...prefs, coachRetry:e.target.checked })}/> Retry after miss</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.sound}      onChange={e=>save({ ...prefs, sound:e.target.checked })}/> Sound</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.confetti}   onChange={e=>save({ ...prefs, confetti:e.target.checked })}/> Confetti</label>
              <label className="text-sm"><input type="checkbox" checked={prefs.callouts}   onChange={e=>save({ ...prefs, callouts:e.target.checked })}/> Call-outs</label>
            </div>
    
            <div className="flex gap-2">
              <button className="btn btn-rose"  onClick={onResetStats}>Reset All Stats</button>
              <button className="btn btn-green" onClick={onExportCSV}>Export CSV</button>
            </div>
          </div>
    
          <div className="grid md:grid-cols-3 gap-4 mt-4">
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Strings</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('strings',true)}>All</span> · <span className="linkish" onClick={()=>setAll('strings',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {STRINGS.map(s=>(
                  <button key={s} className={`pill ${f.strings[s]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('strings',s)}>{s}</button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Positions</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('positions',true)}>All</span> · <span className="linkish" onClick={()=>setAll('positions',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {POSITIONS.map(p=>(
                  <button key={p} className={`pill ${f.positions[p]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('positions',p)}>Pos {p}</button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold">Fingers</div>
                <div className="text-xs"><span className="linkish" onClick={()=>setAll('fingers',true)}>All</span> · <span className="linkish" onClick={()=>setAll('fingers',false)}>None</span></div>
              </div>
              <div className="flex flex-wrap gap-2">
                {FINGERS.map(fn=>(
                  <button key={fn} className={`pill ${f.fingers[fn]?'bg-purple-600 text-white':'bg-gray-200'}`} onClick={()=>toggle('fingers',fn)}>F{fn}</button>
                ))}
              </div>
            </div>
          </div>
    
          <p className="text-xs muted mt-3">Focus Mode pulls only from your selected subset (falls back to all if deselected).</p>
        </div>
      );
    };

    /* =========================================================
       Dashboard extras: XP header, Avatar, Weakest 3, Sparkline, Badges
    ========================================================== */
    const AvatarIcon = ({ outfit='classic', trail='none' }) => {
      const outfitFill =
        outfit==='rock' ? '#ef4444' :
        outfit==='fantasy' ? '#22d3ee' :
        '#6d28d9';
      return (
        <svg className="avatar" viewBox="0 0 64 64">
          <rect x="0" y="0" width="64" height="64" rx="12" fill="rgba(0,0,0,0.04)" />
          <circle cx="32" cy="22" r="10" fill="#fed7aa"/>
          <rect x="16" y="34" width="32" height="18" rx="9" fill={outfitFill} />
          {trail==='aurora' && (
            <circle cx="32" cy="54" r="4" fill="var(--accent)">
              <animate attributeName="r" values="4;6;4" dur="1.6s" repeatCount="indefinite" />
            </circle>
          )}
        </svg>
      );
    };
    
    const AvatarCustomizer = () => {
      const [cos, setCos] = useState(
        loadJSON(COSMETICS_KEY, {
          selected: { outfit:'classic', trail:'none' },
          unlocked: { outfits:['classic'], trails:['none'] }
        })
      );
      const save = (nx) => { setCos(nx); saveJSON(COSMETICS_KEY, nx); };
    
      const unlockBag = loadBadges();
    
      // Build a fresh unlocked object (no mutation)
      const computeUnlocked = () => {
        const u = {
          outfits: [...(cos.unlocked?.outfits || ['classic'])],
          trails:  [...(cos.unlocked?.trails  || ['none'])]
        };
        if (unlockBag.earned['first-100']    && !u.outfits.includes('rock'))    u.outfits.push('rock');
        if (unlockBag.earned['d-string-ace'] && !u.outfits.includes('fantasy')) u.outfits.push('fantasy');
        if (unlockBag.earned['perfect-20']   && !u.trails.includes('aurora'))   u.trails.push('aurora');
        return u;
      };
    
      // React when badges (or current unlocked) change
      useEffect(() => {
        const nextUnlocked = computeUnlocked();
        if (JSON.stringify(nextUnlocked) !== JSON.stringify(cos.unlocked)) {
          save({ ...cos, unlocked: nextUnlocked });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [JSON.stringify(unlockBag.earned), JSON.stringify(cos.unlocked)]);
    
      return (
        <div className="card rounded-xl p-4">
          <div className="flex items-center justify-between mb-2">
            <div className="font-semibold">Player Avatar</div>
            <div className="avatar-wrap">
              <AvatarIcon outfit={cos.selected.outfit} trail={cos.selected.trail} />
            </div>
          </div>
    
          <div className="text-xs avatar-label mb-2">
            Customize your look with unlocks from badges.
          </div>
    
          <div className="flex flex-wrap gap-2 items-center">
            {/* Outfits */}
            {['classic','rock','fantasy'].map(o => (
              <button
                key={o}
                disabled={!cos.unlocked.outfits.includes(o)}
                className={`pill ${cos.selected.outfit===o ? 'bg-purple-600 text-white' : 'bg-gray-200'}`}
                onClick={() => save({ ...cos, selected: { ...cos.selected, outfit:o } })}
                title={cos.unlocked.outfits.includes(o) ? `Select ${o}` : 'Locked'}
              >
                {o}
              </button>
            ))}
    
            <span className="text-xs mx-2 muted">Trail:</span>
    
            {/* Trails */}
            {['none','aurora'].map(t => (
              <button
                key={t}
                disabled={!cos.unlocked.trails.includes(t)}
                className={`pill ${cos.selected.trail===t ? 'bg-purple-600 text-white' : 'bg-gray-200'}`}
                onClick={() => save({ ...cos, selected: { ...cos.selected, trail:t } })}
                title={cos.unlocked.trails.includes(t) ? `Select ${t}` : 'Locked'}
              >
                {t}
              </button>
            ))}
          </div>
        </div>
      );
    };

    const Spark = ({points}) => {
      if (!points || !points.length) return <div className="muted text-xs">No sessions yet.</div>;
      const w=240,h=40; const max=Math.max(...points,1);
      const path=points.map((v,i)=>{const x=i*(w/(points.length-1)); const y=h-(v/max)*h; return `${i?'L':'M'}${x},${y}`;}).join(' ');
      return <svg width={w} height={h}><path d={path} fill="none" stroke="currentColor" strokeWidth="2"/></svg>;
    };

    const Dashboard = ({ prefs, setPrefs, stats, setStats, onPlay }) => {
      const onResetStats = () => {
        saveStats({}); setStats({});
        saveTempoStats({}); saveJSON('positionsQuest.height.stats.v1', {});
        saveJSON('positionsQuest.locator.stats.v1', {});
        saveJSON('positionsQuest.shift.stats.v1', {});
        saveJSON('positionsQuest.harmonics.stats.v1', {});
        document.getElementById('sr').textContent = 'All stats reset';
      };
    
      const onExportCSV = () => {
        const rows = [['cell','correct','total','accuracy']];
        Object.entries(loadStats()).forEach(([k,v])=>{
          const acc = v.total ? Math.round(100*v.correct/v.total) : 0;
          rows.push([k, v.correct||0, v.total||0, `${acc}%`]);
        });
        const csv = rows.map(r=>r.join(',')).join('\n');
        const a = document.createElement('a');
        a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
        a.download = 'vpq-stats.csv'; a.click();
      };
    
      return (
        <div className="p-4 max-w-6xl mx-auto">
          <div className="flex items-center justify-between gap-4">
            <div>
              <div className="text-2xl font-bold">Violin Positions Quest</div>
              <div className="text-sm muted">Pick a mode to start training.</div>
            </div>
            <AvatarCustomizer />
          </div>
    
          <div className="mt-4">
            <FiltersPanel
              prefs={prefs}
              setPrefs={setPrefs}
              stats={stats}
              onResetStats={onResetStats}
              onExportCSV={onExportCSV}
            />
          </div>
    
          <div className="grid-cards mt-6">
            <CardButton title="Speed Ladder"   description="Timed note-ID quiz." onClick={()=>onPlay('speed')}           onHelp={()=>{}} />
            <CardButton title="Flashcards"      description="Two decks: positions & locations." onClick={()=>onPlay('flash')} onHelp={()=>{}} />
            <CardButton title="Positions Bingo" description="5×5 practice board." onClick={()=>onPlay('bingo')}          onHelp={()=>{}} />
            <CardButton title="Dice of Destiny" description="Random practice prompts." onClick={()=>onPlay('dice')}     onHelp={()=>{}} />
            <CardButton title="Tempo Trainer"   description="Flashcards + call-outs." onClick={()=>onPlay('tempoTrainer')}  onHelp={()=>{}} />
            <CardButton title="Tempo Tester"    description="MCQ + heatmap." onClick={()=>onPlay('tempoTester')}        onHelp={()=>{}} />
            <CardButton title="Bieler Method Lab" description="Vocab, concepts, apps." onClick={()=>onPlay('bielerLab')} onHelp={()=>{}} />
            <CardButton title="Finger Height Drill" description="Low vs High." onClick={()=>onPlay('height')}           onHelp={()=>{}} />
            <CardButton title="Note Locator"    description="Find valid locations." onClick={()=>onPlay('locator')}      onHelp={()=>{}} />
            <CardButton title="Shift Coach"     description="Best landing pos/finger." onClick={()=>onPlay('shift')}    onHelp={()=>{}} />
            <CardButton title="Harmonics Lab"   description="Nodes 1/2, 1/3, 1/4." onClick={()=>onPlay('harmonics')}    onHelp={()=>{}} />
          </div>
    
          <div className="mt-6 grid lg:grid-cols-2 gap-4">
            <AccuracyHeatmap stats={stats} order={prefs.stringOrder} />
            <WeakestThreePanel
              stats={stats}
              onDrill={(s,p,f)=>{
                setPrefs(prev=>{
                  const next = { ...prev };
                  next.filters = {
                    strings:  { G:false, D:false, A:false, E:false, [s]: true },
                    positions:{ 1:false, 2:false, 3:false, 4:false, 5:false, [p]: true },
                    fingers:  { 1:false, 2:false, 3:false, 4:false, [f]: true }
                  };
                  savePrefs(next);
                  return next;
                });
                onPlay('speed');
              }}
            />
          </div>
        </div>
      );
    };
    
    const App = () => {
      const [prefs, setPrefs] = React.useState(loadPrefs());
      const [stats, setStats] = React.useState(loadStats());
      const [screen, setScreen] = React.useState('home');
    
      const go = (s) => setScreen(s);
      const back = () => setScreen('home');
    
      return (
        <>
          {screen==='home'         && <Dashboard prefs={prefs} setPrefs={setPrefs} stats={stats} setStats={setStats} onPlay={go} />}
          {screen==='speed'        && <SpeedLadderGame onBack={back} prefs={prefs} stats={stats} setStats={setStats} />}
          {screen==='flash'        && <Flashcards onBack={back} />}
          {screen==='bingo'        && <BingoBoard onBack={back} />}
          {screen==='dice'         && <DiceOfDestinyGame onBack={back} />}
          {screen==='tempoTrainer' && <TempoTrainer onBack={back} prefs={prefs} />}
          {screen==='tempoTester'  && <TempoTester onBack={back} prefs={prefs} />}
          {screen==='bielerLab'    && <BielerLab onBack={back} />}
          {screen==='height'       && <HeightDrill onBack={back} prefs={prefs} />}
          {screen==='locator'      && <NoteLocator onBack={back} prefs={prefs} />}
          {screen==='shift'        && <ShiftCoach onBack={back} prefs={prefs} />}
          {screen==='harmonics'    && <HarmonicsLab onBack={back} prefs={prefs} />}
        </>
      );
    };
    
    class ErrorBoundary extends React.Component {
      constructor(p){super(p); this.state={hasError:false};}
      static getDerivedStateFromError(){return {hasError:true};}
      componentDidCatch(err, info){console.error(err, info);}
      render(){return this.state.hasError ? <div style={{padding:16}}>Something went wrong.</div> : this.props.children;}
    }
    
    ReactDOM.createRoot(document.getElementById('root')).render(
      <ErrorBoundary><App/></ErrorBoundary>
    );
        const WeakestThreePanel = ({ stats, onDrill }) => {
          const toLB = (c,t)=> t? wilsonLowerBound(c,t) : 0;
          const list = Object.entries(stats).map(([k,v])=>({k, c:v.correct||0, t:v.total||0, lb:toLB(v.correct||0, v.total||0)}))
            .filter(x=>x.t>=5).sort((a,b)=>a.lb-b.lb).slice(0,3);
          if (!list.length) return null;
          return (
            <div className="card rounded-xl p-4">
              <div className="text-lg font-semibold mb-2">Top 3 Weakest Spots</div>
              <div className="grid gap-2">
                {list.map((it,i)=>{
                  const [s,p,f] = it.k.split(':');
                  return (
                    <div key={i} className="flex items-center justify-between rounded border p-2">
                      <div>{fullLoc(s, Number(p), Number(f))} · <span className="muted text-sm">LB {Math.round(it.lb*100)}% · {it.c}/{it.t}</span></div>
                      <button className="btn btn-purple" onClick={()=>onDrill(s,Number(p),Number(f))}>Drill This</button>
                    </div>
                  );
                })}
              </div>
              <div className="text-xs muted mt-2">LB = 95% confidence lower bound. Each drill opens Speed Ladder focused on that cell.</div>
            </div>
          );
        };

    const BadgesPanel = () => {
      const bag = loadBadges();
      const earned = bag.earned || {};
      return (
        <div className="card rounded-xl p-4">
          <div className="text-lg font-semibold mb-2">Badges</div>
          <div className="flex flex-wrap gap-2">
            {BADGES.map(b=>{
              const on = !!earned[b.slug];
              return <span key={b.slug} className="badge" style={{opacity: on?1:0.35}} title={on?`Earned ${new Date(earned[b.slug]).toLocaleDateString()}`:'Not yet'}>{b.name}</span>;
            })}
          </div>
        </div>
      );
    };

    const ScoreHeader = () => {
      const sb = loadScoreboard();
      const lvl = sb.level||1; const next = sb.next||nextLevelXP(lvl);
      const curIn = sb.xp - nextLevelXP(lvl-1);
      const need = next - nextLevelXP(lvl-1);
      const pct = Math.max(0, Math.min(100, Math.round(100 * (curIn/need))));
      const st = loadStreak();
      const accentName = getAccent();
      return (
        <div className="card rounded-xl p-4 mb-4">
          <div className="flex items-center justify-between">
            <div>
              <div className="font-semibold">Level {lvl}</div>
              <div className="xpbar mt-1"><div className="xpbar-fill" style={{width:`${pct}%`}}/></div>
              <div className="text-xs muted mt-1">{sb.xp} XP · {pct}% to next</div>
            </div>
            <div className="text-right">
              <div className="avatar-wrap justify-end">
                <AvatarIcon outfit={loadJSON(COSMETICS_KEY, {selected:{outfit:'classic',trail:'none'}}).selected.outfit}
                            trail={loadJSON(COSMETICS_KEY, {selected:{outfit:'classic',trail:'none'}}).selected.trail}/>
              </div>
              <div className="text-xs muted">Best streak: {st.best||0}</div>
              <div className="text-xs muted">Theme: {accentName}</div>
            </div>
          </div>
        </div>
      );
    };

    /* =========================================================
       Dashboard
    ========================================================== */
    const Dashboard = ({ go, prefs, setPrefs, stats, setStats }) => {
      const [helpKey,setHelpKey]=useState(null);
      const [theme, setThemeState] = useState(getTheme());
      const [updateReady,setUpdateReady]=useState(false);
      const [accent, setAccent] = useState(getAccent());

      // Backup & Restore
      const backup = () => {
        const payload = {
          [PREFS_KEY]: JSON.parse(localStorage.getItem(PREFS_KEY) || 'null'),
          [STATS_KEY]: JSON.parse(localStorage.getItem(STATS_KEY) || 'null'),
          [BEST_KEY]: JSON.parse(localStorage.getItem(BEST_KEY) || 'null'),
          [TEMPO_STATS_KEY]: JSON.parse(localStorage.getItem(TEMPO_STATS_KEY) || 'null'),
          [TEMPO_BEST_KEY]: JSON.parse(localStorage.getItem(TEMPO_BEST_KEY) || 'null'),
          [SEYBOLD_KEY]: JSON.parse(localStorage.getItem(SEYBOLD_KEY) || 'null'),
          [SCORE_KEY]: JSON.parse(localStorage.getItem(SCORE_KEY) || 'null'),
          [BADGES_KEY]: JSON.parse(localStorage.getItem(BADGES_KEY) || 'null'),
          [PRESETS_KEY]: JSON.parse(localStorage.getItem(PRESETS_KEY) || 'null'),
          [SESSIONLOG_KEY]: JSON.parse(localStorage.getItem(SESSIONLOG_KEY) || 'null'),
          [HEIGHT_STATS_KEY]: JSON.parse(localStorage.getItem(HEIGHT_STATS_KEY) || 'null'),
          [LOCATOR_STATS_KEY]: JSON.parse(localStorage.getItem(LOCATOR_STATS_KEY) || 'null'),
          [SHIFT_STATS_KEY]: JSON.parse(localStorage.getItem(SHIFT_STATS_KEY) || 'null'),
          [HARM_STATS_KEY]: JSON.parse(localStorage.getItem(HARM_STATS_KEY) || 'null'),
          [COSMETICS_KEY]: JSON.parse(localStorage.getItem(COSMETICS_KEY) || 'null'),
          [SM2_KEY]: JSON.parse(localStorage.getItem(SM2_KEY) || 'null'),
          [THEME_ACCENT_KEY]: localStorage.getItem(THEME_ACCENT_KEY) || null
        };
        const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download='vpq_backup.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };
      const restore = async (file) => {
        try {
          const txt = await file.text();
          const obj = JSON.parse(txt);
          Object.entries(obj).forEach(([k,v])=>{ if (v!==undefined && v!==null) localStorage.setItem(k, typeof v==='string'? v : JSON.stringify(v)); });
          alert('Backup restored. The page will now reload to apply it.'); location.reload();
        } catch(e){ alert('Import failed: ' + e.message); }
      };
      const inputRef = useRef(null);

      const exportCSV = () => {
        const rows = [['mode','key','correct','total','accuracy']];
        const packs = [
          ['speed', stats],
          ['height', loadJSON(HEIGHT_STATS_KEY, {})],
          ['locator', loadJSON(LOCATOR_STATS_KEY, {})],
          ['shift', loadJSON(SHIFT_STATS_KEY, {})],
          ['harmonics', loadJSON(HARM_STATS_KEY, {})],
        ];
        for (const [mode, obj] of packs) {
          Object.entries(obj).forEach(([k, v]) => {
            if (v && typeof v === 'object') {
              if ('low' in v && 'high' in v) {
                ['low','high','natural'].forEach(h=>{
                  const c=v[h]?.correct||0, t=v[h]?.total||0, a=t? (c/t).toFixed(4):'0.0000';
                  rows.push([`${mode}:${h}`, k, c, t, a]);
                });
              } else {
                const c=v.correct||0, t=v.total||0, a=t? (c/t).toFixed(4):'0.0000';
                rows.push([mode, k, c, t, a]);
              }
            }
          });
        }
        const csv = rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
        const url = URL.createObjectURL(new Blob([csv], {type:'text/csv'}));
        const a = Object.assign(document.createElement('a'), {href:url, download:'positions_training_stats.csv'});
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };

      const resetAll = () => { if(!confirm('Reset all fingerboard stats & bests?')) return;
        localStorage.removeItem(BEST_KEY); localStorage.removeItem(STATS_KEY);
        localStorage.removeItem(HEIGHT_STATS_KEY); localStorage.removeItem(LOCATOR_STATS_KEY);
        localStorage.removeItem(SHIFT_STATS_KEY); localStorage.removeItem(HARM_STATS_KEY);
        setStats({}); alert('Stats cleared.'); };

      useEffect(()=>{
        checkAwardBadges();
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.getRegistration().then(reg=>{
            if (!reg) return;
            reg.addEventListener('updatefound', ()=>{
              const nw = reg.installing;
              nw?.addEventListener('statechange', ()=>{
                if (nw.state === 'installed' && navigator.serviceWorker.controller) {
                  setUpdateReady(true);
                }
              });
            });
          });
        }
      },[]);

      const toggleTheme = () => { const next = theme==='light'?'dark':'light'; setTheme(next); setThemeState(next); };
      const changeAccent = (name) => { applyAccent(name); setAccent(name); };

      const goDrill = (s,p,f) => {
        const next = {...prefs};
        next.filters = { strings:Object.fromEntries(STRINGS.map(x=>[x, x===s])), positions:Object.fromEntries(POSITIONS.map(x=>[x, x===p])), fingers:Object.fromEntries(FINGERS.map(x=>[x, x===f])) };
        setPrefs(next); savePrefs(next);
        go('speed');
      };

      const sessions = loadJSON(SESSIONLOG_KEY, []);
      const speedPoints = sessions.filter(s=>s.mode==='speed').slice(-20).map(s=> (s.total? s.correct/s.total : 0.0));
      const tempoPoints = sessions.filter(s=>s.mode==='tempo').slice(-20).map(s=> (s.total? s.correct/s.total : 0.0));

      return (
        <div className="p-4">
          <header className="mb-4 flex items-center justify-between">
            <div>
              <div className="text-3xl font-bold">Violin Positions Quest</div>
              <div className="muted text-sm">Your daily mission to master the fingerboard—and beyond.</div>
            </div>
            <div className="flex items-center gap-2">
              <select className="border rounded p-2 text-sm" value={accent} onChange={e=>changeAccent(e.target.value)} title="Theme accent">
                <option value="symphony">Symphony Hall</option>
                <option value="rockstar">Rockstar</option>
                <option value="fantasy">Fantasy Quest</option>
                <option value="lofi">Lo-fi Studio</option>
              </select>
              <button className="btn btn-gray" onClick={toggleTheme}>{theme==='dark'?'Light':'Dark'} Mode</button>
              <button className="btn btn-green" onClick={backup}>Backup</button>
              <button className="btn btn-blue" onClick={()=>inputRef.current?.click()}>Restore</button>
              <input ref={inputRef} type="file" accept="application/json" hidden onChange={e=>e.target.files[0] && restore(e.target.files[0])}/>
            </div>
          </header>

          <ScoreHeader />

          <div className="grid-cards">
            <CardButton title="Speed Ladder" description="Adaptive fingerboard quiz (Pos 1–5). Coach + retries." onClick={()=>go('speed')} onHelp={()=>setHelpKey('speed')} />
            <CardButton title="Finger Height Drill" description="Low vs High fingers for intonation." onClick={()=>go('height')} onHelp={()=>setHelpKey('height')} />
            <CardButton title="Note Locator" description="Pick a valid string/position/finger for a pitch." onClick={()=>go('locator')} onHelp={()=>setHelpKey('locator')} />
            <CardButton title="Shift Coach" description="Choose efficient shifts on one string." onClick={()=>go('shift')} onHelp={()=>setHelpKey('shift')} />
            <CardButton title="Harmonics Lab" description="Natural nodes (1/2, 1/3, 1/4) per string." onClick={()=>go('harmonics')} onHelp={()=>setHelpKey('harmonics')} />
            <CardButton title="Flashcards Mode" description="Two decks: direct hits + note→locations." onClick={()=>go('cards')} onHelp={()=>setHelpKey('cards')} />
            <CardButton title="Positions Bingo" description="Fill a line with focused tasks." onClick={()=>go('bingo')} onHelp={()=>setHelpKey('bingo')} />
            <CardButton title="Dice of Destiny" description="Roll for a practice challenge." onClick={()=>go('dice')} onHelp={()=>setHelpKey('dice')} />
            <CardButton title="Tempo Trainer" description="Italian terms flashcards with call-outs." onClick={()=>go('tempoTrainer')} onHelp={()=>setHelpKey('tempoTrainer')} />
            <CardButton title="Tempo Tester" description="Timed MCQ + review misses + heatmap." onClick={()=>go('tempoTester')} onHelp={()=>setHelpKey('tempoTester')} />
            <CardButton title="Bieler Method Lab" description="Vocabulary, concepts, and application." onClick={()=>go('bielerLab')} onHelp={()=>setHelpKey('bielerLab')} />
          </div>

          <div className="grid lg:grid-cols-3 gap-4 mt-6">
            <div className="lg:col-span-2">
              <FiltersPanel
                prefs={prefs}
                setPrefs={setPrefs}
                stats={stats}
                onResetStats={resetAll}
                onExportCSV={exportCSV}
              />
              <div className="mt-4"><AccuracyHeatmap stats={stats} order={prefs.stringOrder} /></div>
            </div>
            <div className="space-y-4">
              <div className="card rounded-xl p-4">
                <div className="text-lg font-semibold mb-2">Recent Accuracy</div>
                <div className="text-xs muted mb-1">Speed Ladder (last 20)</div>
                <Spark points={speedPoints}/>
                <div className="text-xs muted mt-2">Tempo Tester (last 20)</div>
                <Spark points={tempoPoints}/>
              </div>
              <WeakestThreePanel stats={stats} onDrill={goDrill}/>
              <BadgesPanel/>
              <AvatarCustomizer/>
            </div>
          </div>

          <Modal open={!!helpKey} onClose={()=>setHelpKey(null)} title="How to play">
            {HELP[helpKey] || 'Select a mode to begin.'}
          </Modal>

          <Toast open={updateReady} text="An update is ready." action="Reload" onAction={()=>location.reload()} />
        </div>
      );
    };

    /* =========================================================
       Error Boundary (runtime guard)
    ========================================================== */
    class ErrorBoundary extends React.Component {
      constructor(props){ super(props); this.state = { hasError:false, err:'' }; }
      static getDerivedStateFromError(err){ return { hasError:true, err: String(err) }; }
      componentDidCatch(err, info){ console.error(err, info); }
      render(){
        if (this.state.hasError){
          return (
            <div className="p-6">
              <div className="card rounded-xl p-6">
                <h2 className="text-xl font-bold mb-2">Something went wrong</h2>
                <p className="muted text-sm mb-3">{this.state.err}</p>
                <button className="btn btn-purple" onClick={()=>location.reload()}>Reload App</button>
              </div>
            </div>
          );
        }
        return this.props.children;
      }
    }

    /* =========================================================
       Root App (routing + state)
    ========================================================== */
    const App = () => {
      const [route, setRoute] = useState(() => (location.hash.replace('#','') || 'home'));
      const [prefs, setPrefs] = useState(loadPrefs());
      const [stats, setStats] = useState(loadStats());

      // Hash routing + deep-link
      const go = (r) => { setRoute(r); location.hash = r; };
      const onBack = () => go('home');

      useEffect(()=>{
        const onHash=()=> setRoute(location.hash.replace('#','') || 'home');
        window.addEventListener('hashchange', onHash);
        return ()=>window.removeEventListener('hashchange', onHash);
      },[]);

      // Persist prefs/stats on change
      useEffect(()=>{ savePrefs(prefs); }, [prefs]);
      useEffect(()=>{ saveStats(stats); }, [stats]);

      // Global keyboard: Esc to go home
      useEffect(()=>{
        const onKey=(e)=>{ if(e.key==='Escape' && route!=='home') onBack(); };
        window.addEventListener('keydown', onKey);
        return ()=>window.removeEventListener('keydown', onKey);
      }, [route]);

      // Optional: register service worker (if present in repo)
      useEffect(()=>{
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/violin-positions-quest/sw.js').catch(()=>{});
        }
      },[]);

      // Route table
      if (route==='speed')        return <SpeedLadderGame onBack={onBack} prefs={prefs} stats={stats} setStats={setStats} />;
      if (route==='cards')        return <Flashcards onBack={onBack} />;
      if (route==='bingo')        return <BingoBoard onBack={onBack} />;
      if (route==='dice')         return <DiceOfDestinyGame onBack={onBack} />;
      if (route==='tempoTrainer') return <TempoTrainer onBack={onBack} prefs={prefs} />;
      if (route==='tempoTester')  return <TempoTester onBack={onBack} prefs={prefs} />;
      if (route==='bielerLab')    return <BielerLab onBack={onBack} />;
      if (route==='height')       return <HeightDrill onBack={onBack} prefs={prefs} />;
      if (route==='locator')      return <NoteLocator onBack={onBack} prefs={prefs} />;
      if (route==='shift')        return <ShiftCoach onBack={onBack} prefs={prefs} />;
      if (route==='harmonics')    return <HarmonicsLab onBack={onBack} prefs={prefs} />;

      // Default: Dashboard
      return <Dashboard go={go} prefs={prefs} setPrefs={setPrefs} stats={stats} setStats={setStats} />;
    };

    // simple boundary (optional)
    class ErrorBoundary extends React.Component {
      constructor(p){ super(p); this.state={hasError:false}; }
      static getDerivedStateFromError(){ return {hasError:true}; }
      componentDidCatch(err, info){ console.error(err, info); }
      render(){ return this.state.hasError ? <div>Something went wrong.</div> : this.props.children; }
    }

    // mount
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <ErrorBoundary>
        <App />
      </ErrorBoundary>
    );
  </script>
</body>
</html>
