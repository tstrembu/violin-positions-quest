<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Positions Quest</title>

  <!-- Viewport & Theme -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#6d28d9" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="VPQ" />

  <!-- PWA manifest & icons (GitHub Pages path) -->
  <!-- If hosted at https://<user>.github.io/violin-positions-quest/, keep the leading folder -->
  <link rel="manifest" href="/violin-positions-quest/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/violin-positions-quest/icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/violin-positions-quest/icons/icon-192.png" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- Base styles -->
  <style>
    :root {
      --bg: #f3f4f6;
      --card: #ffffff;
      --ink-900: #111827;
      --ink-800: #1f2937;
      --ink-700: #374151;
      --ink-600: #4b5563;
      --ink-500: #6b7280;
      --shadow: 0 10px 20px rgba(0,0,0,0.08);
      --accent: #6d28d9; /* theme accent */
      --accent-soft: rgba(109,40,217,.08); /* fallback if color-mix unsupported */
    }
    body.dark {
      --bg: #0b1020;
      --card: #0f172a;
      --ink-900: #e5e7eb;
      --ink-800: #e2e8f0;
      --ink-700: #cbd5e1;
      --ink-600: #94a3b8;
      --ink-500: #64748b;
      --shadow: 0 12px 24px rgba(0,0,0,0.35);
    }
    html, body { height:100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink-900);
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji';
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    .card { background: var(--card); box-shadow: var(--shadow); }
    .muted { color: var(--ink-600); }
    .ink700 { color: var(--ink-700); }
    .ink800 { color: var(--ink-800); }
    .linkish { text-decoration: underline; cursor: pointer; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { width:min(680px, 92vw); }
    .pill { border-radius: 9999px; padding: 4px 10px; display:inline-block; font-size:12px; }
    .badge { background:var(--accent); color:white; border-radius:9999px; padding:.25rem .6rem; font-weight:700; font-size:12px; }
    .help-dot { width: 22px; height: 22px; border-radius: 9999px; display:inline-flex; align-items:center; justify-content:center; background:#11182717; color:var(--accent); font-weight:700; }
    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; z-index: 9998; }
    .btn {
      display:inline-flex; align-items:center; justify-content:center;
      padding: .75rem 1.25rem; border-radius: 9999px; color:white; font-weight:700;
      transition: transform .08s ease;
    }
    .btn:active { transform: scale(.98); }
    .btn-purple { background:var(--accent); }
    .btn-blue { background:#2563eb; }
    .btn-green { background:#059669; }
    .btn-gray { background:#4b5563; }
    .btn-rose { background:#e11d48; }
    .btn-amber { background:#d97706; }
    .grid-cards { display:grid; gap: 24px; grid-template-columns: repeat(1, minmax(0,1fr)); }
    @media(min-width:640px){ .grid-cards{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media(min-width:1024px){ .grid-cards{ grid-template-columns: repeat(3, minmax(0,1fr)); } }

    /* micro-animations for answers */
    @keyframes pulseCorrect { from{transform:scale(1)} 50%{transform:scale(1.03)} to{transform:scale(1)} }
    @keyframes pulseWrong   { from{transform:scale(1)} 50%{transform:scale(0.97)} to{transform:scale(1)} }
    .btn-hit.ok   { animation:pulseCorrect .25s ease; box-shadow:0 0 0 3px rgba(16,185,129,.25); }
    .btn-hit.miss { animation:pulseWrong   .25s ease; box-shadow:0 0 0 3px rgba(239,68,68,.25); }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }

    /* A11y live region */
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}
    *, *::before, *::after { box-sizing: border-box; }

    /* ---- Fingerboard accuracy heatmap layout ---- */
    :root{ --posw: clamp(160px, 45%, 220px); }
    .fb-strip{
      display:flex; gap:12px; overflow-x:auto; -webkit-overflow-scrolling:touch;
      padding-bottom:6px; scroll-snap-type:x mandatory;
    }
    .fb-pos{ flex: 0 0 var(--posw); min-width: var(--posw); scroll-snap-align: start; overflow:hidden; }
    .fb-grid{ display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap:6px; }
    .fb-tile{
      position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 2px; line-height: 1.1; aspect-ratio: 1 / 1.15; padding: 6px 4px; min-width: 0;
    }
    .fb-band{ position: absolute; left: 6px; right: 6px; bottom: 6px; height: 10px; border-radius: 6px; }
    @media (min-width: 1024px){
      .fb-strip{ display: grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 12px; overflow: visible; }
      .fb-pos{ flex: initial; min-width: 0; }
    }
    @supports not (aspect-ratio: 1){ .fb-tile { height: 72px; } }
    @media (min-width: 768px) and (max-width: 1023px){
      .fb-strip{ flex-wrap: wrap; }
      .fb-pos{ flex: 1 1 calc(50% - 12px); min-width: 0; }
    }

    /* Avatar */
    .avatar { width:56px; height:56px; border-radius:12px; overflow:hidden; border:2px solid rgba(0,0,0,.08); }
    .avatar-wrap { display:flex; align-items:center; gap:10px; }
    .avatar-label { font-size:12px; color:var(--ink-600); }

    /* XP bar */
    .xpbar { height:10px; border-radius:9999px; background:rgba(0,0,0,.1); overflow:hidden; }
    .xpbar-fill { height:100%; background:var(--accent); }

    /* === FingerboardDiagram + Staff === */
    .fb-diagram { display: grid; grid-template-columns: 1fr minmax(260px, 360px); gap: 16px; align-items: start; }
    @media (max-width: 820px) { .fb-diagram { grid-template-columns: 1fr; } }
    .fb-board { position: relative; background: var(--card); border-radius: 12px; box-shadow: var(--shadow); border: 1px solid rgba(0,0,0,0.08); overflow: hidden; }
    .fb-strings { display: grid; grid-template-rows: repeat(4, 56px); align-items: stretch; padding: 16px 14px 18px; }
    .fb-string-row { position: relative; display: grid; grid-template-columns: repeat(5, minmax(0,1fr)); gap: 8px; }
    /* Fallback to --accent-soft if color-mix is not available */
    .fb-pos-band { position: absolute; top: 0; bottom: 0; width: calc(20% - 6px); border-radius: 10px; background: var(--accent-soft); pointer-events: none; }
    @supports (background: color-mix(in srgb, red 10%, transparent)) {
      .fb-pos-band { background: color-mix(in srgb, var(--accent) 8%, transparent); }
    }
    .fb-pos-label { position: absolute; top: 6px; left: 10px; font-size: 11px; font-weight: 700; color: var(--ink-600); }
    .fb-string-label { position: absolute; left: 8px; top: 50%; transform: translateY(-50%); font-weight: 700; font-size: 12px; color: var(--ink-600); opacity: .9; pointer-events: none; }
    .fb-cell { position: relative; display: grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 6px; align-items: center; justify-content: center; }
    .fb-mark { position: relative; display: inline-flex; align-items: center; justify-content: center; height: 40px; border-radius: 10px; border: 1px solid rgba(0,0,0,0.10); background: rgba(0,0,0,0.02); font-weight: 700; user-select: none; outline: none; }
    .fb-mark:focus-visible { box-shadow: 0 0 0 3px rgba(109,40,217,.28); }
    .fb-mark.dim    { opacity: .35; }
    .fb-mark.active { background: var(--accent); color: #fff; border-color: transparent; }
    .fb-mark.note   { font-size: 11px; font-weight: 600; color: var(--ink-700); }
    .fb-foot { margin-top: 8px; font-size: 11px; color: var(--ink-600); }
    .staff-card { background: var(--card); border-radius: 12px; box-shadow: var(--shadow); border: 1px solid rgba(0,0,0,0.08); padding: 12px; }
    .staff-svg text { fill: currentColor; }
    .staff-label { font-size: 12px; color: var(--ink-600); }
    @media (prefers-contrast: more) { .fb-mark { border-color: currentColor; } .fb-pos-label { color: var(--ink-800); } }
  </style>

  <!-- Tailwind (utility helpers only) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode:'class', theme:{ extend:{ fontFamily:{ inter:['Inter','ui-sans-serif','system-ui'] } } } };
  </script>

  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <noscript>This app requires JavaScript.</noscript>
  <div id="root"></div>
  <!-- A11y live region -->
  <div id="sr" aria-live="polite" class="sr-only"></div>

  <!-- App -->
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    /* =========================================================
       Storage keys
    ========================================================== */
    const THEME_KEY = 'vpq.theme.v1';                   // light | dark
    const THEME_ACCENT_KEY = 'vpq.themeAccent.v1';      // symphony | rockstar | fantasy | lofi
    const BEST_KEY = 'positionsQuest.speed.best';
    const STATS_KEY = 'positionsQuest.speed.stats';
    const PREFS_KEY = 'positionsQuest.prefs';
    const PRESETS_KEY = 'positionsQuest.filterPresets.v1';
    const SESSIONLOG_KEY = 'positionsQuest.sessions.v1';
    const SCORE_KEY = 'positions.scoreboard.v1';
    const BADGES_KEY = 'positions.badges.v1';
    const STREAK_KEY = 'positions.streak.v1';
    const COSMETICS_KEY = 'positions.cosmetics.v1';
    const SM2_KEY = 'sm2.v1';

    const TEMPO_STATS_KEY = 'positionsQuest.tempo.stats.v1';
    const TEMPO_BEST_KEY  = 'positionsQuest.tempo.best.v1';
    const HEIGHT_STATS_KEY  = 'positionsQuest.height.stats.v1';
    const LOCATOR_STATS_KEY = 'positionsQuest.locator.stats.v1';
    const SHIFT_STATS_KEY   = 'positionsQuest.shift.stats.v1';
    const HARM_STATS_KEY    = 'positionsQuest.harmonics.stats.v1';

    /* =========================================================
       Theme
    ========================================================== */
    const getTheme = () => (localStorage.getItem(THEME_KEY) || 'light');
    const setTheme = (t) => { localStorage.setItem(THEME_KEY, t); document.body.classList.toggle('dark', t === 'dark'); };
    (function bootTheme(){ setTheme(getTheme()); })();

    const THEMES = {
      symphony: { '--accent':'#6d28d9' },
      rockstar: { '--accent':'#e11d48' },
      fantasy:  { '--accent':'#22d3ee' },
      lofi:     { '--accent':'#10b981' }
    };
    const getAccent = () => localStorage.getItem(THEME_ACCENT_KEY) || 'symphony';
    const applyAccent = (name) => {
      const t = THEMES[name] || THEMES.symphony;
      Object.entries(t).forEach(([k,v])=>document.documentElement.style.setProperty(k, v));
      localStorage.setItem(THEME_ACCENT_KEY, name);
    };
    applyAccent(getAccent());

    /* =========================================================
       Utilities
    ========================================================== */
    const shuffle = (arr) => { const a = [...arr]; for (let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };
    const getRandomItem = (arr) => arr[Math.floor(Math.random()*arr.length)];
    const nowISO = () => new Date().toISOString();

    // ASCII accidental normalizer for display
    const NORM = {'A‚ô≠':'Ab','B‚ô≠':'Bb','E‚ô≠':'Eb','D‚ô≠':'Db','G‚ô≠':'Gb','C‚ô≠':'Cb','C‚ôØ':'C#','D‚ôØ':'D#','F‚ôØ':'F#','G‚ôØ':'G#','A‚ôØ':'A#'};
    const norm = n => NORM[n] || n;

    // Label helpers
    const ordinal = n => { const x = Number(n);
      const suf = (x%10===1 && x%100!==11) ? 'st'
               : (x%10===2 && x%100!==12) ? 'nd'
               : (x%10===3 && x%100!==13) ? 'rd' : 'th';
      return `${x}${suf}`;
    };
    const posLabel    = p => `${ordinal(p)} Position`;
    const fingerLabel = f => `${ordinal(f)} Finger`;
    const stringLabel = s => `${s} string`;
    const fullLoc     = (s,p,f,withString=true) =>
      withString ? `${posLabel(p)}, ${fingerLabel(f)} on the ${stringLabel(s)}`
                 : `${posLabel(p)}, ${fingerLabel(f)}`;

    /* =========================================================
       Core enums (MUST be defined before use)
    ========================================================== */
    const STRINGS   = ['G','D','A','E'];
    const POSITIONS = [1,2,3,4,5];
    const FINGERS   = [1,2,3,4];

    /* =========================================================
       Fingerboard Data (Positions 1‚Äì5, no open strings)
    ========================================================== */
    const NOTES_DATA = {
      G: {
        1: { 1: ['A‚ô≠','A'], 2: ['B‚ô≠','B'], 3: ['C','C#'], 4: ['D'] },
        2: { 1: ['B‚ô≠','B'], 2: ['B','C'],   3: ['C','C#'], 4: ['E‚ô≠','E'] },
        3: { 1: ['C','C#'], 2: ['C#','D'],  3: ['E‚ô≠','E'], 4: ['F','F#'] },
        4: { 1: ['D','D#'], 2: ['D#','E'],  3: ['E','F'],  4: ['F#','G'] },
        5: { 1: ['E‚ô≠','E'], 2: ['F','F#'],  3: ['G','G#'], 4: ['A'] },
      },
      D: {
        1: { 1: ['E‚ô≠','E'], 2: ['F','F#'], 3: ['G','G#'], 4: ['A'] },
        2: { 1: ['F','F#'], 2: ['F#','G'], 3: ['A','B‚ô≠'], 4: ['B‚ô≠','B'] },
        3: { 1: ['G','G#'], 2: ['G#','A'], 3: ['A','B‚ô≠'], 4: ['C','C#'] },
        4: { 1: ['A','A#'], 2: ['A#','B'], 3: ['B','C'],  4: ['C#','D'] },
        5: { 1: ['B‚ô≠','B'], 2: ['C','C#'], 3: ['D','D#'], 4: ['E'] },
      },
      A: {
        1: { 1: ['B‚ô≠','B'], 2: ['C','C#'], 3: ['D','D#'], 4: ['E'] },
        2: { 1: ['C','C#'], 2: ['C#','D'], 3: ['D','D#'], 4: ['F','F#'] },
        3: { 1: ['D','D#'], 2: ['D#','E'], 3: ['F','F#'], 4: ['G','G#'] },
        4: { 1: ['E','F'],  2: ['F','F#'], 3: ['F#','G'], 4: ['G#','A'] },
        5: { 1: ['F','F#'], 2: ['G','G#'], 3: ['A'],      4: ['B‚ô≠','B'] },
      },
      E: {
        1: { 1: ['F','F#'], 2: ['G','G#'], 3: ['A','A#'], 4: ['B'] },
        2: { 1: ['G','G#'], 2: ['G#','A'], 3: ['B','C'],  4: ['C','C#'] },
        3: { 1: ['A','A#'], 2: ['A#','B'], 3: ['C','C#'], 4: ['D','D#'] },
        4: { 1: ['B','C'],  2: ['C','C#'], 3: ['C#','D'], 4: ['D#','E'] },
        5: { 1: ['C','C#'], 2: ['D','D#'], 3: ['D#','E'], 4: ['F','F#'] },
      },
    };

    // Low/High helper
    const fingerHeight = (note, options) => {
      if (!Array.isArray(options)) return 'natural';
      if (options.length <= 1) return 'natural';
      const [low, high] = [options[0], options[options.length-1]];
      if (note === low) return 'low';
      if (note === high) return 'high';
      return 'natural';
    };

    // Simple harmonics set per string
    const HARMONICS = {
      G: { '1/2':['G','octave'], '1/3':['D','oct+5th'], '1/4':['G','2 oct'] },
      D: { '1/2':['D','octave'], '1/3':['A','oct+5th'], '1/4':['D','2 oct'] },
      A: { '1/2':['A','octave'], '1/3':['E','oct+5th'], '1/4':['A','2 oct'] },
      E: { '1/2':['E','octave'], '1/3':['B','oct+5th'], '1/4':['E','2 oct'] },
    };

    // Unique note list
    const ALL_NOTES_UNIQUE = (() => {
      const set = new Set();
      STRINGS.forEach(s => POSITIONS.forEach(p => FINGERS.forEach(f => {
        const cell = NOTES_DATA[s]?.[p]?.[f];
        if (Array.isArray(cell)) cell.forEach(n => set.add(n));
      })));
      return [...set];
    })();

    // Distractors avoiding enharmonic duplicates
    const getRandomDistractors = (correct, count = 3) => {
      const target = norm(correct);
      const pool = ALL_NOTES_UNIQUE.filter(n => norm(n) !== target);
      const picks = []; const seen = new Set([target]);
      while (picks.length < Math.min(count, pool.length)) {
        const n = getRandomItem(pool);
        const k = norm(n);
        if (!seen.has(k)) { seen.add(k); picks.push(n); }
      }
      return picks;
    };

    /* =========================================================
       Prefs & persistence
    ========================================================== */
    const defaultFilters = {
      strings: Object.fromEntries(STRINGS.map(s => [s, true])),
      positions: Object.fromEntries(POSITIONS.map(p => [p, true])),
      fingers: Object.fromEntries(FINGERS.map(f => [f, true])),
    };
    const loadPrefs = () => {
      try {
        const p = JSON.parse(localStorage.getItem(PREFS_KEY));
        return {
          sound: true, confetti: true, adaptive: true, coach: true, coachRetry: true,
          callouts: true, roundLen: 120, goalEnabled: false, goalTarget: 10,
          filters: { ...defaultFilters, ...(p?.filters || {}) }, ...(p || {})
        };
      } catch { return { sound:true, confetti:true, adaptive:true, coach:true, coachRetry:true, callouts:true, roundLen:120, goalEnabled:false, goalTarget:10, filters: defaultFilters }; }
    };
    const savePrefs = (obj) => { try { localStorage.setItem(PREFS_KEY, JSON.stringify(obj)); } catch {} };
    const loadBest = () => { try { return JSON.parse(localStorage.getItem(BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveBest = (obj) => { try { localStorage.setItem(BEST_KEY, JSON.stringify(obj)); } catch {} };
    const loadStats = () => { try { return JSON.parse(localStorage.getItem(STATS_KEY)) || {}; } catch { return {}; } };
    const saveStats = (obj) => { try { localStorage.setItem(STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoStats = () => { try { return JSON.parse(localStorage.getItem(TEMPO_STATS_KEY)) || {}; } catch { return {}; } };
    const saveTempoStats = (obj) => { try { localStorage.setItem(TEMPO_STATS_KEY, JSON.stringify(obj)); } catch {} };
    const loadTempoBest = () => { try { return JSON.parse(localStorage.getItem(TEMPO_BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return { bestScore:0, bestStreak:0 }; } };
    const saveTempoBest = (obj) => { try { localStorage.setItem(TEMPO_BEST_KEY, JSON.stringify(obj)); } catch {} };
    const loadJSON = (k, fallback={}) => { try { return JSON.parse(localStorage.getItem(k)) || fallback; } catch { return fallback; } };
    const saveJSON = (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };

    /* =========================================================
       Audio & call-outs (defensive)
    ========================================================== */
    const useBeeps = (enabled) => {
      const ctxRef = useRef(null);
      const ensureCtx = () => {
        if (!enabled) return null;
        try {
          if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
        } catch {}
        return ctxRef.current || null;
      };
      const beep = (freq = 880, dur = 0.08, type = 'sine') => {
        const ctx = ensureCtx(); if (!ctx) return;
        try {
          const o = ctx.createOscillator(); const g = ctx.createGain();
          o.type = type; o.frequency.value = freq; g.gain.value = 0.08; o.connect(g); g.connect(ctx.destination);
          o.start(); setTimeout(()=>{ try{o.stop();}catch{} }, dur*1000);
        } catch {}
      };
      return { good: () => beep(1046, 0.09, 'triangle'), bad: () => beep(196, 0.12, 'sawtooth') };
    };
    const useCallouts = (enabled) => {
      const speak = (text) => {
        if (!enabled || !window.speechSynthesis) return;
        try {
          const u = new SpeechSynthesisUtterance(text);
          u.lang='en-US'; u.rate=1.0;
          window.speechSynthesis.cancel();
          setTimeout(()=>window.speechSynthesis.speak(u), 0);
        } catch {}
      };
      return { speak };
    };

    /* =========================================================
       Evidence helpers (Wilson LB; heatmap style)
    ========================================================== */
    const wilsonLowerBound = (correct, total, z = 1.96) => {
      if (!total) return 0;
      const p = correct / total;
      const denom = 1 + (z*z)/total;
      const centre = p + (z*z)/(2*total);
      const adj = z * Math.sqrt((p*(1-p) + (z*z)/(4*total)) / total);
      return Math.max(0, (centre - adj) / denom);
    };
    const bandFromLB = (lb) => { if (lb < 0.65) return 'red'; if (lb < 0.85) return 'yellow'; return 'green'; };
    const SWATCH = { red:[239,68,68], yellow:[245,158,11], green:[16,185,129], gray:[120,120,120] };
    const rgba = (rgb, a) => `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
    const stabilityAlpha = (n) => { if (!n) return 0.18; const t = Math.min(1, Math.log10(n + 1) / Math.log10(50)); return 0.35 + 0.65 * t; };
    const evidenceStyle = (st) => {
      const correct = st?.correct || 0, total = st?.total || 0;
      if (!total) { return { bandColor: rgba(SWATCH.gray, 0.45), bg:'transparent', text:'#4b5563', lb:0, acc:0, total }; }
      const lb = wilsonLowerBound(correct, total);
      const band = bandFromLB(lb);
      const alpha = stabilityAlpha(total);
      return { bandColor: rgba(SWATCH[band], alpha), bg:'transparent', text:'#111827', lb, acc: correct/total, total, band };
    };

    /* =========================================================
       XP, Streaks, Levels, Badges
    ========================================================== */
    const BASE_XP = 10;
    const streakMultiplier = (streak) => Math.min(2.0, 1 + Math.floor(streak/5)*0.2);
    const xpForEvent = ({type='normal', streak=0}) => {
      const base = (type==='review'?5 : type==='retry'?1 : BASE_XP);
      return Math.round(base * streakMultiplier(streak));
    };
    const levelForXP = (xp)=> Math.floor(Math.pow(xp/120, 0.75))+1;
    const nextLevelXP = (lvl)=> Math.round(120*Math.pow(lvl, 1.33));
    const loadScoreboard = () => loadJSON(SCORE_KEY, { xp:0, level:1, next: nextLevelXP(1) });
    const saveScoreboard = (obj) => saveJSON(SCORE_KEY, obj);
    const loadStreak = () => loadJSON(STREAK_KEY, { current:0, best:0, lastTimestamp:0 });
    const saveStreak = (obj) => saveJSON(STREAK_KEY, obj);

    const BADGES = [
      {slug:'first-100', name:'First 100', test: s => s.totalCorrect >= 100},
      {slug:'perfect-20', name:'Perfect 20', test: s => s.bestStreak >= 20},
      {slug:'d-string-ace', name:'Master of D String', test: s => {
        const keys = Object.keys(s.byCell || {}).filter(k=>k.startsWith('D:'));
        if (!keys.length) return false;
        return keys.every(k=> { const t=s.byCell[k]; return (t.total||0)>=10 && (t.correct||0)/(t.total||1) >= 0.9; });
      }},
      {slug:'streak-50', name:'Combo 50', test: s => s.bestStreak >= 50},
    ];
    const loadBadges = () => loadJSON(BADGES_KEY, { earned:{} });
    const saveBadges = (b) => saveJSON(BADGES_KEY, b);
    const summarizeStats = (stats) => {
      let total=0, correct=0; const byCell={};
      Object.entries(stats||{}).forEach(([k,v])=>{
        const c=v.correct||0, t=v.total||0; total+=t; correct+=c; byCell[k]={correct:c,total:t};
      });
      const bestStreak = Math.max(loadBest().bestStreak||0, (loadStreak().best||0));
      return { totalAttempts: total, totalCorrect: correct, byCell, bestStreak };
    };
    const checkAwardBadges = () => {
      const summary = summarizeStats(loadStats());
      const bag = loadBadges();
      let changed = false;
      BADGES.forEach(b=>{
        if (!bag.earned[b.slug] && b.test(summary)) { bag.earned[b.slug] = nowISO(); changed = true; }
      });
      if (changed) saveBadges(bag);
      return bag;
    };

    /* =========================================================
       SM-2 Spaced Repetition (Speed Ladder)
    ========================================================== */
    function scheduleSM2(item, quality) { // 0..5
      const MIN_EASE = 1.3;
      if (quality < 3) { item.reps = 0; item.interval = 1; item.lapses=(item.lapses||0)+1; }
      else {
        item.reps = (item.reps||0) + 1;
        if (item.reps === 1) item.interval = 1;
        else if (item.reps === 2) item.interval = 6;
        else item.interval = Math.round(item.interval * (item.ease||2.5));
      }
      item.ease = Math.max(MIN_EASE, (item.ease||2.5) + (0.1 - (5 - quality)*(0.08 + (5 - quality)*0.02)));
      item.due = Date.now() + item.interval * 86400000;
      return item;
    }
    const sm2Update = (key, quality) => {
      const sm2 = loadJSON(SM2_KEY, {});
      const item = sm2[key] || { ease:2.5, interval:0, due:Date.now(), reps:0, lapses:0 };
      sm2[key] = scheduleSM2(item, quality);
      saveJSON(SM2_KEY, sm2);
    };
    const sm2DueKeys = () => {
      const sm2 = loadJSON(SM2_KEY, {});
      const now = Date.now();
      return Object.entries(sm2).filter(([k,v]) => (v?.due||0) <= now).map(([k])=>k);
    };

    /* =========================================================
       Tiny UI atoms
    ========================================================== */
    const Modal = ({ open, onClose, title, children }) => !open ? null : (
      <div className="modal-backdrop" onClick={onClose}>
        <div className="modal card rounded-xl p-5" role="dialog" aria-modal="true" onClick={e=>e.stopPropagation()}>
          <div className="flex items-center justify-between mb-2">
            <div className="text-lg font-bold">{title}</div>
            <button className="btn btn-gray" onClick={onClose} aria-label="Close modal">Close</button>
          </div>
          <div className="muted text-sm leading-relaxed">{children}</div>
        </div>
      </div>
    );

    const CardButton = ({ title, description, onClick, onHelp }) => (
      <div className="card rounded-xl p-5">
        <div className="flex items-start justify-between">
          <div>
            <div className="text-xl font-bold ink800">{title}</div>
            <div className="muted text-sm mt-1">{description}</div>
          </div>
          <button className="help-dot" title="How to play" onClick={onHelp} aria-label={`Help: ${title}`}>?</button>
        </div>
        <div className="mt-4">
          <button className="btn btn-purple" onClick={onClick} aria-label={`Open ${title}`}>Open</button>
        </div>
      </div>
    );

    const Toast = ({ open, text, action, onAction }) => !open ? null : (
      <div className="toast">
        <div className="card rounded-full px-4 py-2 flex items-center gap-3">
          <span className="ink800">{text}</span>
          {action && <button className="btn btn-amber" onClick={onAction}>{action}</button>}
        </div>
      </div>
    );

    /* =========================================================
       Staff + FingerboardDiagram (unchanged logic, with a11y labels)
    ========================================================== */
    const PC = { C:0, 'C#':1, Db:1, D:2, 'D#':3, Eb:3, E:4, Fb:4, 'E#':5, F:5, 'F#':6, Gb:6, G:7, 'G#':8, Ab:8, A:9, 'A#':10, Bb:10, B:11, Cb:11, 'B#':0 };
    const LETTER_IDX = { C:0, D:1, E:2, F:3, G:4, A:5, B:6 };
    const OPEN_MIDI_MAP = { G:55, D:62, A:69, E:76 }; // unused but kept for reference
    const RANGE = { G:[55,71], D:[62,79], A:[69,88], E:[76,96] }; // practical

    const parseNote = (n) => { const v = norm(n); return { letter: v[0], acc: v.slice(1) }; };
    const toMidi = (note, octave) => { const p = PC[note]; if (p==null) return null; return 12 * (octave + 1) + p; };
    const chooseMidiForString = (note, s) => {
      const [lo, hi] = RANGE[s]; let best = null;
      for (let oct = 2; oct <= 7; oct++) {
        const m = toMidi(note, oct); if (m==null) continue;
        if (m >= lo && m <= hi) { const mid = (lo + hi) / 2; const score = Math.abs(m - mid); if (!best || score < best.score) best = { midi: m, score }; }
      }
      if (!best) { let candidate = toMidi(note, 4); if (candidate==null) return null; if (candidate<lo) candidate=lo; if (candidate>hi) candidate=hi; best={midi:candidate, score:0}; }
      return best.midi;
    };
    const staffPosition = (spelled, octave, { step=10 }={}) => {
      const baselineIndex = 2; // E4 bottom line index offset
      const spelledLetter = spelled[0];
      const diatonicIndex = 7 * (octave - 4) + LETTER_IDX[spelledLetter];
      const staffSlotIndex = diatonicIndex + (2 - 2); // keep mapping stable
      const y = (4 - staffSlotIndex) * (step / 2);
      const ledgers = [];
      const topSlot = 8, bottomSlot = 0;
      const needAbove = Math.max(0, Math.ceil((staffSlotIndex - topSlot) / 2));
      const needBelow = Math.max(0, Math.ceil((bottomSlot - staffSlotIndex) / 2));
      if (needAbove) for (let i=1;i<=needAbove;i++){const ledgerSlot=topSlot + i*2; const ly=(4 - ledgerSlot) * (step / 2); ledgers.push(ly);}
      if (needBelow) for (let i=1;i<=needBelow;i++){const ledgerSlot=bottomSlot - i*2; const ly=(4 - ledgerSlot) * (step / 2); ledgers.push(ly);}
      return { y, ledgers };
    };

    const StaffNote = ({ s, note, width=320, height=120, label }) => {
      const spelled = norm(note);
      const midi = chooseMidiForString(spelled, s);
      const octave = Math.floor(midi / 12) - 1;
      const pad = 16, w = width - pad*2, h = height - pad*2;
      const step = 10, y0 = (h/2) - 2*step;
      const { y, ledgers } = staffPosition(spelled, octave, { step });
      const noteY = y0 + y;
      const cx = pad + w * 0.58; const rx = 9, ry = 6;

      return (
        <div className="staff-card" aria-label={`Staff: ${spelled} on ${s} string (octave ${octave})`}>
          <svg className="staff-svg" width="100%" height={height} viewBox={`0 0 ${width} ${height}`} role="img" aria-label={`Treble staff showing ${spelled}`}>
            {[0,1,2,3,4].map(i => { const y = y0 + i*step; return <line key={i} x1={pad} x2={width-pad} y1={y} y2={y} stroke="currentColor" strokeWidth="1" />; })}
            <text x={pad+4} y={y0 + step*3} fontSize="12">ùÑû</text>
            {ledgers.map((ly,i) => (<line key={'L'+i} x1={cx - 16} x2={cx + 16} y1={ly} y2={ly} stroke="currentColor" strokeWidth="1" />))}
            <ellipse cx={cx} cy={noteY} rx={rx} ry={ry} fill="currentColor" />
          </svg>
          <div className="staff-label">
            {label || `Target: ${spelled}  ‚Ä¢  String: ${s}  ‚Ä¢  Octave‚âà${octave}`}
          </div>
        </div>
      );
    };

    const validCell = (s,p,f) => Array.isArray(NOTES_DATA[s]?.[p]?.[f]) ? NOTES_DATA[s][p][f] : null;

    const FingerboardDiagram = ({
      position=1,
      mode='train',              // 'train' | 'test'
      active=null,               // { s, p, f, note? }
      showStaff=true,
      showStringLabels=true,
      staffTitle
    }) => {
      const p = Number(position) || 1;
      const isTrain = mode === 'train';
      const actKey = active ? `${active.s}:${active.p}:${active.f}` : null;
      const strings = ['E','A','D','G']; // top‚Üíbottom
      return (
        <div className="fb-diagram">
          <div className="fb-board" role="group" aria-label={`Fingerboard view ‚Äî ${posLabel(p)} ‚Äî ${isTrain?'Training':'Testing'} mode`}>
            <div className="fb-strings" aria-hidden={false}>
              {[1,2,3,4,5].map(i => (
                <div key={`band-${i}`} className="fb-pos-band" style={{ left: `calc(${(i-1)*20}% + 14px)` }} aria-hidden />
              ))}
              <div className="fb-pos-label" aria-hidden>Pos {p}</div>

              {strings.map((s) => (
                <div key={s} className="fb-string-row" aria-label={`${s} string, ${posLabel(p)}`}>
                  {showStringLabels && <div className="fb-string-label">{s}</div>}
                  {POSITIONS.map(col => {
                    const isThisPos = col === p;
                    return (
                      <div key={`${s}:${col}`} aria-hidden={!isThisPos} className="fb-cell" style={{ opacity: isThisPos ? 1 : 0.15 }}>
                        {FINGERS.map(f => {
                          const notes = validCell(s, col, f);
                          if (!notes) return <div key={`${s}:${col}:${f}`} />;
                          const k = `${s}:${col}:${f}`;
                          const isActiveCell = (k === actKey);
                          const label = isTrain
                            ? notes.map(norm).join('/')
                            : (isActiveCell ? (active?.note ? norm(active.note) : notes.map(n=>norm(n))[0]) : '');
                          const aria = `${s} string, ${posLabel(col)}, ${fingerLabel(f)}${label ? `, notes ${label}` : ''}`;
                          return (
                            <div key={k} className={`fb-mark ${isActiveCell ? 'active' : (isTrain ? '' : 'dim')}`} tabIndex={0}
                                 role="button" aria-label={aria} title={`${s} ‚Ä¢ ${posLabel(col)} ‚Ä¢ ${fingerLabel(f)}`}>
                              <div style={{ position:'absolute', top: 4, left: 6, fontSize: 10, opacity: .85 }}>{f}</div>
                              {label && <div className="fb-mark note">{label}</div>}
                            </div>
                          );
                        })}
                      </div>
                    );
                  })}
                </div>
              ))}
            </div>
            <div className="fb-foot" aria-hidden>
              Orientation: E (top) ‚Üí G (bottom). {isTrain ? 'Training view shows finger + notes.' : 'Testing view dims context and highlights the target.'}
            </div>
          </div>

          {showStaff && active?.s && active?.note && (
            <StaffNote
              s={active.s}
              note={active.note}
              label={staffTitle || `Target: ${norm(active.note)}  ‚Ä¢  ${fullLoc(active.s, active.p, active.f)}`}
            />
          )}
        </div>
      );
    };

    /* =========================================================
       Heatmaps (Accuracy; Tempo)
    ========================================================== */
    const tileColor = (total, acc) => {
      if (!total) return 'rgba(120,120,120,0.18)';
      const hue = 140 * acc, sat = 85, light = 45 + 10 * acc;
      return `hsla(${hue}, ${sat}%, ${light}%, 1)`;
    };

    const AccuracyHeatmap = ({ stats }) => (
      <div className="card rounded-xl p-4">
        <div className="text-lg font-semibold mb-2">Fingerboard Accuracy</div>
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          {STRINGS.map(s => (
            <div key={s} className="rounded-lg border overflow-hidden">
              <div className="px-3 py-2 font-semibold" style={{ background: 'rgba(0,0,0,.04)', whiteSpace:'nowrap' }}>
                {s} string
              </div>
              <div className="p-2">
                <div className="fb-strip">
                  {POSITIONS.map(p => (
                    <div key={p} className="fb-pos rounded-md border">
                      <div className="fb-grid p-2">
                        {FINGERS.map(f => {
                          const isReal = !!validCell(s, p, f);
                          const k = `${s}:${p}:${f}`;
                          const st = isReal ? (stats[k] || { correct:0, total:0 }) : null;
                          const style = evidenceStyle(st);
                          return (
                            <div
                              key={f}
                              className="fb-tile"
                              title={isReal ? `${fullLoc(s,p,f)} ‚Äî ${st.correct||0}/${st.total||0} (acc ${st.total?Math.round((st.correct/st.total)*100):0}%; LB ${st.total?Math.round(style.lb*100):0}%)` : 'Not a valid finger/position'}
                              aria-label={isReal ? `${fullLoc(s,p,f)}. ${st.total||0} attempts, ${st.correct||0} correct. Lower bound ${Math.round(style.lb*100)} percent` : 'Invalid cell'}
                              style={{
                                border: isReal ? '1px solid rgba(0,0,0,0.08)' : '1px dashed rgba(0,0,0,0.20)',
                                background: 'transparent',
                                color: isReal ? style.text : '#9ca3af'
                              }}
                            >
                              <div style={{ fontWeight:600 }}>F{f}</div>
                              <div className="text-xs">
                                {isReal && st.total ? `${Math.round((st.correct/st.total)*100)}%` : '‚Äî'}
                              </div>
                              <div className="fb-band" style={{ background: isReal ? style.bandColor : 'rgba(0,0,0,0.08)' }} />
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ))}
        </div>

        <p className="text-xs muted mt-2">
          Legend ‚Äî <b>Gray:</b> unseen ¬∑ <span style={{color:'#ef4444',fontWeight:600}}>Red:</span> needs work (<i>LB</i>&lt;65%)
          ¬∑ <span style={{color:'#f59e0b',fontWeight:600}}>Yellow:</span> developing (65‚Äì85%)
          ¬∑ <span style={{color:'#10b981',fontWeight:600}}>Green:</span> strong (‚â•85%). Bands use the 95% Wilson lower confidence bound; opacity increases with attempts.
        </p>
      </div>
    );

    const TempoHeatmap = ({ stats, terms }) => (
      <div className="card rounded-xl p-4">
        <div className="text-lg font-semibold mb-2">Tempo Heatmap</div>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
          {terms.map(t => {
            const st = stats[t.it] || { correct:0, total:0 };
            const acc = st.total ? st.correct/st.total : 0;
            const bg = tileColor(st.total, acc);
            return (
              <div key={t.it} className="rounded border p-3" style={{background:bg}} title={`${t.it} ‚Äî ${st.correct}/${st.total} (${Math.round(acc*100)}%)`}>
                <div className="font-semibold">{t.it}</div>
                <div className="text-xs">{st.total ? `${Math.round(acc*100)}%` : '‚Äî'}</div>
              </div>
            );
          })}
        </div>
      </div>
    );

    /* =========================================================
       Tempo data / Bieler Method decks (as provided)
    ========================================================== */
    const TEMPOS = [
      { it:'Prestissimo', en:'super fast' },
      { it:'Presto',      en:'very fast' },
      { it:'Allegro',     en:'fast/happy' },
      { it:'Allegretto',  en:'medium moving/motion, brisk' },
      { it:'Andante',     en:'walking tempo/speed' },
      { it:'Andantino',   en:'little walking (near Andante)' },
      { it:'Adagio',      en:'slow (majestic), at ease' },
      { it:'Largo',       en:'slow-largeness, broad' },
      { it:'Lento',       en:'very slow' },
    ];

    const BIELER_VOCAB = [
      { term:'Basic Left-Hand Position', def:'Balanced, rounded hand with natural finger curvature over the string; thumb relaxed opposite 1st‚Äì2nd finger.' },
      { term:'Three-Dimensional Positioning', def:'Aligns height, depth, and angle of the violin relative to torso to free both hands.' },
      { term:'Hand Frame', def:'Stable spacing of fingers across semitone/whole-tone patterns; frame travels during shifts.' },
      { term:'First Trained Function', def:'Accurate finger placement (intonation and spacing) within a stable frame.' },
      { term:'Second Trained Function', def:'Finger independence and agility (lifting/placing without disturbing neighbors).' },
      { term:'Third Trained Function', def:'Shifting‚Äîmoving the whole hand while preserving the frame and sound line.' },
      { term:'Fourth Trained Function', def:'Vibrato‚Äîfinger/hand oscillation integrated with intonation and tone aim.' },
      { term:'Bow Hold', def:'Flexible, pronation-ready grip with curved fingers and mobile thumb.' },
      { term:'Contact Point', def:'Soundpoint between bridge and fingerboard; chosen by speed/pressure/tilt.' },
      { term:'Bow Angles', def:'String crossings via forearm/upper arm levels; keep hair tangent to soundpoint.' },
      { term:'D√©tach√©', def:'Connected, articulated bows; the default singing stroke.' },
      { term:'Legato', def:'Multiple notes under one bow with seamless changes.' },
      { term:'Coll√©', def:'Pinch-and-release articulation from the fingers near the bow start.' },
      { term:'Martel√©', def:'Accented, stopped stroke‚Äîbite, release, ring.' },
      { term:'Spiccato', def:'Controlled bounce near the balance point‚Äîvertical energy, horizontal timing.' },
      { term:'Sautill√©', def:'Fast natural bow spring at higher speeds; small surface motion.' },
      { term:'Ricochet', def:'Thrown bow that rebounds multiple times with one impulse.' },
      { term:'Firm Staccato', def:'In-the-string articulated stops in one bow direction.' },
      { term:'Flying Staccato', def:'Off-the-string successive stops in a single bow.' },
      { term:'Nature', def:'Use body‚Äôs natural alignments‚Äîeconomy, ease, resonance.' },
      { term:'Nurture', def:'Stepwise training‚Äîpatterns before speed; stability before flourish.' },
      { term:'Knowledge', def:'Clear mental models: maps, sound ideals, mechanics.' },
      { term:'Necessity', def:'Technique serves musical intent; choose tools by purpose.' },
    ];

    const BIELER_CONCEPT_QA = [
      { q:'Why does ‚Äúhand frame‚Äù matter before speed drills?', a:'It stabilizes finger spacing so motion stays accurate as tempo rises.', wrong:['It builds arm muscle only','It makes vibrato louder','It avoids all shifts'] },
      { q:'Best cue to pick a contact point?', a:'Balance of bow speed & pressure to the tone color you want.', wrong:['Player height','String brand','Left-hand position only'] },
      { q:'Core difference: spiccato vs sautill√©?', a:'Spiccato is placed/rebounded; sautill√© is natural spring at faster tempi.', wrong:['Spiccato is legato','Sautill√© is always loud','They are the same stroke'] },
      { q:'What should move in most string crossings?', a:'Forearm level first, then upper arm for large distances.', wrong:['Fingers only','Wrist only','Whole torso always'] },
    ];

    const BIELER_APPLY = [
      { scenario:'Bright forte in 1st position on A string, clear projection.', answer:'Move soundpoint closer to bridge, increase bow speed with supportive index; keep hand frame stable for intonation.', wrong:['Move to fingerboard with lighter bow','Only vibrato faster','Tighten right thumb and press hard'] },
      { scenario:'Clean off-string articulation at MM=100, 8ths.', answer:'Spiccato near balance point with small vertical energy; consistent level changes.', wrong:['Wide arm throws at tip','Heavy martel√© at frog','Fast ricochet near bridge'] },
      { scenario:'Warm dolce line in 3rd position', answer:'More over-fingerboard soundpoint, lower pressure, continuous legato changes; left-hand frame glides in shifts.', wrong:['Stiff wrist coll√©','Firm staccato','Always play sul ponticello'] },
    ];

    /* =========================================================
       Games / Trainers (TempoTrainer, TempoTester, HeightDrill, NoteLocator,
       ShiftCoach, HarmonicsLab, SpeedLadder, Flashcards, Bingo)
       ‚Äî identical logic to your originals with small guards
    ========================================================== */
    const ConfettiBurst = ({ seed }) => {
      const [pieces, setPieces] = useState([]);
      useEffect(() => {
        if (!seed) return;
        const EMOJI = ['‚ú®','üéâ','üéä','‚≠ê','üí•','üåü'];
        const n = 24;
        const arr = Array.from({ length: n }, (_, i) => ({
          id: i, left: Math.random()*100, rot: (Math.random()*40)-20, delay: Math.random()*100, emoji: EMOJI[Math.floor(Math.random()*EMOJI.length)]
        }));
        setPieces(arr);
        const t = setTimeout(()=>setPieces([]), 900);
        return () => clearTimeout(t);
      }, [seed]);
      if (!pieces.length) return null;
      return (
        <div className="pointer-events-none fixed inset-0 overflow-hidden z-50">
          {pieces.map(p => (
            <span key={p.id} style={{position:'absolute', left:`${p.left}vw`, top:'-10px', transform:`rotate(${p.rot}deg)`, animation:'fall 0.9s ease-in forwards', animationDelay:`${p.delay}ms`, fontSize:'20px' }}>
              {p.emoji}
            </span>
          ))}
          <style>{`@keyframes fall{to{transform:translateY(110vh); opacity:.65;}}`}</style>
        </div>
      );
    };

    const allActualCombos = () => {
      const arr = [];
      for (const s of STRINGS) for (const p of POSITIONS) for (const f of FINGERS) {
        const cell = validCell(s,p,f);
        if (cell) arr.push({ s, p, f,