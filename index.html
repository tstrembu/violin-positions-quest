<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Violin Positions Quest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    .font-inter { font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; }
    html, body { height: 100%; }
    body { margin: 0; background: #f3f4f6; }
  </style>
  <!-- PWA hooks -->
  <link rel="manifest" href="/violin-positions-quest/manifest.webmanifest">
  <link rel="apple-touch-icon" href="/violin-positions-quest/icons/icon-192.png">
  <meta name="theme-color" content="#6d28d9">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Tailwind Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { theme: { extend: { fontFamily: { inter: ['Inter','ui-sans-serif','system-ui'] }}}};
  </script>
  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo, useEffect, useRef } = React;

    /* =========================
       Shared UI Bits
       ========================= */
    const AppHeader = ({ title, subtitle }) => (
      <header className="p-6 text-center">
        <h1 className="text-3xl font-bold text-gray-800 font-inter">{title}</h1>
        <p className="text-sm text-gray-600 font-inter">{subtitle}</p>
      </header>
    );

    const GameCard = ({ title, description, onClick }) => (
      <button
        onClick={onClick}
        className="bg-white rounded-lg shadow-lg p-6 m-4 w-full text-left cursor-pointer transition-transform hover:scale-[1.02] focus:outline-none focus:ring-2 focus:ring-purple-500"
      >
        <h3 className="text-xl font-semibold text-purple-700 mb-2 font-inter">{title}</h3>
        <p className="text-gray-600 font-inter">{description}</p>
      </button>
    );

    const ActionButton = ({ onClick, children, className = '', disabled = false, title }) => (
      <button
        onClick={onClick}
        disabled={disabled}
        title={title}
        className={`px-6 py-3 rounded-full font-bold text-white transition-all transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-offset-2 ${disabled ? 'opacity-50 cursor-not-allowed' : ''} ${className}`}
      >
        {children}
      </button>
    );

    const Toggle = ({ label, checked, onChange }) => (
      <label className="inline-flex items-center gap-2 text-sm mr-4">
        <input type="checkbox" checked={checked} onChange={e => onChange(e.target.checked)} className="h-4 w-4" />
        <span className="select-none">{label}</span>
      </label>
    );

    /* =========================
       Core Fingerboard Data (unchanged)
       ========================= */
    const NOTES_DATA = {
      G: {
        1: { 1: ['A♭', 'A'], 2: ['B♭', 'B'], 3: ['C', 'C#'], 4: ['D'] },
        2: { 1: ['B♭', 'B'], 2: ['B', 'C'], 3: ['C', 'C#'], 4: ['D', 'D#'] },
        3: { 1: ['C', 'C#'], 2: ['C#', 'D'], 3: ['D', 'D#'], 4: ['E', 'F'] },
      },
      D: {
        1: { 1: ['E♭', 'E'], 2: ['F', 'F#'], 3: ['G', 'G#'], 4: ['A'] },
        2: { 1: ['F', 'F#'], 2: ['F#', 'G'], 3: ['G', 'G#'], 4: ['A', 'A#'] },
        3: { 1: ['G', 'G#'], 2: ['G#', 'A'], 3: ['A', 'A#'], 4: ['B', 'C'] },
      },
      A: {
        1: { 1: ['B♭', 'B'], 2: ['C', 'C#'], 3: ['D', 'D#'], 4: ['E'] },
        2: { 1: ['C', 'C#'], 2: ['C#', 'D'], 3: ['D', 'D#'], 4: ['E', 'F'] },
        3: { 1: ['D', 'D#'], 2: ['D#', 'E'], 3: ['E', 'F'], 4: ['G', 'G#'] },
      },
      E: {
        1: { 1: ['F', 'F#'], 2: ['G', 'G#'], 3: ['A', 'A#'], 4: ['B'] },
        2: { 1: ['G', 'G#'], 2: ['G#', 'A'], 3: ['A', 'A#'], 4: ['B', 'C'] },
        3: { 1: ['A', 'A#'], 2: ['A#', 'B'], 3: ['B', 'C'], 4: ['C#', 'D'] },
      },
    };
    const STRINGS = ['G', 'D', 'A', 'E'];
    const POSITIONS = ['1', '2', '3'];
    const FINGERS = ['1', '2', '3', '4'];

    /* =========================
       Helpers & Persistence (shared)
       ========================= */
    const shuffle = (arr) => {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    };
    const getRandomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];

    const ALL_NOTES_UNIQUE = (() => {
      const set = new Set();
      STRINGS.forEach(s =>
        POSITIONS.forEach(p =>
          FINGERS.forEach(f => NOTES_DATA[s][p][f].forEach(n => set.add(n)))
        )
      );
      return [...set];
    })();

    const getRandomDistractors = (excludeSet, count = 3) => {
      const pool = ALL_NOTES_UNIQUE.filter(n => !excludeSet.has(n));
      const picks = new Set();
      while (picks.size < Math.min(count, pool.length)) {
        picks.add(pool[Math.floor(Math.random() * pool.length)]);
      }
      return [...picks];
    };

    const BEST_KEY = 'positionsQuest.speed.best';
    const STATS_KEY = 'positionsQuest.speed.stats';
    const PREFS_KEY = 'positionsQuest.prefs';
    const PRESETS_KEY = 'positionsQuest.filterPresets.v1';
    const SESSIONLOG_KEY = 'positionsQuest.sessions.v1';

    const loadBest = () => { try { return JSON.parse(localStorage.getItem(BEST_KEY)) || { bestScore: 0, bestStreak: 0 }; } catch { return { bestScore: 0, bestStreak: 0 }; } };
    const saveBest = (obj) => { try { localStorage.setItem(BEST_KEY, JSON.stringify(obj)); } catch {} };

    const loadStats = () => { try { return JSON.parse(localStorage.getItem(STATS_KEY)) || {}; } catch { return {}; } };
    const saveStats = (obj) => { try { localStorage.setItem(STATS_KEY, JSON.stringify(obj)); } catch {} };

    const defaultFilters = {
      strings: Object.fromEntries(STRINGS.map(s => [s, true])),
      positions: Object.fromEntries(POSITIONS.map(p => [p, true])),
      fingers: Object.fromEntries(FINGERS.map(f => [f, true])),
    };
    const loadPrefs = () => {
      try {
        const p = JSON.parse(localStorage.getItem(PREFS_KEY));
        return {
          sound: true,
          confetti: true,
          adaptive: true,
          coach: true,
          coachRetry: true,
          callouts: true,     // enable by default for Tempo games
          roundLen: 120,
          goalEnabled: false,
          goalTarget: 10,
          filters: { ...defaultFilters, ...(p?.filters || {}) },
          ...(p || {})
        };
      } catch {
        return {
          sound: true, confetti: true, adaptive: true, coach: true, coachRetry: true,
          callouts: true, roundLen: 120, goalEnabled: false, goalTarget: 10, filters: defaultFilters
        };
      }
    };
    const savePrefs = (obj) => { try { localStorage.setItem(PREFS_KEY, JSON.stringify(obj)); } catch {} };

    /* =========================
       Confetti + Audio + Callouts (shared)
       ========================= */
    const ConfettiBurst = ({ seed }) => {
      const [pieces, setPieces] = useState([]);
      useEffect(() => {
        if (!seed) return;
        const EMOJI = ['✨','🎉','🎊','⭐','💥','🌟'];
        const n = 26;
        const arr = Array.from({ length: n }, (_, i) => ({
          id: i,
          left: Math.random() * 100,
          rot: (Math.random() * 40) - 20,
          delay: Math.random() * 100,
          emoji: EMOJI[Math.floor(Math.random() * EMOJI.length)],
        }));
        setPieces(arr);
        const t = setTimeout(() => setPieces([]), 900);
        return () => clearTimeout(t);
      }, [seed]);
      if (!pieces.length) return null;
      return (
        <div className="pointer-events-none fixed inset-0 overflow-hidden z-50">
          {pieces.map(p => (
            <span
              key={p.id}
              style={{
                position: 'absolute',
                left: `${p.left}vw`,
                top: '-10px',
                transform: `rotate(${p.rot}deg)`,
                animation: `fall 0.9s ease-in forwards`,
                animationDelay: `${p.delay}ms`,
                fontSize: '20px',
              }}
            >
              {p.emoji}
            </span>
          ))}
          <style>{`@keyframes fall { to { transform: translateY(110vh); opacity: 0.6; } }`}</style>
        </div>
      );
    };

    const useBeeps = (enabled) => {
      const ctxRef = useRef(null);
      const ensureCtx = () => {
        if (!enabled) return null;
        if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
        return ctxRef.current;
      };
      const beep = (freq = 880, dur = 0.08, type = 'sine') => {
        const ctx = ensureCtx(); if (!ctx) return;
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.value = 0.08; o.connect(g); g.connect(ctx.destination);
        o.start(); setTimeout(() => { o.stop(); }, dur * 1000);
      };
      return { good: () => beep(1046, 0.09, 'triangle'), bad: () => beep(196, 0.12, 'sawtooth') };
    };

    const useCallouts = (enabled) => {
      const speak = (text) => {
        if (!enabled || typeof window === 'undefined' || !window.speechSynthesis) return;
        try {
          const u = new SpeechSynthesisUtterance(text);
          u.lang = 'en-US';
          u.rate = 1.0;
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(u);
        } catch {}
      };
      return { speak };
    };

    /* =========================
       Filters / Presets / Analytics UI (unchanged)
       ========================= */
    const loadPresets = () => {
      try {
        const p = JSON.parse(localStorage.getItem(PRESETS_KEY));
        if (p) return p;
      } catch {}
      const seeded = [
        { id: 'f1', name: 'F1 Drills (Low-1 focus)', filters: { strings: {...defaultFilters.strings}, positions: {...defaultFilters.positions}, fingers: { '1': true, '2': false, '3': false, '4': false } } },
        { id: 'pos2da', name: 'All Pos-2 on D/A', filters: { strings: { G:false, D:true, A:true, E:false }, positions: { '1': false, '2': true, '3': false }, fingers: {...defaultFilters.fingers} } },
      ];
      localStorage.setItem(PRESETS_KEY, JSON.stringify(seeded));
      return seeded;
    };
    const savePresets = (list) => { try { localStorage.setItem(PRESETS_KEY, JSON.stringify(list)); } catch {} };

    const PREFS_KEY_TEMPO = 'positionsQuest.tempo.prefs.v1'; // optional: future
    const loadSessions = () => { try { return JSON.parse(localStorage.getItem(SESSIONLOG_KEY)) || []; } catch { return []; } };
    const saveSessions = (arr) => { try { localStorage.setItem(SESSIONLOG_KEY, JSON.stringify(arr)); } catch {} };

    const tileColor = (total, acc) => {
      if (!total) return 'rgba(120,120,120,0.18)';
      const hue = 140 * acc;
      const sat = 0.85, light = 0.45 + 0.1 * acc;
      return `hsl(${hue}deg ${sat*100}% ${light*100}%)`;
    };

    /* =========================
       Accuracy Heatmap (fingerboard) — unchanged
       ========================= */
    const AccuracyHeatmap = ({ stats }) => {
      return (
        <div className="w-full max-w-5xl bg-white rounded-lg shadow p-4 mb-4">
          <h3 className="text-lg font-semibold text-gray-800 mb-2">Accuracy Heatmap</h3>
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
            {STRINGS.map(s => (
              <div key={s} className="border rounded-lg overflow-hidden">
                <div className="bg-gray-100 px-3 py-2 font-semibold">{s} string</div>
                <div className="p-2">
                  <div className="grid grid-cols-3 gap-2">
                    {POSITIONS.map(p => (
                      <div key={p} className="rounded-md border">
                        <div className="text-xs text-gray-600 px-2 py-1 border-b">Pos {p}</div>
                        <div className="grid grid-cols-2 gap-1 p-2">
                          {FINGERS.map(f => {
                            const k = `${s}:${p}:${f}`;
                            const st = stats[k] || { correct: 0, total: 0 };
                            const acc = st.total ? st.correct / st.total : 0;
                            const bg = tileColor(st.total, acc);
                            return (
                              <div key={f} className="rounded p-2 text-center text-xs font-semibold"
                                   title={`${s} Pos ${p} F${f} — ${st.correct}/${st.total} (${Math.round(acc*100)}%)`}
                                   style={{ background: bg }}>
                                F{f}<br/>{st.total ? `${Math.round(acc*100)}%` : '—'}
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            ))}
          </div>
          <p className="text-xs text-gray-500 mt-2">Tip: Gray = unseen, red = needs work, green = strong.</p>
        </div>
      );
    };

    /* =========================
       FILTERS PANEL (unchanged)
       ========================= */
    const FiltersPanel = ({ prefs, setPrefs, onResetStats, onExportCSV, best, presets, setPresets }) => {
      const f = prefs.filters;
      const [newPresetName, setNewPresetName] = useState('');

      const toggleGroup = (group, key) => {
        setPrefs(p => {
          const next = { ...p, filters: { ...p.filters, [group]: { ...p.filters[group], [key]: !p.filters[group][key] } } };
          savePrefs(next); return next;
        });
      };

      const setAll = (group, value) => {
        setPrefs(p => {
          const obj = Object.fromEntries(Object.keys(p.filters[group]).map(k => [k, value]));
          const next = { ...p, filters: { ...p.filters, [group]: obj } };
          savePrefs(next); return next;
        });
      };

      const saveCurrentAsPreset = () => {
        if (!newPresetName.trim()) return;
        const id = `user_${Date.now()}`;
        const next = [...presets, { id, name: newPresetName.trim(), filters: JSON.parse(JSON.stringify(prefs.filters)) }];
        setPresets(next); savePresets(next); setNewPresetName('');
      };
      const applyPreset = (id) => {
        const p = presets.find(x => x.id === id);
        if (!p) return;
        setPrefs(prev => { const n = { ...prev, filters: JSON.parse(JSON.stringify(p.filters)) }; savePrefs(n); return n; });
      };
      const deletePreset = (id) => {
        const next = presets.filter(x => x.id !== id);
        setPresets(next); savePresets(next);
      };

      return (
        <div className="w-full max-w-5xl bg-white rounded-lg shadow p-4 mb-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <div className="text-sm text-gray-700">
              Best Score: <b>{best.bestScore}</b> · Best Streak: <b>{best.bestStreak}</b>
            </div>
            <div className="flex flex-wrap items-center gap-3">
              <Toggle label="Adaptive" checked={prefs.adaptive} onChange={v => { const n={...prefs, adaptive:v}; setPrefs(n); savePrefs(n);} } />
              <Toggle label="Coach" checked={prefs.coach} onChange={v => { const n={...prefs, coach:v}; setPrefs(n); savePrefs(n);} } />
              <Toggle label="Retry after miss" checked={!!prefs.coachRetry} onChange={v => { const n={...prefs, coachRetry:v}; setPrefs(n); savePrefs(n);} } />
              <Toggle label="Sound" checked={prefs.sound} onChange={v => { const n={...prefs, sound:v}; setPrefs(n); savePrefs(n);} } />
              <Toggle label="Confetti" checked={prefs.confetti} onChange={v => { const n={...prefs, confetti:v}; setPrefs(n); savePrefs(n);} } />
              <Toggle label="Audio call-outs" checked={prefs.callouts} onChange={v => { const n={...prefs, callouts:v}; setPrefs(n); savePrefs(n);} } />
              <div className="flex items-center gap-2 text-sm">
                <label>Round:</label>
                <select
                  value={prefs.roundLen}
                  onChange={e => { const n={...prefs, roundLen:Number(e.target.value)}; setPrefs(n); savePrefs(n);} }
                  className="border rounded p-1"
                >
                  {[30,60,120,180].map(x=> <option key={x} value={x}>{x}s</option>)}
                </select>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <Toggle label="Goal" checked={prefs.goalEnabled} onChange={v => { const n={...prefs, goalEnabled:v}; setPrefs(n); savePrefs(n);} } />
                <input type="number" min="1" max="100" className="border rounded p-1 w-16"
                  value={prefs.goalTarget}
                  onChange={e => { const n={...prefs, goalTarget:Number(e.target.value)}; setPrefs(n); savePrefs(n);} } />
                <span className="text-xs text-gray-500">correct answers</span>
              </div>
              <ActionButton onClick={onResetStats} className="bg-rose-600 hover:bg-rose-700">Reset Stats</ActionButton>
              <ActionButton onClick={onExportCSV} className="bg-emerald-600 hover:bg-emerald-700" title="Export CSV of training stats">Export CSV</ActionButton>
            </div>
          </div>

          {/* Presets */}
          <div className="mt-4">
            <div className="flex items-center justify-between mb-2">
              <h4 className="font-semibold">Filter Presets</h4>
              <div className="flex items-center gap-2">
                <input value={newPresetName} onChange={e=>setNewPresetName(e.target.value)} placeholder="Preset name…" className="border rounded p-1" />
                <ActionButton onClick={saveCurrentAsPreset} className="bg-blue-600 hover:bg-blue-700">Save Preset</ActionButton>
              </div>
            </div>
            <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-2">
              {presets.map(pr => (
                <div key={pr.id} className="border rounded p-2 flex items-center justify-between">
                  <div className="text-sm">{pr.name}</div>
                  <div className="flex gap-2">
                    <ActionButton onClick={()=>applyPreset(pr.id)} className="bg-purple-600 hover:bg-purple-700">Apply</ActionButton>
                    {pr.id.startsWith('user_') && (
                      <ActionButton onClick={()=>deletePreset(pr.id)} className="bg-gray-600 hover:bg-gray-700">Delete</ActionButton>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Filters */}
          <div className="mt-4 grid md:grid-cols-3 gap-4">
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold">Strings</h4>
                <div className="text-xs">
                  <button className="underline mr-2" onClick={() => setAll('strings', true)}>All</button>
                  <button className="underline" onClick={() => setAll('strings', false)}>None</button>
                </div>
              </div>
              <div className="flex flex-wrap gap-2">
                {STRINGS.map(s => (
                  <button key={s} onClick={() => toggleGroup('strings', s)}
                    className={`px-3 py-1 rounded-full text-sm border ${f.strings[s] ? 'bg-purple-600 text-white border-purple-700' : 'bg-gray-100 text-gray-700 border-gray-300'}`}>
                    {s}
                  </button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold">Positions</h4>
                <div className="text-xs">
                  <button className="underline mr-2" onClick={() => setAll('positions', true)}>All</button>
                  <button className="underline" onClick={() => setAll('positions', false)}>None</button>
                </div>
              </div>
              <div className="flex flex-wrap gap-2">
                {POSITIONS.map(p => (
                  <button key={p} onClick={() => toggleGroup('positions', p)}
                    className={`px-3 py-1 rounded-full text-sm border ${f.positions[p] ? 'bg-purple-600 text-white border-purple-700' : 'bg-gray-100 text-gray-700 border-gray-300'}`}>
                    Pos {p}
                  </button>
                ))}
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold">Fingers</h4>
                <div className="text-xs">
                  <button className="underline mr-2" onClick={() => setAll('fingers', true)}>All</button>
                  <button className="underline" onClick={() => setAll('fingers', false)}>None</button>
                </div>
              </div>
              <div className="flex flex-wrap gap-2">
                {FINGERS.map(fn => (
                  <button key={fn} onClick={() => toggleGroup('fingers', fn)}
                    className={`px-3 py-1 rounded-full text-sm border ${f.fingers[fn] ? 'bg-purple-600 text-white border-purple-700' : 'bg-gray-100 text-gray-700 border-gray-300'}`}>
                    F{fn}
                  </button>
                ))}
              </div>
            </div>
          </div>

          <p className="text-xs text-gray-500 mt-3">Focus Mode pulls questions only from your selected subset (falls back to all if deselected).</p>
        </div>
      );
    };

    /* =========================
       Tempo Data + Storage
       ========================= */
    const TEMPOS = [
      { it:"Prestissimo", en:"super fast" },
      { it:"Presto",      en:"very fast" },
      { it:"Allegro",     en:"fast, happy" },
      { it:"Allegretto",  en:"fairly brisk" },
      { it:"Andante",     en:"walking speed" },
      { it:"Andantino",   en:"little walking (near Andante)" },
      { it:"Adagio",      en:"slow, at ease" },
      { it:"Largo",       en:"broad, slow" },
      { it:"Lento",       en:"very slow" },
    ];

    const TEMPO_STATS_KEY = 'positionsQuest.tempo.stats.v1';
    const TEMPO_BEST_KEY  = 'positionsQuest.tempo.best.v1';

    const loadTempoStats = () => { try { return JSON.parse(localStorage.getItem(TEMPO_STATS_KEY)) || {}; } catch { return {}; } };
    const saveTempoStats = (obj) => { try { localStorage.setItem(TEMPO_STATS_KEY, JSON.stringify(obj)); } catch {} };

    const loadTempoBest = () => { try { return JSON.parse(localStorage.getItem(TEMPO_BEST_KEY)) || { bestScore:0, bestStreak:0 }; } catch { return {bestScore:0,bestStreak:0}; } };
    const saveTempoBest = (obj) => { try { localStorage.setItem(TEMPO_BEST_KEY, JSON.stringify(obj)); } catch {} };

    /* =========================
       Tempo Heatmap
       ========================= */
    const TempoHeatmap = ({ stats }) => {
      const order = TEMPOS.map(t => t.it);
      return (
        <div className="w-full max-w-3xl bg-white rounded-lg shadow p-4 mb-4">
          <h3 className="text-lg font-semibold text-gray-800 mb-2">Tempo Heatmap</h3>
          <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
            {order.map(it => {
              const st = stats[it] || { correct:0, total:0 };
              const acc = st.total ? st.correct/st.total : 0;
              const bg = tileColor(st.total, acc);
              return (
                <div key={it} className="rounded border p-3" style={{ background:bg }}
                     title={`${it} — ${st.correct}/${st.total} (${Math.round(acc*100)}%)`}>
                  <div className="font-semibold">{it}</div>
                  <div className="text-xs">{st.total ? `${Math.round(acc*100)}%` : '—'}</div>
                </div>
              );
            })}
          </div>
          <p className="text-xs text-gray-500 mt-2">Tracks your accuracy for each Italian term over time.</p>
        </div>
      );
    };

    /* =========================
       NEW Tempo Trainer (Flashcards)
       ========================= */
    const TempoTrainer = ({ onBack, prefs }) => {
      const [index, setIndex] = useState(0);
      const [show, setShow] = useState(false);
      const { speak } = useCallouts(prefs.callouts);

      useEffect(() => {
        // Speak the Italian term on first show or when index changes
        speak(TEMPOS[index].it);
      }, [index]);

      const next = () => { setShow(false); setIndex((index + 1) % TEMPOS.length); };
      const prev = () => { setShow(false); setIndex((index - 1 + TEMPOS.length) % TEMPOS.length); };
      const reveal = () => setShow(true);

      useEffect(() => {
        const onKey = (e) => {
          const k = e.key.toLowerCase();
          if (k === ' ') { e.preventDefault(); reveal(); }
          else if (k === 'n' || k === 'arrowright') next();
          else if (k === 'p' || k === 'arrowleft') prev();
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [index, show]);

      const card = TEMPOS[index];

      return (
        <div className="flex flex-col items-center p-4 bg-gray-100 min-h-screen">
          <div className="bg-white rounded-xl shadow-lg p-8 w-full max-w-2xl">
            <h2 className="text-3xl font-bold text-center text-purple-700 mb-4 font-inter">Tempo Trainer (Flashcards)</h2>
            <div className="border-2 border-gray-300 rounded-xl p-6 text-center">
              <p className="text-xl font-inter text-gray-800 mb-4">{card.it}</p>
              {show ? (
                <div className="space-y-1">
                  <p className="text-lg font-semibold text-green-700 font-inter">{card.en}</p>
                  <p className="text-sm text-gray-500">Tip: say it aloud, then speak a metronome feel to match.</p>
                </div>
              ) : (
                <p className="text-gray-400 italic font-inter">Press Space or tap “Reveal”.</p>
              )}
            </div>
            <div className="flex justify-center gap-3 mt-6">
              <ActionButton onClick={reveal} className="bg-blue-600 hover:bg-blue-700">Reveal</ActionButton>
              <ActionButton onClick={prev} className="bg-gray-600 hover:bg-gray-700">Previous</ActionButton>
              <ActionButton onClick={next} className="bg-purple-600 hover:bg-purple-700">Next</ActionButton>
            </div>
            <p className="text-center text-sm text-gray-500 mt-4 font-inter">
              Card {index + 1} / {TEMPOS.length} · Shortcuts: Space (reveal), ←/→ or P/N (nav)
            </p>
          </div>
          <ActionButton onClick={onBack} className="mt-8 bg-gray-500 hover:bg-gray-600">Back</ActionButton>
        </div>
      );
    };

    /* =========================
       NEW Tempo Tester (Scored MCQ + Heatmap)
       ========================= */
    const TempoTester = ({ onBack, prefs }) => {
      const [best, setBest] = useState(loadTempoBest());
      const [stats, setStats] = useState(loadTempoStats());
      const [timer, setTimer] = useState(prefs.roundLen || 60);
      const [finished, setFinished] = useState(false);
      const [score, setScore] = useState(0);
      const [answered, setAnswered] = useState(0);
      const [streak, setStreak] = useState(0);
      const [confettiSeed, setConfettiSeed] = useState(0);
      const [roundEvents, setRoundEvents] = useState([]);
      const { speak } = useCallouts(prefs.callouts);
      const beeps = useBeeps(prefs.sound);
      const optionsRef = useRef([]);
      const [question, setQuestion] = useState(null);

      const pickQuestion = () => {
        const correct = getRandomItem(TEMPOS);
        const distractors = shuffle(TEMPOS.filter(t => t.it !== correct.it)).slice(0,3);
        const options = shuffle([correct.en, ...distractors.map(d=>d.en)]);
        const q = { it: correct.it, correct: correct.en, options };
        setQuestion(q);
        optionsRef.current = options;
        speak(correct.it);
      };

      useEffect(() => { setTimer(prefs.roundLen || 60); }, [prefs.roundLen]);
      useEffect(() => { pickQuestion(); }, []); // first question

      useEffect(() => {
        if (finished) return;
        const id = setInterval(() => {
          setTimer(t => {
            if (t <= 1) {
              clearInterval(id);
              setFinished(true);
              const nb = { bestScore: Math.max(best.bestScore, score), bestStreak: Math.max(best.bestStreak, streak) };
              setBest(nb); saveTempoBest(nb);
              return 0;
            }
            return t - 1;
          });
        }, 1000);
        return () => clearInterval(id);
      }, [finished, score, streak, best]);

      const record = (it, ok) => {
        const st = stats[it] || { correct:0, total:0 };
        const next = { ...stats, [it]: { correct: st.correct + (ok ? 1 : 0), total: st.total + 1 } };
        setStats(next); saveTempoStats(next);
      };

      const handleAnswer = (choice) => {
        if (finished || !question) return;
        const ok = choice === question.correct;
        record(question.it, ok);
        setRoundEvents(e => [{ t: Date.now(), it: question.it, chosen: choice, correct: question.correct, ok }, ...e]);
        setAnswered(a => a + 1);
        if (ok) {
          beeps.good();
          setScore(s => s + 1);
          setStreak(x => x + 1);
          if (prefs.confetti) setConfettiSeed(x => x + 1);
        } else {
          beeps.bad();
          setStreak(0);
        }
        setTimeout(() => { pickQuestion(); }, ok ? 400 : 800);
      };

      useEffect(() => {
        const onKey = (e) => {
          if (finished) return;
          const k = e.key.toLowerCase();
          if (['1','2','3','4'].includes(k)) {
            const idx = Number(k)-1;
            const choice = optionsRef.current?.[idx];
            if (choice) handleAnswer(choice);
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [finished, question]);

      const resetRound = () => {
        setScore(0); setAnswered(0); setStreak(0);
        setTimer(prefs.roundLen || 60);
        setFinished(false);
        setRoundEvents([]);
        setConfettiSeed(0);
        pickQuestion();
      };

      const exportCSV = () => {
        const rows = [['time','term_it','chosen_en','correct_en','ok']];
        [...roundEvents].reverse().forEach(e => rows.push([new Date(e.t).toISOString(), e.it, e.chosen, e.correct, e.ok?'1':'0']));
        const csv = rows.map(r => r.map(x => `"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'tempo_round.csv';
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };

      return (
        <div className="relative flex flex-col items-center p-4 bg-gray-100 min-h-screen">
          <ConfettiBurst seed={confettiSeed} />
          <div className="bg-white rounded-xl shadow-lg p-8 w-full max-w-xl">
            <h2 className="text-3xl font-bold text-center text-purple-700 mb-2 font-inter">Tempo Tester (Multiple Choice)</h2>
            <div className="flex flex-col items-center text-sm text-gray-700">
              <div className="mb-1">
                Time: <b>{timer}s</b> · Score: <b>{score}</b> / {answered} · Best score: <b>{best.bestScore}</b> · Best streak: <b>{best.bestStreak}</b>
              </div>
              <div className="mb-4 text-xs text-gray-500">Shortcuts: press <b>1–4</b> to answer quickly.</div>
            </div>

            {finished ? (
              <div className="text-center">
                <p className="text-xl font-inter mb-2">Round over! Final score: <b>{score}</b> / {answered}</p>
                <div className="flex flex-wrap gap-2 justify-center">
                  <ActionButton onClick={resetRound} className="bg-purple-600 hover:bg-purple-700">Play Again</ActionButton>
                  <ActionButton onClick={exportCSV} className="bg-emerald-600 hover:bg-emerald-700">Export Round CSV</ActionButton>
                </div>
              </div>
            ) : question && (
              <>
                <div className="text-center mb-6">
                  <p className="text-2xl font-bold text-gray-800 font-inter">
                    What does <b>{question.it}</b> mean?
                  </p>
                  <p className="text-sm text-gray-500 mt-2">Listen to the call-out, then choose the best translation.</p>
                </div>

                <div className="flex flex-wrap justify-center gap-3">
                  {question.options.map((opt, i) => (
                    <ActionButton
                      key={i}
                      onClick={() => handleAnswer(opt)}
                      className="bg-blue-600 hover:bg-blue-700 text-lg w-60 flex items-center justify-center gap-2"
                      title={`Press ${i+1}`}
                    >
                      <span className="inline-flex items-center justify-center w-6 h-6 rounded-full bg-black/20 text-sm">{i+1}</span>
                      <span>{opt}</span>
                    </ActionButton>
                  ))}
                </div>
              </>
            )}
          </div>

          <div className="mt-6 w-full max-w-3xl">
            <TempoHeatmap stats={stats} />
          </div>

          <ActionButton onClick={onBack} className="mt-4 bg-gray-500 hover:bg-gray-600">Back</ActionButton>
        </div>
      );
    };

    /* =========================
       (All your existing games/components below are unchanged)
       Speed Ladder, Flashcards, Bingo, Dice, Seybold Hub, Scoreboard, Boss Fights…
       ========================= */

    /* ==== Speed Ladder (unchanged) ==== */
    // [kept exactly as in your current file]
    // -- BEGIN existing Speed Ladder and related components --
    // (For brevity in this snippet, your previously shared implementations of:
    //  - SpeedLadderGame
    //  - Flashcards
    //  - BingoBoard
    //  - SeyboldHub (+ DayChecklistTable, IntervalLog, BowLog, WeeklyReflection, MasterChart)
    //  - Scoreboard
    //  - BossFights
    //  - DiceOfDestinyGame
    //  - AccuracyHeatmap (already included above)
    //  remain the same. Paste your existing definitions here exactly as-is.)
    // -- END existing components --

    /* =========================
       Dashboard (adds two cards)
       ========================= */
    const Dashboard = ({ go, prefs, setPrefs, stats, setStats, seyboldState }) => {
      const [best, setBest] = useState(loadBest());
      const [presets, setPresets] = useState(loadPresets());

      useEffect(() => {
        const onStorage = () => setBest(loadBest());
        window.addEventListener('storage', onStorage);
        return () => window.removeEventListener('storage', onStorage);
      }, []);

      const resetAll = () => {
        localStorage.removeItem(BEST_KEY);
        localStorage.removeItem(STATS_KEY);
        setBest({ bestScore: 0, bestStreak: 0 });
        setStats({});
      };

      const exportCSV = () => {
        const rows = [['string','position','finger','correct','total','accuracy']];
        STRINGS.forEach(s => POSITIONS.forEach(p => FINGERS.forEach(f => {
          const k = `${s}:${p}:${f}`;
          const st = stats[k] || { correct:0, total:0 };
          const acc = st.total ? (st.correct / st.total) : 0;
          rows.push([s,p,f, String(st.correct), String(st.total), acc.toFixed(4)]);
        })));
        const csv = rows.map(r => r.map(x => `"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'positions_training_stats.csv';
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };

      return (
        <div className="flex flex-col items-center p-4">
          <AppHeader title="Violin Positions Quest" subtitle="Your daily mission to master the fingerboard!" />

          <FiltersPanel
            prefs={prefs} setPrefs={setPrefs}
            onResetStats={resetAll} onExportCSV={exportCSV}
            best={best} presets={presets} setPresets={setPresets}
          />

          <AccuracyHeatmap stats={stats} />

          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 w-full max-w-5xl">
            <GameCard title="Speed Ladder" description="2-minute round (configurable). Adaptive + Coach. Eyes-off call-outs. Replay misses. Shortcuts: 1–4" onClick={() => go('speed')} />
            <GameCard title="Dice of Destiny" description="Press your luck for a random practice challenge." onClick={() => go('dice')} />
            <GameCard title="Positions Bingo" description="Fill a line. Center is FREE. Press R to reshuffle." onClick={() => go('bingo')} />
            <GameCard title="Flashcards Mode" description="Deck A: Direct Hit · Deck B: Note → grouped locations." onClick={() => go('cards')} />
            <GameCard title="Seybold Hub" description="Weekly checklist, logs, reflections, master chart." onClick={() => go('seybold')} />
            <GameCard title="Scoreboard & Badges" description="0–5 daily scoring + earned badges." onClick={() => go('scoreboard')} />
            <GameCard title="Boss Fights I–III" description="Beat the checks to clear bosses." onClick={() => go('boss')} />
            {/* NEW tempo cards */}
            <GameCard title="Tempo Trainer" description="Flashcards for Italian → English with speech call-outs." onClick={() => go('tempoTrainer')} />
            <GameCard title="Tempo Tester" description="Timed multiple choice with streaks, CSV export, and a tempo heatmap." onClick={() => go('tempoTester')} />
          </div>
        </div>
      );
    };

    /* =========================
       App Shell
       ========================= */
    const App = () => {
      const [view, setView] = useState('dashboard');
      const [prefs, setPrefs] = useState(loadPrefs());
      const [stats, setStats] = useState(loadStats());
      const [seyboldState, setSeyboldState] = useState(() => {
        try { return JSON.parse(localStorage.getItem("seybold.hub.v1")) || {}; } catch { return {}; }
      });
      useEffect(() => { savePrefs(prefs); }, [prefs]);
      useEffect(() => { saveStats(stats); }, [stats]);
      useEffect(() => { try { localStorage.setItem("seybold.hub.v1", JSON.stringify(seyboldState)); } catch {} }, [seyboldState]);

      const go = (v) => setView(v);
      const markFlag = (k,v) => setSeyboldState(s=>({ ...s, flags:{ ...(s.flags||{}), [k]:v }}));

      return (
        <div className="min-h-screen bg-gray-100 font-inter">
          {view === 'dashboard'     && <Dashboard go={go} prefs={prefs} setPrefs={setPrefs} stats={stats} setStats={setStats} seyboldState={seyboldState} />}
          {view === 'speed'         && <SpeedLadderGame prefs={prefs} setPrefs={setPrefs} stats={stats} setStats={setStats} onBack={() => setView('dashboard')} />}
          {view === 'dice'          && <DiceOfDestinyGame onBack={() => setView('dashboard')} />}
          {view === 'bingo'         && <BingoBoard onBack={() => setView('dashboard')} markFlag={markFlag} />}
          {view === 'cards'         && <Flashcards onBack={() => setView('dashboard')} />}
          {view === 'seybold'       && <SeyboldHub onBack={() => setView('dashboard')} />}
          {view === 'scoreboard'    && <Scoreboard seyboldState={seyboldState} onBack={() => setView('dashboard')} />}
          {view === 'boss'          && <BossFights onBack={() => setView('dashboard')} markFlag={markFlag} />}
          {/* NEW views */}
          {view === 'tempoTrainer'  && <TempoTrainer prefs={prefs} onBack={() => setView('dashboard')} />}
          {view === 'tempoTester'   && <TempoTester prefs={prefs} onBack={() => setView('dashboard')} />}
        </div>
      );
    };

    // Mount the app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

    // --- iOS audio/TTS unlock (first user gesture) ---
    const unlock = () => {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (ctx && ctx.state === 'suspended') ctx.resume();
      } catch {}
      if (window.speechSynthesis) {
        try { window.speechSynthesis.cancel(); } catch {}
      }
      window.removeEventListener('touchend', unlock);
      window.removeEventListener('click', unlock);
    };
    window.addEventListener('touchend', unlock, { once: true });
    window.addEventListener('click', unlock, { once: true });
  </script>

  <!-- Service worker registration (unchanged) -->
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./sw.js", { scope: "./" });
      });
    }
  </script>
</body>
</html>
